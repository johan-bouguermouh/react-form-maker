{
  "/ReactFormMaker/DOCUMENTATION.md": "# React Form Maker Documentation\r\n\r\n## Introduction\r\n\r\nReact Form Maker est un outil destiné à faciliter le travail d'édition de formulaire simple et répétitif. Il se base sur un approche de JSON simple avec les informations utile à l'insertion des champs lier au formulaire.\r\nReact Form Maker allie la force de React Hook Form & Zod pour assurer un state mangement robuste tout en integrant un validation de formulaire.\r\nReact Form Maker est basé sur ShadCn et la librairie Radix Ui permettant à chaque développeur la possibiliter de modifier à la racine le comportement et l'UI de leurs composant.\r\n\r\n## Philosophie\r\n\r\nCe projet vise à :\r\n\r\n- **Normaliser l'UI** des formulaires grâce à des composants réutilisables et cohérents.\r\n- **Centraliser la logique métier** et la configuration des champs dans des objets ou du JSON, plutôt que dans le JSX.\r\n- **Réduire la quantité de code à écrire** pour chaque formulaire, tout en gardant la puissance de React Hook Form et Zod pour la gestion du contexte et la validation.\r\n- **Faciliter la personnalisation** et la gestion de cas complexes (champs conditionnels, validations avancées, etc.) sans complexifier le code JSX.\r\n\r\n## Concepts clés\r\n\r\n**React Form Maker** adopte un pattern **configuration-driven UI **: l'intégralité du formulaire est décrite par une configuration métier, permettant de générer dynamiquement des composants intelligents et cohérents, tout en gardant la logique métier centralisée et factorisée.\r\n\r\n**ReactFormMaker** propose une architecture où la configuration métier pilote la génération de formulaires, tout en s'appuyant sur une base UI solide et normalisée grâce à shadcn/ui.\r\nCette approche garantit des formulaires cohérents, personnalisables et faciles à maintenir, tout en limitant la verbosité du code JSX.\r\n\r\n## Utilisation du Composant `ReactFormMaker`\r\n\r\n### Props du Composant\r\n\r\nVoici la liste des props acceptées par le composant `ReactFormMaker` :\r\n\r\n- **`formfields`**\r\n    - Type : `CompositeField[]`\r\n    - Requis : Oui\r\n    - Description : Un tableau de définitions de champs de formulaire utilisées pour générer le formulaire. Chaque objet dans le tableau configure un champ ou un groupe de champs (fieldset).\r\n    - Exemple :\r\n      ```typescript\r\n      const formfields = [\r\n        { name: 'username', type: 'text', label: 'Username', validation: { required: true } },\r\n        { name: 'email', type: 'email', label: 'Email', validation: { required: true, isEmail: true } }\r\n      ];\r\n      ```\r\n\r\n- **`onSubmit`**\r\n    - Type : `(data: T | false, errors: FieldErrors<T> | false) => void`\r\n    - Requis : Oui\r\n    - Description : Fonction de rappel déclenchée lors de la soumission du formulaire. Elle reçoit les données du formulaire si la validation réussit, ou les erreurs si la validation échoue.\r\n    - Exemple :\r\n      ```typescript\r\n      function handleSubmit(data, errors) {\r\n        if (data) {\r\n          console.log(\"Formulaire soumis avec succès:\", data);\r\n        } else {\r\n          console.error(\"Erreurs de validation:\", errors);\r\n        }\r\n      }\r\n      ```\r\n\r\n- **`className`**\r\n    - Type : `string`\r\n    - Requis : Optionnel\r\n    - Description : Classe CSS optionnelle pour le conteneur du formulaire. Permet de personnaliser le style du formulaire.\r\n\r\n- **`footerClassName`**\r\n    - Type : `string`\r\n    - Requis : Optionnel\r\n    - Valeur par défaut : `'flex justify-end gap-4'`\r\n    - Description : Classe CSS optionnelle pour la section du pied de page du formulaire, où se trouvent généralement les boutons d'action.\r\n\r\n- **`children`**\r\n    - Type : `React.ReactNode`\r\n    - Requis : Optionnel\r\n    - Description : Enfants React optionnels à rendre à l'intérieur du formulaire. Utile pour insérer des éléments personnalisés ou des boutons d'action supplémentaires dans le pied de page.\r\n\r\n- **`btnTextSubmit`**\r\n    - Type : `string`\r\n    - Requis : Optionnel\r\n    - Valeur par défaut : `'Submit'`\r\n    - Description : Texte à afficher sur le bouton de soumission principal du formulaire.\r\n\r\n- **`btnSubmitClassName`**\r\n    - Type : `string`\r\n    - Requis : Optionnel\r\n    - Description : Classe CSS optionnelle pour le bouton de soumission principal.\r\n\r\n- **`stepper`**\r\n    - Type : `boolean`\r\n    - Requis : Optionnel\r\n    - Valeur par défaut : `false`\r\n    - Description : Si `true`, le formulaire sera rendu sous forme de \"stepper\" (formulaire multi-étapes). Chaque `fieldset` de premier niveau dans `formfields` sera traité comme une étape.\r\n\r\n- **`orientation`**\r\n    - Type : `'horizontal' | 'vertical'`\r\n    - Requis : Optionnel\r\n    - Valeur par défaut : `'horizontal'`\r\n    - Description : Définit l'orientation du stepper (horizontal ou vertical). Utilisé uniquement si `stepper` est à `true`.\r\n\r\n### Exemples d'Utilisation\r\n\r\n#### Exemple simple avec des champs de base\r\n\r\n```tsx\r\nimport ReactFormMaker from './ReactFormMaker'; // Ajustez le chemin d'importation\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { z } from 'zod'; // Assurez-vous d'importer Zod\r\n\r\nconst MyForm = () => {\r\n  const formFieldsDefinition = [\r\n    { inputName: 'firstName', inputType: 'text', label: 'Prénom', zodObject: z.string().min(1, 'Le prénom est requis') },\r\n    { inputName: 'lastName', inputType: 'text', label: 'Nom', zodObject: z.string().min(1, 'Le nom est requis') },\r\n    { inputName: 'age', inputType: 'number', label: 'Âge', zodObject: z.number().min(18, 'Vous devez avoir au moins 18 ans') }\r\n  ];\r\n\r\n  const handleSubmit = (data: FieldValues) => {\r\n    console.log('Données soumises:', data);\r\n  };\r\n\r\n  return (\r\n    <ReactFormMaker\r\n      formfields={formFieldsDefinition}\r\n      onSubmit={handleSubmit}\r\n      btnTextSubmit=\"Envoyer\"\r\n      className=\"my-custom-form\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default MyForm;\r\n```\r\n\r\n#### Exemple avec des enfants personnalisés\r\n\r\nVous pouvez passer des boutons ou d'autres éléments React comme enfants. Ils seront rendus dans le pied de page du formulaire. Si un bouton de type `submit` est passé comme enfant, le bouton de soumission par défaut ne sera pas affiché.\r\n\r\n```tsx\r\nimport ReactFormMaker from './ReactFormMaker'; // Ajustez le chemin d'importation\r\nimport { Button } from '@/components/ui/button'; // Assurez-vous d'avoir un composant Button\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { z } from 'zod'; // Assurez-vous d'importer Zod\r\n\r\nconst FormWithCustomFooter = () => {\r\n  const formFieldsDefinition = [\r\n    { inputName: 'feedback', inputType: 'textarea', label: 'Votre avis', zodObject: z.string().max(200, 'Maximum 200 caractères') }\r\n  ];\r\n\r\n  const handleSubmit = (data: FieldValues) => {\r\n    console.log('Avis soumis:', data);\r\n  };\r\n\r\n  const handleReset = () => {\r\n    // Logique pour réinitialiser le formulaire (nécessite accès à l'instance de formulaire)\r\n    console.log('Formulaire réinitialisé');\r\n  };\r\n\r\n  return (\r\n    <ReactFormMaker\r\n      formfields={formFieldsDefinition}\r\n      onSubmit={handleSubmit}\r\n    >\r\n      <Button type=\"submit\" variant=\"secondary\">Soumettre l'avis</Button>\r\n      <Button type=\"button\" variant=\"outline\" onClick={handleReset}>Réinitialiser</Button>\r\n    </ReactFormMaker>\r\n  );\r\n};\r\n\r\nexport default FormWithCustomFooter;\r\n```\r\n\r\n#### Exemple avec le mode `stepper`\r\n\r\nPour utiliser le mode stepper, vous devez structurer `formfields` avec des objets implémentant `ReactFormMakerStep` (qui sont essentiellement des `ReactFormMakerFieldset` avec des propriétés additionnelles pour le stepper).\r\n\r\n```tsx\r\nimport ReactFormMaker from './ReactFormMaker'; // Ajustez le chemin d'importation\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { z } from 'zod'; // Assurez-vous d'importer Zod\r\n\r\nconst StepperFormExample = () => {\r\n  const stepperFormFields = [\r\n    {\r\n      stepName: 'step1', // Propriété de ReactFormMakerStep\r\n      isStep: true,      // Propriété de ReactFormMakerStep\r\n      legend: 'Étape 1: Informations personnelles',\r\n      fields: [\r\n        { inputName: 'username', inputType: 'text', label: 'Nom d\\'utilisateur', zodObject: z.string().min(1) },\r\n        { inputName: 'email', inputType: 'email', label: 'Email', zodObject: z.string().email() }\r\n      ]\r\n    },\r\n    {\r\n      stepName: 'step2',\r\n      isStep: true,\r\n      legend: 'Étape 2: Adresse',\r\n      fields: [\r\n        { inputName: 'address', inputType: 'text', label: 'Adresse', zodObject: z.string().min(1) },\r\n        { inputName: 'city', inputType: 'text', label: 'Ville', zodObject: z.string().min(1) }\r\n      ]\r\n    },\r\n    {\r\n      stepName: 'step3',\r\n      isStep: true,\r\n      legend: 'Étape 3: Confirmation',\r\n      fields: [\r\n        { inputName: 'confirm', inputType: 'checkbox', label: 'Je confirme mes informations', zodObject: z.boolean().refine(val => val === true) }\r\n      ]\r\n    }\r\n  ];\r\n\r\n  const handleSubmit = (data: FieldValues) => {\r\n    console.log('Données du stepper soumises:', data);\r\n  };\r\n\r\n  return (\r\n    <ReactFormMaker\r\n      formfields={stepperFormFields}\r\n      onSubmit={handleSubmit}\r\n      stepper={true}\r\n      orientation=\"vertical\" // ou \"horizontal\"\r\n      btnTextSubmit=\"Finaliser\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default StepperFormExample;\r\n```\r\n\r\n## Configuration des Champs de Formulaire\r\n\r\nLa prop `formfields` est essentielle pour `ReactFormMaker`. C'est un tableau d'objets qui définit la structure et le comportement de votre formulaire. Chaque objet dans ce tableau peut être un champ individuel, un groupe de champs (fieldset), un séparateur, ou une étape de formulaire (si `stepper` est activé).\r\n\r\n### Interface `CompositeField`\r\n\r\n`CompositeField` est une interface de base dont héritent la plupart des autres configurations de champs. Elle fournit des propriétés communes pour les éléments composables du formulaire.\r\n\r\n| Propriété  | Type                                                                 | Description                                                                                                                               |\r\n| :--------- | :------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `classname`| `string` (optionnel)                                                 | Classe CSS pour styliser l'élément.                                                                                                       |\r\n| `fields`   | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` (optionnel) | Un tableau d'éléments enfants (champs, diviseurs, ou fieldsets). Recommandé pour `ReactFormMakerFieldset`.                                  |\r\n| `isHide`   | `boolean` (optionnel)                                                | Si `true`, masque l'élément. Utile pour cacher des champs conditionnellement.                                                              |\r\n\r\n### Interface `FieldReactFormMaker`\r\n\r\nCette interface définit un champ de formulaire standard (input, select, etc.). Elle hérite de `CompositeField`.\r\n\r\n| Propriété                | Type                                                              | Requis    | Description                                                                                                                                                             |\r\n| :----------------------- | :---------------------------------------------------------------- | :-------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `inputName`              | `string`                                                          | Oui       | Nom unique du champ, utilisé comme clé dans les données du formulaire.                                                                                                   |\r\n| `label`                  | `string`                                                          | Optionnel | Texte affiché au-dessus ou à côté du champ.                                                                                                                              |\r\n| `placeholder`            | `string`                                                          | Optionnel | Texte indicatif affiché dans le champ lorsqu'il est vide.                                                                                                             |\r\n| `inputType`              | `InputType`                                                       | Oui       | Type de champ à afficher (voir la section \"Types de Champs (`InputType`)\" ci-dessous).                                                                                     |\r\n| `zodObject`              | `ZodType<any>`                                                    | Optionnel | Schéma de validation Zod pour ce champ. Recommandé pour une validation robuste.                                                                                          |\r\n| `defaultValues`          | `any`                                                             | Optionnel | Valeur par défaut du champ.                                                                                                                                               |\r\n| `options`                | `string[] \\| { value: string \\| number; label: string }[]`        | Optionnel | Options pour les champs de type `select`, `radio`, `checkbox`, `tileSelector`, `tileMultiSelector`. Requis si `inputType` est l'un de ces types.                               |\r\n| `className`              | `string`                                                          | Optionnel | Classe CSS pour styliser l'élément du champ lui-même.                                                                                                                    |\r\n| `disabled`               | `boolean`                                                         | Optionnel | Si `true`, désactive le champ.                                                                                                                                          |\r\n| `description`            | `string`                                                          | Optionnel | Texte descriptif affiché sous ou à côté du champ pour fournir des informations supplémentaires.                                                                         |\r\n| `isSecure`               | `boolean`                                                         | Optionnel | Si `true`, masque le champ (par exemple, pour des raisons de sécurité, bien que `isHide` soit plus courant pour le masquage dynamique).                                  |\r\n| `onChange`               | `(event: FormFieldEvent) => void`                                 | Optionnel | Fonction de rappel exécutée lorsque la valeur du champ change. L'objet `event` contient une propriété `form` pour interagir avec l'état du formulaire.                   |\r\n| `onBlur`                 | `(event: FormFieldEvent) => void`                                 | Optionnel | Fonction de rappel exécutée lorsque le champ perd le focus.                                                                                                                |\r\n| `onSelect` (ou `onFocus`) | `(event: FormFieldEvent) => void`                                 | Optionnel | Fonction de rappel exécutée lorsque le champ obtient le focus.                                                                                                             |\r\n| `onClick`                | `(event: FormFieldEvent) => void`                                 | Optionnel | Fonction de rappel exécutée lors d'un clic sur le champ (pertinent pour certains types de champs).                                                                      |\r\n| `customInputFieldElement`| `React.ReactNode`                                                 | Optionnel | Permet de remplacer le rendu par défaut du champ par un composant React personnalisé. Doit être un élément de champ valide compatible avec React Hook Form.                 |\r\n| `children`               | `React.ReactNode`                                                 | Optionnel | Enfants React à afficher à l'intérieur de la structure du champ (par exemple, après le champ lui-même mais avant la description).                                         |\r\n| `props`                  | `Record<string, any>`                                             | Optionnel | Propriétés supplémentaires à passer directement à l'élément d'input HTML sous-jacent.                                                                                   |\r\n\r\n#### Types de Champs (`InputType`)\r\n\r\n| Type                 | Description                                                                                                |\r\n| :------------------- | :--------------------------------------------------------------------------------------------------------- |\r\n| `text`               | Champ de saisie de texte standard.                                                                         |\r\n| `password`           | Champ de saisie de mot de passe (masque les caractères).                                                   |\r\n| `select`             | Liste déroulante pour une sélection unique. Nécessite la prop `options`.                                  |\r\n| `selectAutocomplete` | Liste déroulante avec auto-complétion. Nécessite la prop `options`.                                         |\r\n| `multiSelect`        | Liste déroulante pour des sélections multiples. Nécessite la prop `options`.                                |\r\n| `textarea`           | Zone de texte multiligne.                                                                                  |\r\n| `date`               | Sélecteur de date.                                                                                         |\r\n| `dateRange`          | Sélecteur de plage de dates.                                                                               |\r\n| `radio`              | Boutons radio pour une sélection unique parmi plusieurs options. Nécessite la prop `options`.             |\r\n| `checkbox`           | Case à cocher unique (pour une valeur booléenne) ou groupe de cases (si `options` est fourni).            |\r\n| `switch`             | Interrupteur à bascule (généralement pour une valeur booléenne).                                           |\r\n| `file`               | Champ de téléversement de fichier standard.                                                                |\r\n| `fileDropZone`       | Zone de glisser-déposer pour le téléversement de fichiers.                                                 |\r\n| `number`             | Champ de saisie numérique.                                                                                 |\r\n| `custom`             | Utilisé lorsque vous fournissez un `customInputFieldElement`.                                               |\r\n| `tileSelector`       | Sélecteur de tuiles pour une sélection unique. Nécessite la prop `options`.                               |\r\n| `tileMultiSelector`  | Sélecteur de tuiles pour des sélections multiples. Nécessite la prop `options`.                             |\r\n| `phoneNumber`        | Champ de saisie de numéro de téléphone (peut inclure un formatage spécifique).                               |\r\n\r\n### Interface `DividerReactFormMaker`\r\n\r\nUtilisée pour insérer des séparateurs ou des éléments de structuration non interactifs dans le formulaire. Hérite de `CompositeField`.\r\n\r\n| Propriété  | Type                                                                 | Requis    | Description                                                                                                                             |\r\n| :--------- | :------------------------------------------------------------------- | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `isDiv`    | `boolean`                                                            | Oui       | Doit être `true`. Indique que cet élément est un diviseur/conteneur structurel.                                                        |\r\n| `className`| `string`                                                             | Optionnel | Classe CSS pour styliser le diviseur.                                                                                                   |\r\n| `isHide`   | `boolean`                                                            | Optionnel | Si `true`, masque le diviseur.                                                                                                          |\r\n| `fields`   | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` | Optionnel | Permet d'imbriquer d'autres éléments à l'intérieur de ce diviseur, créant une structure de groupe.                                   |\r\n| `children` | `JSX.Element`                                                        | Optionnel | Contenu JSX personnalisé à afficher à l'intérieur du diviseur.                                                                          |\r\n\r\n### Interface `ReactFormMakerFieldset`\r\n\r\nPermet de grouper logiquement des champs sous un titre commun (`legend`). Hérite de `CompositeField`.\r\n\r\n| Propriété        | Type                                                                 | Requis    | Description                                                                                             |\r\n| :--------------- | :------------------------------------------------------------------- | :-------- | :------------------------------------------------------------------------------------------------------ |\r\n| `fieldset`       | `string`                                                             | Oui       | Nom unique pour le fieldset (principalement pour l'organisation interne, pas pour les données du formulaire). |\r\n| `legend`         | `string`                                                             | Optionnel | Titre affiché pour le groupe de champs.                                                                 |\r\n| `legendClassName`| `string`                                                             | Optionnel | Classe CSS pour styliser la légende.                                                                    |\r\n| `className`      | `string`                                                             | Optionnel | Classe CSS pour styliser l'élément fieldset.                                                            |\r\n| `fields`         | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` | Optionnel | Tableau des champs, diviseurs ou autres fieldsets imbriqués dans ce groupe.                             |\r\n| `isHide`         | `boolean`                                                            | Optionnel | Si `true`, masque l'ensemble du fieldset.                                                               |\r\n\r\n### Interface `ReactFormMakerStep`\r\n\r\nDéfinit une étape dans un formulaire de type \"stepper\". Cette interface hérite de `CompositeField` et partage de nombreuses propriétés avec `ReactFormMakerFieldset`, mais ajoute des fonctionnalités spécifiques au stepper. Elle est utilisée lorsque la prop `stepper` de `ReactFormMaker` est à `true`.\r\n\r\n| Propriété               | Type                                                                                 | Requis    | Description                                                                                                                                                                                             |\r\n| :---------------------- | :----------------------------------------------------------------------------------- | :-------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| `stepName`              | `string`                                                                             | Oui       | Nom unique de l'étape, utilisé pour l'identification et la navigation.                                                                                                                                  |\r\n| `isStep`                | `boolean`                                                                            | Optionnel | Doit être `true` pour indiquer que cet élément est une étape du stepper.                                                                                                                                |\r\n| `legend`                | `string`                                                                             | Optionnel | Titre de l'étape, affiché en haut de l'étape.                                                                                                                                                           |\r\n| `legendClassName`       | `string`                                                                             | Optionnel | Classe CSS pour styliser la légende de l'étape.                                                                                                                                                         |\r\n| `className`             | `string`                                                                             | Optionnel | Classe CSS pour styliser le conteneur de l'étape.                                                                                                                                                       |\r\n| `fields`                | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]`           | Optionnel | Tableau des champs, diviseurs ou fieldsets contenus dans cette étape.                                                                                                                                     |\r\n| `isHide`                | `boolean`                                                                            | Optionnel | Si `true`, masque l'étape.                                                                                                                                                                              |\r\n| `children`              | `React.ReactNode`                                                                    | Optionnel | Enfants React personnalisés à afficher dans le contenu de l'étape.                                                                                                                                      |\r\n| `disabledBefore`        | `boolean`                                                                            | Optionnel | Si `true` (par défaut `false`), désactive le bouton \"Précédent\" et la navigation vers les étapes précédentes via l'en-tête du stepper.                                                                 |\r\n| `isStrict`              | `boolean`                                                                            | Optionnel | Si `true` (par défaut `false`), l'utilisateur ne peut pas passer à l'étape suivante tant que tous les champs de l'étape actuelle ne sont pas valides selon leur `zodObject`.                               |\r\n| `onBeforeNextStep`      | `(data: { submissionState: StepFormState<any>; form: UseFormReturn<any>; }) => Promise<boolean>` | Optionnel | Fonction asynchrone exécutée avant de passer à l'étape suivante (après validation). Doit retourner `true` pour autoriser le passage, `false` pour l'empêcher. Permet des logiques de validation avancées. |\r\n| `IconStep`              | `React.ComponentType<any>`                                                           | Optionnel | Composant React personnalisé pour l'icône de l'étape dans l'indicateur de progression du stepper.                                                                                                       |\r\n| `buttonNextContent`     | `string`                                                                             | Optionnel | Texte personnalisé pour le bouton \"Suivant\" de cette étape.                                                                                                                                             |\r\n| `buttonPreviousContent` | `string`                                                                             | Optionnel | Texte personnalisé pour le bouton \"Précédent\" de cette étape.                                                                                                                                           |\r\n| `additionalButtons`     | `React.ReactNode`                                                                    | Optionnel | Éléments JSX supplémentaires (par exemple, des boutons) à afficher dans le pied de page de l'étape, après les boutons de navigation standard.                                                              |\r\n| `footerClassName`       | `string \\| string[]`                                                                   | Optionnel | Classe(s) CSS pour styliser le pied de page de l'étape.                                                                                                                                                 |\r\n\r\n### Exemples de Configuration de Champs\r\n\r\n```typescript\r\nimport { z } from 'zod'; // Assurez-vous d'importer Zod pour les exemples de validation\r\n\r\nexport const formFieldsExamples = [\r\n  // 1. Champ texte simple\r\n  {\r\n    inputName: 'username',\r\n    label: 'Nom d\\'utilisateur',\r\n    inputType: 'text',\r\n    placeholder: 'Entrez votre nom d\\'utilisateur',\r\n    zodObject: z.string().min(3, 'Le nom d\\'utilisateur doit contenir au moins 3 caractères.'),\r\n    description: 'Votre nom d\\'utilisateur public.'\r\n  },\r\n\r\n  // 2. Champ select avec des options\r\n  {\r\n    inputName: 'country',\r\n    label: 'Pays',\r\n    inputType: 'select',\r\n    options: [\r\n      { value: 'fr', label: 'France' },\r\n      { value: 'ca', label: 'Canada' },\r\n      { value: 'us', label: 'États-Unis' }\r\n    ],\r\n    zodObject: z.string().nonempty('Veuillez sélectionner un pays.'),\r\n    defaultValues: 'fr'\r\n  },\r\n\r\n  // 3. Champ checkbox\r\n  {\r\n    inputName: 'subscribe',\r\n    label: 'S\\'abonner à la newsletter',\r\n    inputType: 'checkbox',\r\n    zodObject: z.boolean(),\r\n    defaultValues: true\r\n  },\r\n\r\n  // 4. Groupe de cases à cocher (options pour un même inputName)\r\n  {\r\n    inputName: 'interests',\r\n    label: 'Vos centres d\\'intérêt',\r\n    inputType: 'checkbox',\r\n    options: [\r\n      { value: 'tech', label: 'Technologie' },\r\n      { value: 'sport', label: 'Sport' },\r\n      { value: 'music', label: 'Musique' }\r\n    ],\r\n    zodObject: z.array(z.string()).min(1, 'Veuillez sélectionner au moins un intérêt.'),\r\n    description: 'Cochez tout ce qui s\\'applique.'\r\n  },\r\n\r\n  // 5. Utilisation de ReactFormMakerFieldset pour grouper des champs\r\n  {\r\n    fieldset: 'userProfile', // Nom du fieldset\r\n    legend: 'Profil Utilisateur',\r\n    className: 'user-profile-fieldset',\r\n    fields: [\r\n      {\r\n        inputName: 'firstName',\r\n        label: 'Prénom',\r\n        inputType: 'text',\r\n        zodObject: z.string().min(1, 'Le prénom est requis.')\r\n      },\r\n      {\r\n        inputName: 'lastName',\r\n        label: 'Nom de famille',\r\n        inputType: 'text',\r\n        zodObject: z.string().min(1, 'Le nom de famille est requis.')\r\n      }\r\n    ]\r\n  },\r\n\r\n  // 6. Utilisation de ReactFormMakerStep (pour un formulaire avec stepper={true})\r\n  // Ceci serait un élément du tableau `formfields` principal\r\n  {\r\n    stepName: 'personalInfo',\r\n    isStep: true,\r\n    legend: 'Informations Personnelles',\r\n    fields: [\r\n      {\r\n        inputName: 'fullName',\r\n        label: 'Nom complet',\r\n        inputType: 'text',\r\n        zodObject: z.string().min(2, 'Le nom complet est requis.')\r\n      },\r\n      {\r\n        inputName: 'birthDate',\r\n        label: 'Date de naissance',\r\n        inputType: 'date',\r\n        zodObject: z.date().refine(date => date < new Date(), 'La date doit être dans le passé.')\r\n      }\r\n    ],\r\n    // Propriétés spécifiques au step\r\n    isStrict: true,\r\n    buttonNextContent: 'Suivant : Adresse'\r\n  }\r\n];\r\n```\r\n\r\n## Définition Programmatique des Champs avec `FieldFactory`\r\n\r\nDans de nombreux générateurs de formulaires, la configuration initiale se fait souvent sous forme de JSON (ou d'objets littéraux JavaScript). Si cette approche est universelle et flexible, elle atteint vite ses limites :\r\n\r\n- Les formulaires complexes deviennent difficiles à lire et à maintenir.\r\n- La logique métier (validation, comportements dynamiques) se retrouve dispersée ou dupliquée.\r\n- L’absence de typage fort et d’outils d’autocomplétion nuit à la robustesse du code.\r\n\r\n**`FieldFactory`** répond à ces problématiques en proposant une approche orientée objet pour la définition des champs de formulaire. Elle sert de classe de base à des classes spécialisées (par exemple, `TextField`, `SelectField`, `PasswordField`, etc.), offrant plusieurs avantages :\r\n\r\n-   **Configuration Fluide et Lisible** : Grâce au chaînage de méthodes (method chaining), la configuration des champs devient plus déclarative et expressive.\r\n    ```typescript\r\n    const emailField = new TextField('email')\r\n      .setLabel('Adresse email')\r\n      .isEmail() // Méthode spécifique à TextField pour appliquer une validation d'email\r\n      .setPlaceholder('Entrez votre email')\r\n      .setRequired('L'adresse email est obligatoire.');\r\n    ```\r\n-   **Centralisation de la Logique Métier et Validation** : Chaque classe spécialisée (par exemple, `TextField`) peut embarquer ses propres règles de validation Zod et logiques de comportement. Par exemple, la méthode `.isEmail()` sur une instance de `TextField` pourrait automatiquement configurer le `zodObject` approprié pour la validation d'emails. Cela évite la duplication et garantit la cohérence.\r\n-   **Extensibilité Facilitée** : Ajouter un nouveau type de champ ou une nouvelle règle de validation devient plus simple. Il suffit de créer une nouvelle classe héritant de `FieldFactory` (ou d'une autre classe de champ) ou d'ajouter une nouvelle méthode à une classe existante.\r\n-   **Meilleure Expérience Développeur** : L'utilisation de classes et de TypeScript offre un typage fort, une autocomplétion avancée dans les IDEs, et une documentation intégrée via les TSDoc, réduisant les erreurs et augmentant la productivité.\r\n-   **Configuration Évolutive** : Pour des besoins simples, la configuration par objets littéraux reste possible. Mais pour des formulaires complexes, l'approche orientée objet avec `FieldFactory` permet une structuration plus poussée sans sacrifier la lisibilité ni la maintenabilité.\r\n\r\n### Usage et Utilité\r\n\r\n`FieldFactory` et ses classes dérivées permettent de :\r\n\r\n1.  **Définir des champs de formulaire de façon déclarative et expressive.**\r\n2.  **Centraliser la logique métier et la validation** au sein des classes de champ.\r\n3.  **Faciliter la maintenance et l’évolution** de la configuration des formulaires.\r\n4.  **Bénéficier d’un typage fort et d’une autocomplétion avancée.**\r\n\r\n### Exemple d'Utilisation avec `TextField`\r\n\r\nLa classe `TextField` (située dans `frontend/src/components/ReactFormMaker/FormFields/Class/TextFields.class.ts`) est un exemple de classe dérivée de `FieldFactory`. Voici comment l'utiliser pour définir des champs de texte et les intégrer dans `ReactFormMaker` :\r\n\r\n```typescript\r\n// Assurez-vous que le chemin d'importation est correct\r\nimport { TextField } from './frontend/src/components/ReactFormMaker/FormFields/Class/TextFields.class';\r\nimport ReactFormMaker from './frontend/src/components/ReactFormMaker/ReactFormMaker'; // Ajustez le chemin\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { z } from 'zod'; // Importation de Zod pour d'autres champs si nécessaire\r\n\r\n// Définition des champs en utilisant la classe TextField\r\nconst usernameField = new TextField('username') // 'username' est le inputName\r\n  .setLabel('Nom d\\'utilisateur')\r\n  .setPlaceholder('Votre nom d\\'utilisateur unique')\r\n  .setRequired('Le nom d\\'utilisateur est requis.') // Applique une validation Zod simple\r\n  .setMinLength(5, 'Doit contenir au moins 5 caractères.');\r\n\r\nconst emailField = new TextField('userEmail')\r\n  .setLabel('Adresse Email')\r\n  .isEmail() // Applique la validation Zod pour email et met un placeholder par défaut\r\n  .setRequired('L\\'email est obligatoire.');\r\n\r\nconst websiteField = new TextField('userWebsite')\r\n  .setLabel('Site Web (optionnel)')\r\n  .isUrl() // Applique la validation Zod pour URL et un comportement onSelect\r\n  .setZodObject(z.string().url().optional()); // Permet de surcharger ou affiner le ZodObject\r\n\r\n// Les objets de champ configurés peuvent être directement utilisés dans formfields.\r\n// La méthode .getConfig() de la classe FieldFactory retourne l'objet FieldReactFormMaker.\r\nconst myFormFields = [\r\n  usernameField.getConfig(),\r\n  emailField.getConfig(),\r\n  websiteField.getConfig(),\r\n  // Vous pouvez toujours mélanger avec des objets de configuration littéraux\r\n  {\r\n    inputName: 'age',\r\n    inputType: 'number',\r\n    label: 'Âge',\r\n    zodObject: z.number().min(18)\r\n  }\r\n];\r\n\r\nconst MyComponentUsingFieldFactory = () => {\r\n  const handleSubmit = (data: FieldValues) => {\r\n    console.log('Données du formulaire:', data);\r\n  };\r\n\r\n  return (\r\n    <ReactFormMaker\r\n      formfields={myFormFields}\r\n      onSubmit={handleSubmit}\r\n      btnTextSubmit=\"Soumettre\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default MyComponentUsingFieldFactory;\r\n```\r\n\r\nCette approche favorise une meilleure organisation et réutilisabilité de la configuration de vos champs de formulaire, surtout pour les applications de grande taille.\r\n\r\n## Personnalisation du Style\r\n\r\nLa majorité des champs du formulaire et le composant `ReactFormMaker` lui-même s'appuient sur la bibliothèque de composants **ShadCN/UI**, qui est basée sur **Tailwind CSS**. L'objectif est de centraliser la gestion des styles pour garantir cohérence et maintenabilité, tout en offrant plusieurs niveaux de personnalisation pour s'adapter à des besoins spécifiques.\r\n\r\n### Bonnes pratiques pour la personnalisation du style\r\n\r\nVoici les approches recommandées pour personnaliser l'apparence de vos formulaires :\r\n\r\n1.  **Centralisation via la configuration Tailwind (`tailwind.config.ts`)**\r\n    *   **Description** : C'est la méthode à privilégier pour des modifications globales et cohérentes. En ajustant votre fichier `tailwind.config.ts` (ou `tailwind.config.js`, `postcss.config.mjs` selon votre configuration), vous pouvez redéfinir les couleurs primaires, les polices, les espacements, etc., qui seront appliqués à l'ensemble de votre UI, y compris les composants ShadCN utilisés par `ReactFormMaker`.\r\n    *   **Avantage** : Maintient une cohérence stylistique à travers toute votre application.\r\n\r\n2.  **Surcharge des composants ShadCN/UI (dans le dossier `ui`)**\r\n    *   **Description** : Lorsque vous initialisez ShadCN/UI dans votre projet (via la commande `npx shadcn-ui@latest init`), les composants que vous choisissez d'utiliser (comme `Button`, `Input`, `Select`, etc.) sont ajoutés à votre code base, typiquement dans un dossier `components/ui`. `ReactFormMaker` utilise ces composants. Vous pouvez directement modifier le code de ces composants pour des ajustements plus spécifiques qui ne sont pas possibles via la configuration Tailwind seule.\r\n    *   **Avantage** : Contrôle fin sur l'apparence et le comportement des composants de base.\r\n    *   **Note** : Soyez conscient que si vous mettez à jour les composants ShadCN via leur CLI (`add` pour un composant existant), vos modifications locales pourraient être écrasées. Gérez ces composants comme faisant partie de votre code source.\r\n\r\n3.  **Ajustement des styles des composants spécifiques au projet (`ReactFormMaker/enhancements` et autres)**\r\n    *   **Description** : `ReactFormMaker` peut contenir des composants internes ou des \"enhancements\" (améliorations) qui ne sont pas directement des composants ShadCN/UI bruts. Si ces composants ont leurs propres fichiers de style ou permettent des props de style, vous pouvez les ajuster là. Le chemin exact peut varier, mais explorez la structure du dossier `ReactFormMaker` pour de tels composants.\r\n    *   **Avantage** : Permet de cibler des éléments spécifiques à la logique de `ReactFormMaker`.\r\n\r\n4.  **Personnalisation ponctuelle via la prop `className`**\r\n    *   **Description** :\r\n        *   **Sur le composant `ReactFormMaker`** : La prop `className` permet d'appliquer des classes Tailwind (ou CSS globales) au conteneur principal du formulaire. La prop `footerClassName` cible spécifiquement le pied de page du formulaire.\r\n        *   **Sur les définitions de champs (`formfields`)** : Chaque objet champ dans le tableau `formfields` (qu'il s'agisse d'un `FieldReactFormMaker`, `ReactFormMakerFieldset`, etc.) peut accepter une prop `className` (ou `classname` pour `CompositeField` et ses dérivés comme `ReactFormMakerFieldset`, `legendClassName` pour les légendes de fieldset). Ces classes sont appliquées à l'élément wrapper du champ ou à l'élément spécifique.\r\n    *   **Utilisation de `cn`** : Il est recommandé d'utiliser une fonction utilitaire comme `cn` (souvent fournie par ShadCN/UI, basée sur `clsx` et `tailwind-merge`) pour construire vos chaînes de `className`. `cn` permet de fusionner intelligemment les classes Tailwind, de gérer les classes conditionnelles et d'éviter les conflits de classes.\r\n        ```typescript\r\n        // Exemple dans la configuration d'un champ\r\n        {\r\n          inputName: 'email',\r\n          inputType: 'text',\r\n          label: 'Email',\r\n          className: cn('border-blue-500', { 'bg-gray-100': isDisabled })\r\n        }\r\n        ```\r\n    *   **Avantage** : Idéal pour des ajustements spécifiques à un champ ou à un formulaire sans affecter les autres. Très flexible pour des changements dynamiques basés sur l'état.\r\n\r\nEn combinant ces approches, vous pouvez obtenir un contrôle précis sur l'apparence de vos formulaires générés par `ReactFormMaker`, tout en maintenant une base de style cohérente et facile à gérer.\r\n\r\n## Aspects Avancés\r\n\r\nCette section couvre des fonctionnalités plus avancées de `ReactFormMaker`, destinées aux utilisateurs souhaitant étendre ou personnaliser en profondeur le comportement de leurs formulaires.\r\n\r\n### Hooks Personnalisés\r\n\r\n`ReactFormMaker` utilise en interne plusieurs hooks React pour gérer sa logique. Bien que leur utilisation directe ne soit généralement pas nécessaire pour la plupart des cas d'usage, les connaître peut être utile pour des scénarios d'extension ou de débogage avancé.\r\n\r\n-   **`useReactFormMaker<T extends FieldValues>(formfieldsAttributes: CompositeField[])`**\r\n    *   **Rôle** : Ce hook est au cœur de la génération du formulaire. Il prend la configuration `formfields`, initialise `react-hook-form` (y compris la génération du schéma Zod à partir des `zodObject` des champs et la gestion des valeurs par défaut), et retourne l'instance du formulaire (`form`), le schéma Zod généré (`formSchema`), les valeurs par défaut (`dataFieldsDefaultValues`), l'objet Zod brut (`zObject`), et une fonction utilitaire `hasSubmitButton` pour détecter si un bouton de soumission est déjà présent parmi les enfants.\r\n    *   **Utilité principale** : Gère toute la logique d'initialisation de `react-hook-form` et la transformation de la configuration `formfields` en un schéma Zod utilisable. Principalement utilisé en interne par le composant `ReactFormMaker`.\r\n\r\n-   **`useFormHandlers<T extends FieldValues>({ onSubmit: (data, errors) => void })`**\r\n    *   **Rôle** : Ce hook simplifie la gestion des callbacks de soumission de `react-hook-form`. Il prend une unique fonction `onSubmit` (celle que vous passez à `ReactFormMaker`) et la divise en deux gestionnaires : `onValid` (pour les soumissions réussies) et `onInvalid` (pour les soumissions échouées à cause d'erreurs de validation).\r\n    *   **Utilité principale** : Fournit les fonctions `onValid` et `onInvalid` que `react-hook-form` attend pour sa propre fonction `handleSubmit`. Utilisé en interne pour brancher votre callback `onSubmit` au système de soumission de `react-hook-form`.\r\n\r\n-   **`useFormFieldsMap<T extends FieldValues>(form: UseFormReturn<T>)`**\r\n    *   **Rôle** : Ce hook est responsable du rendu récursif des champs de formulaire et des fieldsets. Il retourne des fonctions (`FormFieldsMap`, `FieldsetMap`) qui itèrent sur la configuration `formfields` et affichent les composants de champ appropriés (comme `FormFieldElement`, `DivElementField`) ou les fieldsets. Il retourne également `InpuTComponentCallBack`, une fonction mémoïsée pour rendre le `InputComponent` utilisé pour chaque champ.\r\n    *   **Utilité principale** : Gère la logique de mapping de la configuration des champs vers les éléments JSX rendus. C'est le moteur de rendu dynamique des champs. Principalement pour usage interne.\r\n\r\nCes hooks encapsulent la complexité de l'intégration avec `react-hook-form` et la logique de rendu dynamique. Pour étendre `ReactFormMaker`, il est généralement préférable de créer des types de champs personnalisés ou d'utiliser les props de configuration existantes plutôt que d'interagir directement avec ces hooks, sauf si vous construisez une fonctionnalité de formulaire très spécifique.\r\n\r\n### Gestion des Événements sur les Champs\r\n\r\nVous pouvez attacher des gestionnaires d'événements directement à vos champs lors de leur configuration dans le tableau `formfields`. Les événements courants comme `onChange`, `onBlur`, et `onClick` sont supportés.\r\n\r\nCes fonctions de rappel reçoivent un objet `FormFieldEvent` qui contient deux propriétés :\r\n-   `event`: L'événement brut du navigateur (par exemple, `React.ChangeEvent<HTMLInputElement>`, `React.FocusEvent<HTMLInputElement>`).\r\n-   `form`: L'instance complète de `react-hook-form` (`UseFormReturn<T>`). Cela vous donne un accès direct à toutes les méthodes de `react-hook-form` (comme `setValue`, `getValue`, `trigger`, `formState`, etc.) à l'intérieur de votre gestionnaire d'événements.\r\n\r\nPour la signature exacte et plus de détails sur `FormFieldEvent`, référez-vous à la documentation de l'interface `FieldReactFormMaker` (section \"Events\").\r\n\r\n#### Exemple d'utilisation de `onChange`\r\n\r\n```typescript\r\nimport { FormFieldEvent } from './frontend/src/components/ReactFormMaker/interfaces/FormFieldEvent'; // Ajustez le chemin\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { z } from 'zod';\r\n\r\n// Supposons que TFormData est votre type de données de formulaire\r\ninterface TFormData extends FieldValues {\r\n  firstName: string;\r\n  lastName?: string;\r\n  hasNickname?: boolean;\r\n  nickname?: string;\r\n}\r\n\r\nconst handleFirstNameChange = (fieldEvent: FormFieldEvent<TFormData>) => {\r\n  const { event, form } = fieldEvent;\r\n  const newValue = (event.target as HTMLInputElement).value;\r\n\r\n  console.log(`Le prénom est maintenant : ${newValue}`);\r\n\r\n  // Exemple d'interaction avec react-hook-form :\r\n  // Mettre à jour dynamiquement un autre champ\r\n  form.setValue('lastName', newValue + ' Smith');\r\n\r\n  // Déclencher la validation pour un autre champ\r\n  if (newValue.length > 2) {\r\n    form.trigger('lastName');\r\n  }\r\n};\r\n\r\nconst handleNicknameVisibility = (fieldEvent: FormFieldEvent<TFormData>) => {\r\n  const { event, form } = fieldEvent;\r\n  const isChecked = (event.target as HTMLInputElement).checked;\r\n  // Vous pourriez utiliser form.setValue pour afficher/masquer ou activer/désactiver le champ nickname\r\n  // ou simplement gérer l'état localement si le champ nickname est conditionnellement rendu\r\n  console.log(`Afficher le surnom : ${isChecked}`);\r\n  if (!isChecked) {\r\n    form.setValue('nickname', ''); // Effacer le surnom si la case est décochée\r\n    form.unregister('nickname'); // Optionnel: dé-enregistrer le champ pour qu'il ne soit pas soumis\r\n  } else {\r\n    form.register('nickname'); // Enregistrer le champ s'il était dé-enregistré\r\n  }\r\n};\r\n\r\nexport const formFieldsWithEvents: Array<FieldReactFormMaker> = [\r\n  {\r\n    inputName: 'firstName',\r\n    inputType: 'text',\r\n    label: 'Prénom',\r\n    zodObject: z.string().min(1),\r\n    onChange: handleFirstNameChange,\r\n  },\r\n  {\r\n    inputName: 'hasNickname',\r\n    inputType: 'checkbox',\r\n    label: 'Avez-vous un surnom ?',\r\n    onChange: handleNicknameVisibility,\r\n    zodObject: z.boolean().optional(),\r\n  },\r\n  {\r\n    inputName: 'nickname',\r\n    inputType: 'text',\r\n    label: 'Surnom (si applicable)',\r\n    // Ce champ pourrait être masqué/affiché conditionnellement en fonction de 'hasNickname'\r\n    // en utilisant la propriété 'isHide' et en la mettant à jour via form.setValue dans handleNicknameVisibility,\r\n    // ou en gérant cela dans le rendu JSX de votre composant.\r\n    // Pour cet exemple, nous supposons qu'il est toujours visible mais sa valeur est gérée.\r\n    zodObject: z.string().optional(),\r\n  }\r\n  // ... autres champs\r\n];\r\n\r\n// Utilisez ensuite formFieldsWithEvents dans <ReactFormMaker formfields={formFieldsWithEvents} ... />\r\n```\r\n\r\nDans cet exemple, `handleFirstNameChange` est appelée chaque fois que la valeur du champ \"firstName\" change. Elle a accès à l'événement du navigateur et à l'instance complète du formulaire `react-hook-form`, permettant des logiques complexes et des interactions entre champs. De même, `handleNicknameVisibility` réagit aux changements de la case à cocher pour potentiellement manipuler la visibilité ou l'état du champ \"nickname\".\r\nL'utilisation de `form.setValue`, `form.trigger`, `form.register`, `form.unregister` etc., à l'intérieur de ces gestionnaires d'événements permet une grande flexibilité pour créer des formulaires dynamiques et interactifs.\r\n\r\n## Exemples Complets\r\n\r\nCette section fournit des exemples plus complets illustrant comment combiner les différentes configurations de champs et les props du composant `ReactFormMaker` pour construire des formulaires courants.\r\n\r\n### Exemple 1: Formulaire d'Inscription Complet\r\n\r\nCet exemple montre un formulaire d'inscription typique avec validation.\r\n\r\n**Configuration des champs (`formfields`) :**\r\n\r\n```typescript\r\nimport { z } from 'zod';\r\nimport { FieldReactFormMaker, ReactFormMakerFieldset } from './interfaces/FieldInterfaces'; // Ajustez le chemin\r\n\r\n// Schéma Zod global pour la validation croisée des mots de passe\r\nconst registrationSchema = z.object({\r\n  username: z.string().min(3, \"Le nom d'utilisateur doit faire au moins 3 caractères.\"),\r\n  email: z.string().email(\"Adresse email invalide.\"),\r\n  password: z.string().min(8, \"Le mot de passe doit faire au moins 8 caractères.\"),\r\n  confirmPassword: z.string(),\r\n  acceptTerms: z.boolean().refine(val => val === true, {\r\n    message: \"Vous devez accepter les conditions d'utilisation.\",\r\n  }),\r\n}).refine(data => data.password === data.confirmPassword, {\r\n  message: \"Les mots de passe ne correspondent pas.\",\r\n  path: [\"confirmPassword\"], // Erreur associée au champ confirmPassword\r\n});\r\n\r\n\r\n// Définition des champs pour ReactFormMaker\r\n// Note: La validation croisée des mots de passe est gérée par le schéma global `registrationSchema`\r\n// qui sera passé au resolver de react-hook-form.\r\n// Les `zodObject` individuels ici sont pour la validation par champ.\r\n\r\nexport const registrationFormFields: (FieldReactFormMaker | ReactFormMakerFieldset)[] = [\r\n  {\r\n    fieldset: 'accountInfo',\r\n    legend: 'Informations du Compte',\r\n    className: 'mb-6',\r\n    fields: [\r\n      {\r\n        inputName: 'username',\r\n        label: 'Nom d\\'utilisateur',\r\n        inputType: 'text',\r\n        placeholder: 'ex: supercoder',\r\n        zodObject: registrationSchema.shape.username, // Référence au schéma Zod\r\n        description: 'Sera affiché sur votre profil public.'\r\n      },\r\n      {\r\n        inputName: 'email',\r\n        label: 'Adresse Email',\r\n        inputType: 'text', // inputType 'email' pourrait aussi être utilisé si un composant spécifique est mappé\r\n        placeholder: 'vous@exemple.com',\r\n        zodObject: registrationSchema.shape.email,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    fieldset: 'security',\r\n    legend: 'Sécurité',\r\n    fields: [\r\n      {\r\n        inputName: 'password',\r\n        label: 'Mot de passe',\r\n        inputType: 'password',\r\n        placeholder: '********',\r\n        zodObject: registrationSchema.shape.password,\r\n      },\r\n      {\r\n        inputName: 'confirmPassword',\r\n        label: 'Confirmer le mot de passe',\r\n        inputType: 'password',\r\n        placeholder: '********',\r\n        // Le zodObject ici est simple, la vérification de correspondance est dans le schéma global.\r\n        zodObject: z.string().min(1, \"Veuillez confirmer le mot de passe.\"),\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    inputName: 'acceptTerms',\r\n    label: 'J\\'accepte les conditions d\\'utilisation et la politique de confidentialité.',\r\n    inputType: 'checkbox',\r\n    zodObject: registrationSchema.shape.acceptTerms,\r\n    className: 'mt-4 items-start' // Ajustement pour aligner le label avec la checkbox\r\n  }\r\n];\r\n```\r\n\r\n**Utilisation dans un composant React :**\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport ReactFormMaker from './ReactFormMaker'; // Ajustez le chemin d'importation\r\nimport { registrationFormFields } from './path-to/registrationFormFields'; // Ajustez le chemin\r\nimport { FieldValues } from 'react-hook-form';\r\n// import { z } from 'zod'; // Zod est déjà utilisé dans registrationFormFields.ts\r\n\r\n// Définissez le type de données attendu par votre formulaire, si vous utilisez TypeScript\r\ninterface RegistrationFormData extends FieldValues {\r\n  username: string;\r\n  email: string;\r\n  password?: string; // Le mot de passe peut être optionnel après soumission pour ne pas le renvoyer\r\n  confirmPassword?: string;\r\n  acceptTerms: boolean;\r\n}\r\n\r\nconst RegistrationForm = () => {\r\n  const handleSubmit = (data: RegistrationFormData | false, errors: FieldValues | false) => {\r\n    if (data) {\r\n      console.log('Formulaire d\\'inscription soumis avec succès:', data);\r\n      // Envoyer les données au backend, sans les mots de passe si possible\r\n      const { password, confirmPassword, ...submissionData } = data;\r\n      console.log('Données à envoyer:', submissionData);\r\n    } else {\r\n      console.error('Erreurs de validation:', errors);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"max-w-lg mx-auto p-4 shadow-md rounded-lg\">\r\n      <h2 className=\"text-2xl font-bold mb-6 text-center\">Créer un compte</h2>\r\n      <ReactFormMaker<RegistrationFormData>\r\n        formfields={registrationFormFields}\r\n        onSubmit={handleSubmit}\r\n        btnTextSubmit=\"S'inscrire\"\r\n        // Vous pourriez passer le schéma Zod global ici si ReactFormMaker le permettait\r\n        // directement, ou vous assurer que useReactFormMaker.hook.ts le construit\r\n        // correctement en interne, y compris le .refine pour la validation croisée.\r\n        // Pour l'instant, on suppose que le hook interne gère la création du schéma\r\n        // à partir des zodObjects des champs et applique le .refine() si nécessaire.\r\n        // La validation croisée des mots de passe est gérée par le schéma Zod\r\n        // lors de l'initialisation de react-hook-form dans `useReactFormMaker.hook.ts`.\r\n        // Le hook doit être capable de détecter la présence des champs `password` et `confirmPassword`\r\n        // et d'ajouter la validation `.refine` au schéma global.\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RegistrationForm;\r\n```\r\n\r\n**Explication :**\r\n-   Le fichier `registrationFormFields.ts` (nommé hypothétiquement) définit la structure du formulaire.\r\n-   Nous utilisons `ReactFormMakerFieldset` pour grouper les champs \"Informations du Compte\" et \"Sécurité\".\r\n-   Chaque champ a son propre `zodObject` pour la validation individuelle.\r\n-   **Important pour la confirmation du mot de passe** : La validation directe que `password` et `confirmPassword` correspondent est généralement effectuée au niveau du schéma Zod global utilisé par `react-hook-form`. Le hook `useReactFormMaker` devrait être conçu pour construire ce schéma global en combinant les `zodObject` individuels et en y ajoutant des raffinements (`.refine()`) pour les validations croisées. Dans l'exemple de `registrationFormFields`, nous avons défini un `registrationSchema` complet, et les `zodObject` des champs font référence aux shapes de ce schéma. Le hook `useReactFormMaker` est supposé utiliser ce schéma Zod complet (avec le `.refine`) lors de l'initialisation de `useForm` avec `zodResolver`.\r\n-   Le composant `RegistrationForm` instancie `ReactFormMaker` avec cette configuration et une fonction `handleSubmit`.\r\n\r\n### Exemple 2: Formulaire à Étapes (Stepper) Détaillé\r\n\r\nCet exemple étend le concept de formulaire à étapes, montrant une structure plus complexe avec des validations par étape.\r\n\r\n**Configuration des champs (`formfields`) pour le stepper :**\r\n\r\n```typescript\r\nimport { z } from 'zod';\r\nimport { ReactFormMakerStep, FieldReactFormMaker } from './interfaces/FieldInterfaces'; // Ajustez le chemin\r\n\r\nexport const detailedStepperFormFields: ReactFormMakerStep[] = [\r\n  {\r\n    stepName: 'personalInfo',\r\n    isStep: true,\r\n    legend: 'Étape 1: Vos Informations Personnelles',\r\n    fields: [\r\n      {\r\n        inputName: 'firstName',\r\n        label: 'Prénom',\r\n        inputType: 'text',\r\n        zodObject: z.string().min(2, 'Le prénom est requis (minimum 2 caractères).'),\r\n        placeholder: 'Jean',\r\n      },\r\n      {\r\n        inputName: 'lastName',\r\n        label: 'Nom de famille',\r\n        inputType: 'text',\r\n        zodObject: z.string().min(2, 'Le nom est requis (minimum 2 caractères).'),\r\n        placeholder: 'Dupont',\r\n      },\r\n    ],\r\n    isStrict: true, // L'utilisateur doit valider cette étape pour continuer\r\n  },\r\n  {\r\n    stepName: 'contactInfo',\r\n    isStep: true,\r\n    legend: 'Étape 2: Comment vous Contacter',\r\n    fields: [\r\n      {\r\n        inputName: 'email',\r\n        label: 'Adresse Email',\r\n        inputType: 'text', // ou 'email'\r\n        zodObject: z.string().email('Adresse email invalide.'),\r\n        placeholder: 'jean.dupont@email.com',\r\n      },\r\n      {\r\n        inputName: 'phoneNumber',\r\n        label: 'Numéro de téléphone (optionnel)',\r\n        inputType: 'phoneNumber', // Type spécifique pour potentiellement un composant customisé\r\n        zodObject: z.string().optional().refine(val => !val || /^[0-9+\\s()-]*$/.test(val), {\r\n            message: \"Numéro de téléphone invalide.\",\r\n        }),\r\n        placeholder: '06 12 34 56 78',\r\n      },\r\n    ],\r\n    isStrict: true,\r\n  },\r\n  {\r\n    stepName: 'preferences',\r\n    isStep: true,\r\n    legend: 'Étape 3: Vos Préférences',\r\n    fields: [\r\n      {\r\n        inputName: 'newsletter',\r\n        label: 'Souhaitez-vous vous abonner à notre newsletter ?',\r\n        inputType: 'radio',\r\n        options: [\r\n          { value: 'yes', label: 'Oui, avec plaisir !' },\r\n          { value: 'no', label: 'Non merci.' },\r\n        ],\r\n        zodObject: z.enum(['yes', 'no'], { required_error: \"Veuillez faire un choix.\" }),\r\n        defaultValues: 'no',\r\n      },\r\n      {\r\n        inputName: 'preferredContact',\r\n        label: 'Comment préférez-vous être contacté(e) ?',\r\n        inputType: 'select',\r\n        options: [\r\n          { value: '', label: 'Sélectionnez une option...' },\r\n          { value: 'email', label: 'Par Email' },\r\n          { value: 'phone', label: 'Par Téléphone (si fourni)' },\r\n        ],\r\n        zodObject: z.string().nonempty(\"Veuillez sélectionner une méthode de contact.\"),\r\n        isHide: (form) => { // Exemple de champ conditionnel basé sur les valeurs du formulaire\r\n          return !form?.watch('email') && !form?.watch('phoneNumber');\r\n        }\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    stepName: 'summary',\r\n    isStep: true,\r\n    legend: 'Étape 4: Résumé et Soumission',\r\n    // Ce champ pourrait utiliser un composant personnalisé pour afficher un résumé\r\n    // ou simplement un champ de type 'custom' avec du contenu informatif.\r\n    // Pour la simplicité, nous ajoutons une simple checkbox de confirmation.\r\n    fields: [\r\n        {\r\n            inputName: 'finalConfirmation',\r\n            label: 'Je confirme que toutes les informations sont correctes et je souhaite soumettre ma demande.',\r\n            inputType: 'checkbox',\r\n            zodObject: z.boolean().refine(val => val === true, {\r\n                message: \"Veuillez confirmer pour soumettre.\"\r\n            })\r\n        }\r\n    ],\r\n    // onBeforeNextStep: async (data) => { console.log(\"Dernière vérification avant soumission\", data); return true; }\r\n  }\r\n];\r\n```\r\n\r\n**Utilisation dans un composant React :**\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport ReactFormMaker from './ReactFormMaker'; // Ajustez le chemin\r\nimport { detailedStepperFormFields } from './path-to/detailedStepperFormFields'; // Ajustez le chemin\r\nimport { FieldValues } from 'react-hook-form';\r\n\r\ninterface DetailedStepperFormData extends FieldValues {\r\n  // Définissez les types pour chaque champ si vous le souhaitez\r\n  firstName: string;\r\n  lastName: string;\r\n  email: string;\r\n  phoneNumber?: string;\r\n  newsletter: 'yes' | 'no';\r\n  preferredContact: 'email' | 'phone' | '';\r\n  finalConfirmation: boolean;\r\n}\r\n\r\nconst DetailedStepperForm = () => {\r\n  const handleSubmit = (data: DetailedStepperFormData | false, errors: FieldValues | false) => {\r\n    if (data) {\r\n      console.log('Formulaire à étapes soumis avec succès:', data);\r\n      // Traitement des données finales\r\n    } else {\r\n      console.error('Erreurs de validation dans le stepper:', errors);\r\n      // Peut-être naviguer vers la première étape avec une erreur si nécessaire\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"w-full mx-auto py-8 px-4\">\r\n      <h2 className=\"text-3xl font-bold mb-8 text-center\">Formulaire Multi-Étapes</h2>\r\n      <ReactFormMaker<DetailedStepperFormData>\r\n        formfields={detailedStepperFormFields}\r\n        onSubmit={handleSubmit}\r\n        stepper={true}\r\n        orientation=\"horizontal\" // ou \"vertical\"\r\n        btnTextSubmit=\"Soumettre la Demande\" // Texte du bouton sur la dernière étape\r\n        className=\"bg-white p-6 rounded-xl shadow-xl\" // Style pour le conteneur du stepper\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DetailedStepperForm;\r\n```\r\n\r\n**Points Clés de la Configuration du Stepper :**\r\n-   Chaque objet dans le tableau `detailedStepperFormFields` est une configuration d'étape (`ReactFormMakerStep`).\r\n-   `stepName` : Un identifiant unique pour l'étape.\r\n-   `isStep: true` : Indique que cet objet définit une étape.\r\n-   `legend` : Le titre de l'étape.\r\n-   `fields` : Un tableau de configurations de champs (`FieldReactFormMaker`) pour cette étape spécifique.\r\n-   `isStrict: true` : (Optionnel) Si défini à `true` sur une étape, l'utilisateur ne pourra pas passer à l'étape suivante tant que tous les champs de l'étape actuelle ne sont pas valides selon leurs `zodObject`.\r\n-   La prop `stepper={true}` sur `<ReactFormMaker>` active le mode stepper.\r\n-   `orientation` peut être `\"horizontal\"` ou `\"vertical\"`.\r\n-   Le `btnTextSubmit` sera affiché sur le bouton de la dernière étape. Les étapes intermédiaires auront des boutons \"Suivant\" et \"Précédent\" (textes personnalisables via les props de `ReactFormMakerStep` comme `buttonNextContent`).\r\n-   La propriété `isHide` sur un champ peut être une fonction qui reçoit l'instance du formulaire `react-hook-form`, permettant de masquer/afficher des champs dynamiquement en fonction d'autres valeurs du formulaire (par exemple, `form.watch('fieldName')`).\r\n\r\nCes exemples illustrent la flexibilité de `ReactFormMaker` pour créer à la fois des formulaires simples et des formulaires multi-étapes plus complexes, en s'appuyant sur une configuration déclarative.\r\n",
  "/ReactFormMaker/enhancements/CheckboxWithText.tsx": "import React from 'react';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { cn } from '../../../lib/utils';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction CheckboxWithText(params: FieldParams) {\r\n  const { zFields, fieldProps, indexField } = params;\r\n  const classNameLabel =\r\n    'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70';\r\n  const classNameContainer = 'flex space-x-2 items-top';\r\n\r\n  return (\r\n    <div className={classNameContainer}>\r\n      <Checkbox\r\n        key={indexField}\r\n        className={cn(fieldProps.className)}\r\n        defaultChecked={zFields.value}\r\n        id={fieldProps.inputName}\r\n        {...zFields}\r\n        onCheckedChange={(checked: boolean) => {\r\n          zFields.onChange(checked);\r\n        }}\r\n      />\r\n      <div className=\"grid gap-1.5 leading-none\">\r\n        <label htmlFor={fieldProps.inputName} className={classNameLabel}>\r\n          {fieldProps.label}\r\n        </label>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CheckboxWithText;\r\n",
  "/ReactFormMaker/enhancements/DatePickerSimple.tsx": "import React from 'react';\r\nimport {\r\n  Popover,\r\n  PopoverTrigger,\r\n  PopoverContent,\r\n} from '@/components/ui/popover';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport { CalendarIcon } from '@radix-ui/react-icons';\r\nimport { format } from 'date-fns';\r\nimport { cn } from '../../../lib/utils';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nconst DatePickerSimple = React.forwardRef<HTMLButtonElement, FieldParams>(\r\n  ({ zFields, fieldProps }, ref) => {\r\n    const [date, setDate] = React.useState<Date | undefined>();\r\n\r\n    return (\r\n      <Popover>\r\n        <PopoverTrigger asChild className={cn(fieldProps.className)}>\r\n          <Button\r\n            ref={ref}\r\n            variant=\"outline\"\r\n            className={cn(\r\n              'w-[240px] justify-start text-left font-normal',\r\n              !date && 'text-muted-foreground',\r\n            )}\r\n          >\r\n            <CalendarIcon className=\"w-4 h-4 mr-2\" />\r\n            {date ? format(date, 'PPP') : <span>{fieldProps.placeholder}</span>}\r\n          </Button>\r\n        </PopoverTrigger>\r\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\r\n          <div>\r\n            <Calendar\r\n              mode=\"single\"\r\n              selected={date}\r\n              onSelect={(selectDate) => {\r\n                setDate(selectDate);\r\n                zFields.onChange(selectDate);\r\n              }}\r\n            />\r\n          </div>\r\n        </PopoverContent>\r\n      </Popover>\r\n    );\r\n  },\r\n);\r\nDatePickerSimple.displayName = 'DatePickerSimple';\r\n\r\nexport default DatePickerSimple;\r\n",
  "/ReactFormMaker/enhancements/DateRangePicker.tsx": "'use client';\r\n\r\nimport * as React from 'react';\r\nimport { CalendarIcon } from '@radix-ui/react-icons';\r\nimport { addDays, format, getYear, set, formatDistance } from 'date-fns';\r\nimport { DateRange, DayPickerProps, DropdownProps } from 'react-day-picker';\r\n\r\nimport { cn } from '@/lib/utils';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover';\r\nimport { ChevronLeft, ChevronRight } from 'lucide-react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport YearsDropdownCustom from './YearsDropdown';\r\n\r\nexport function DateRangePicker({ zFields, fieldProps }: FieldParams) {\r\n  const [date, setDate] = React.useState<DateRange>({\r\n    from: fieldProps?.defaultValues?.from || addDays(new Date(), 1),\r\n    to: fieldProps?.defaultValues?.to || addDays(new Date(), 2),\r\n  });\r\n  const [selectedYearFrom, setSelectedYearFrom] = React.useState<number>(\r\n    getYear(new Date()),\r\n  );\r\n  const [selectedYearTo, setSelectedYearTo] = React.useState<number>(\r\n    getYear(new Date()),\r\n  );\r\n  const dateEndMouth = set(new Date(), { month: 11, date: 31 });\r\n  dateEndMouth.setFullYear(dateEndMouth.getFullYear() + 100);\r\n\r\n  const modifiers: DayPickerProps['modifiers'] = {\r\n    selected: date,\r\n    range_start: date.from,\r\n    range_end: date.to,\r\n    range_middle: (day: Date) =>\r\n      date && date.from && date.to ? day > date.from && day < date.to : false,\r\n  };\r\n\r\n  React.useEffect(() => {\r\n    zFields.onChange(date);\r\n  }, [date]);\r\n\r\n  function onDayClickHandler(day: Date, range: 'from' | 'to') {\r\n    if (range === 'from') {\r\n      if (date?.from && day.toString() == date?.from.toString()) {\r\n        setDate({ ...date, from: undefined });\r\n      } else {\r\n        setDate({ ...date, from: day });\r\n      }\r\n    } else if (date?.to && day.toString() == date?.to.toString()) {\r\n      setDate({ ...date, to: undefined });\r\n    } else {\r\n      setDate({ ...date, to: day });\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className={cn('grid gap-2', fieldProps.className)}>\r\n      <Popover>\r\n        <PopoverTrigger asChild>\r\n          <Button\r\n            id=\"date\"\r\n            variant=\"outline\"\r\n            className={cn(\r\n              'w-[300px] justify-start text-left font-normal',\r\n              !date && 'text-muted-foreground',\r\n            )}\r\n          >\r\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\r\n            {date?.from ? (\r\n              date.to ? (\r\n                <>\r\n                  {format(date.from, 'LLL dd, y')} -{' '}\r\n                  {format(date.to, 'LLL dd, y')}\r\n                </>\r\n              ) : (\r\n                format(date.from, 'LLL dd, y')\r\n              )\r\n            ) : (\r\n              <span>Pick a date</span>\r\n            )}\r\n          </Button>\r\n        </PopoverTrigger>\r\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\r\n          <div className=\"space-y-2 p-2 flex flex-row justify-between\">\r\n            <div className=\"mt-2\">\r\n              <h5 className=\"w-full text-center scroll-m-20 leading-7 text-xl font-semibold tracking-tight  m-2\">\r\n                Selected start date\r\n              </h5>\r\n              <Calendar\r\n                pagedNavigation\r\n                captionLayout=\"dropdown-years\"\r\n                endMonth={dateEndMouth}\r\n                modifiers={modifiers}\r\n                onDayClick={(day) => onDayClickHandler(day, 'from')}\r\n                numberOfMonths={1}\r\n                components={{\r\n                  Chevron: ({ ...props }) =>\r\n                    props.orientation === 'left' ? (\r\n                      <ChevronLeft {...props} className=\"h-4 w-4\" />\r\n                    ) : (\r\n                      <ChevronRight {...props} className=\"h-4 w-4\" />\r\n                    ),\r\n                  YearsDropdown: (props: DropdownProps) => {\r\n                    return (\r\n                      <YearsDropdownCustom\r\n                        {...props}\r\n                        range=\"from\"\r\n                        selectedYear={selectedYearFrom}\r\n                        setSelectedYear={setSelectedYearFrom}\r\n                      />\r\n                    );\r\n                  },\r\n                }}\r\n              />\r\n            </div>\r\n            <div>\r\n              <h5 className=\"w-full text-center scroll-m-20 text-xl font-semibold tracking-tight m-2\">\r\n                Selected end date\r\n              </h5>\r\n              <Calendar\r\n                pagedNavigation\r\n                captionLayout=\"dropdown-years\"\r\n                endMonth={dateEndMouth}\r\n                onDayClick={(day) => onDayClickHandler(day, 'to')}\r\n                modifiers={modifiers}\r\n                numberOfMonths={1}\r\n                components={{\r\n                  Chevron: ({ ...props }) =>\r\n                    props.orientation === 'left' ? (\r\n                      <ChevronLeft {...props} className=\"h-4 w-4\" />\r\n                    ) : (\r\n                      <ChevronRight {...props} className=\"h-4 w-4\" />\r\n                    ),\r\n                  YearsDropdown: (props: DropdownProps) => {\r\n                    return (\r\n                      <YearsDropdownCustom\r\n                        {...props}\r\n                        range=\"to\"\r\n                        selectedYear={selectedYearTo}\r\n                        setSelectedYear={setSelectedYearTo}\r\n                      />\r\n                    );\r\n                  },\r\n                }}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"flex justify-center w-full mb-4\">\r\n            <span className=\"text-sm text-muted-foreground\">\r\n              {date && date.from && date.to\r\n                ? `The selected time slot is ${formatDistance(\r\n                    date.from,\r\n                    date.to,\r\n                  )}`\r\n                : 'Choose a date range'}\r\n            </span>\r\n          </div>\r\n        </PopoverContent>\r\n      </Popover>\r\n    </div>\r\n  );\r\n}\r\n",
  "/ReactFormMaker/enhancements/FileUploader/FileUploader.tsx": "'use client';\r\n\r\nimport { Input } from '@/components/ui/input';\r\nimport { cn } from '@/lib/utils';\r\nimport {\r\n  Dispatch,\r\n  SetStateAction,\r\n  createContext,\r\n  forwardRef,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\nimport {\r\n  useDropzone,\r\n  DropzoneState,\r\n  FileRejection,\r\n  DropzoneOptions,\r\n} from 'react-dropzone';\r\nimport { toast } from 'sonner';\r\nimport { Trash2 as RemoveIcon } from 'lucide-react';\r\nimport { buttonVariants } from '@/components/ui/button';\r\n\r\ntype DirectionOptions = 'rtl' | 'ltr' | undefined;\r\n\r\ntype FileUploaderContextType = {\r\n  dropzoneState: DropzoneState;\r\n  isLOF: boolean;\r\n  isFileTooBig: boolean;\r\n  removeFileFromSet: (index: number) => void;\r\n  activeIndex: number;\r\n  setActiveIndex: Dispatch<SetStateAction<number>>;\r\n  orientation: 'horizontal' | 'vertical';\r\n  direction: DirectionOptions;\r\n};\r\n\r\nconst FileUploaderContext = createContext<FileUploaderContextType | null>(null);\r\n\r\nexport const useFileUpload = () => {\r\n  const context = useContext(FileUploaderContext);\r\n  if (!context) {\r\n    throw new Error('useFileUpload must be used within a FileUploaderProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport type FileUploaderProps = {\r\n  value: File[] | null;\r\n  reSelect?: boolean;\r\n  onValueChange: (value: File[] | null) => void;\r\n  dropzoneOptions: DropzoneOptions;\r\n  orientation?: 'horizontal' | 'vertical';\r\n};\r\n\r\n/**\r\n * File upload Docs: {@link: https://localhost:3000/docs/file-upload}\r\n */\r\n\r\nexport const FileUploader = forwardRef<\r\n  HTMLDivElement,\r\n  FileUploaderProps & React.HTMLAttributes<HTMLDivElement>\r\n>(\r\n  (\r\n    {\r\n      className,\r\n      dropzoneOptions,\r\n      value,\r\n      onValueChange,\r\n      reSelect,\r\n      orientation = 'vertical',\r\n      children,\r\n      dir,\r\n      ...props\r\n    },\r\n    ref,\r\n  ) => {\r\n    const [isFileTooBig, setIsFileTooBig] = useState(false);\r\n    const [isLOF, setIsLOF] = useState(false);\r\n    const [activeIndex, setActiveIndex] = useState(-1);\r\n    const {\r\n      accept = {\r\n        'image/*': ['.jpg', '.jpeg', '.png', '.gif'],\r\n      },\r\n      maxFiles = 1,\r\n      maxSize = 4 * 1024 * 1024,\r\n      multiple = true,\r\n    } = dropzoneOptions;\r\n\r\n    const reSelectAll = maxFiles === 1 ? true : reSelect;\r\n    const direction: DirectionOptions = dir === 'rtl' ? 'rtl' : 'ltr';\r\n\r\n    const removeFileFromSet = useCallback(\r\n      (i: number) => {\r\n        if (!value) return;\r\n        const newFiles = value.filter((_, index) => index !== i);\r\n        onValueChange(newFiles);\r\n      },\r\n      [value, onValueChange],\r\n    );\r\n\r\n    const handleKeyDown = useCallback(\r\n      (e: React.KeyboardEvent<HTMLDivElement>) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        if (!value) return;\r\n\r\n        const moveNext = () => {\r\n          const nextIndex = activeIndex + 1;\r\n          setActiveIndex(nextIndex > value.length - 1 ? 0 : nextIndex);\r\n        };\r\n\r\n        const movePrev = () => {\r\n          const nextIndex = activeIndex - 1;\r\n          setActiveIndex(nextIndex < 0 ? value.length - 1 : nextIndex);\r\n        };\r\n\r\n        const prevKey =\r\n          orientation === 'horizontal'\r\n            ? direction === 'ltr'\r\n              ? 'ArrowLeft'\r\n              : 'ArrowRight'\r\n            : 'ArrowUp';\r\n\r\n        const nextKey =\r\n          orientation === 'horizontal'\r\n            ? direction === 'ltr'\r\n              ? 'ArrowRight'\r\n              : 'ArrowLeft'\r\n            : 'ArrowDown';\r\n\r\n        if (e.key === nextKey) {\r\n          moveNext();\r\n        } else if (e.key === prevKey) {\r\n          movePrev();\r\n        } else if (e.key === 'Enter' || e.key === 'Space') {\r\n          if (activeIndex === -1) {\r\n            dropzoneState.inputRef.current?.click();\r\n          }\r\n        } else if (e.key === 'Delete' || e.key === 'Backspace') {\r\n          if (activeIndex !== -1) {\r\n            removeFileFromSet(activeIndex);\r\n            if (value.length - 1 === 0) {\r\n              setActiveIndex(-1);\r\n              return;\r\n            }\r\n            movePrev();\r\n          }\r\n        } else if (e.key === 'Escape') {\r\n          setActiveIndex(-1);\r\n        }\r\n      },\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      [value, activeIndex, removeFileFromSet],\r\n    );\r\n\r\n    const onDrop = useCallback(\r\n      (acceptedFiles: File[], rejectedFiles: FileRejection[]) => {\r\n        const files = acceptedFiles;\r\n\r\n        if (!files) {\r\n          toast.error('file error , probably too big');\r\n          return;\r\n        }\r\n\r\n        const newValues: File[] = value ? [...value] : [];\r\n\r\n        if (reSelectAll) {\r\n          newValues.splice(0, newValues.length);\r\n        }\r\n\r\n        files.forEach((file) => {\r\n          if (newValues.length < maxFiles) {\r\n            newValues.push(file);\r\n          }\r\n        });\r\n\r\n        onValueChange(newValues);\r\n\r\n        if (rejectedFiles.length > 0) {\r\n          for (let i = 0; i < rejectedFiles.length; i++) {\r\n            if (rejectedFiles[i].errors[0]?.code === 'file-too-large') {\r\n              toast.error(\r\n                `File is too large. Max size is ${maxSize / 1024 / 1024}MB`,\r\n              );\r\n              break;\r\n            }\r\n            if (rejectedFiles[i].errors[0]?.message) {\r\n              toast.error(rejectedFiles[i].errors[0].message);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      [reSelectAll, value],\r\n    );\r\n\r\n    useEffect(() => {\r\n      if (!value) return;\r\n      if (value.length === maxFiles) {\r\n        setIsLOF(true);\r\n        return;\r\n      }\r\n      setIsLOF(false);\r\n    }, [value, maxFiles]);\r\n\r\n    const opts = dropzoneOptions\r\n      ? dropzoneOptions\r\n      : { accept, maxFiles, maxSize, multiple };\r\n\r\n    const dropzoneState = useDropzone({\r\n      ...opts,\r\n      onDrop,\r\n      onDropRejected: () => setIsFileTooBig(true),\r\n      onDropAccepted: () => setIsFileTooBig(false),\r\n    });\r\n\r\n    return (\r\n      <FileUploaderContext.Provider\r\n        value={{\r\n          dropzoneState,\r\n          isLOF,\r\n          isFileTooBig,\r\n          removeFileFromSet,\r\n          activeIndex,\r\n          setActiveIndex,\r\n          orientation,\r\n          direction,\r\n        }}\r\n      >\r\n        <div\r\n          ref={ref}\r\n          tabIndex={0}\r\n          onKeyDownCapture={handleKeyDown}\r\n          className={cn(\r\n            'grid w-full focus:outline-none overflow-hidden ',\r\n            className,\r\n            {\r\n              'gap-2': value && value.length > 0,\r\n            },\r\n          )}\r\n          dir={dir}\r\n          {...props}\r\n        >\r\n          {children}\r\n        </div>\r\n      </FileUploaderContext.Provider>\r\n    );\r\n  },\r\n);\r\n\r\nFileUploader.displayName = 'FileUploader';\r\n\r\nexport const FileUploaderContent = forwardRef<\r\n  HTMLDivElement,\r\n  React.HTMLAttributes<HTMLDivElement>\r\n>(({ children, className, ...props }, ref) => {\r\n  const { orientation } = useFileUpload();\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  return (\r\n    <div\r\n      className={cn('w-full px-1')}\r\n      ref={containerRef}\r\n      aria-description=\"content file holder\"\r\n    >\r\n      <div\r\n        {...props}\r\n        ref={ref}\r\n        className={cn(\r\n          'flex rounded-xl gap-1',\r\n          orientation === 'horizontal' ? 'flex-raw flex-wrap' : 'flex-col',\r\n          className,\r\n        )}\r\n      >\r\n        {children}\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nFileUploaderContent.displayName = 'FileUploaderContent';\r\n\r\nexport const FileUploaderItem = forwardRef<\r\n  HTMLDivElement,\r\n  { index: number } & React.HTMLAttributes<HTMLDivElement>\r\n>(({ className, index, children, ...props }, ref) => {\r\n  const { removeFileFromSet, activeIndex, direction } = useFileUpload();\r\n  const isSelected = index === activeIndex;\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={cn(\r\n        buttonVariants({ variant: 'ghost' }),\r\n        'h-6 p-1 justify-between cursor-pointer relative',\r\n        className,\r\n        isSelected ? 'bg-muted' : '',\r\n      )}\r\n      {...props}\r\n    >\r\n      <div className=\"font-medium leading-none tracking-tight flex items-center gap-1.5 h-full w-full\">\r\n        {children}\r\n      </div>\r\n      <button\r\n        type=\"button\"\r\n        className={cn(\r\n          'absolute',\r\n          direction === 'rtl' ? 'top-1 left-1' : 'top-1 right-1',\r\n        )}\r\n        onClick={() => removeFileFromSet(index)}\r\n      >\r\n        <span className=\"sr-only\">remove item {index}</span>\r\n        <RemoveIcon className=\"w-4 h-4 hover:stroke-destructive duration-200 ease-in-out\" />\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nFileUploaderItem.displayName = 'FileUploaderItem';\r\n\r\nexport const FileInput = forwardRef<\r\n  HTMLDivElement,\r\n  React.HTMLAttributes<HTMLDivElement>\r\n>(({ className, children, ...props }, ref) => {\r\n  const { dropzoneState, isFileTooBig, isLOF } = useFileUpload();\r\n  const rootProps = isLOF ? {} : dropzoneState.getRootProps();\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      {...props}\r\n      className={`relative w-full ${\r\n        isLOF ? 'opacity-50 cursor-not-allowed ' : 'cursor-pointer '\r\n      }`}\r\n    >\r\n      <div\r\n        className={cn(\r\n          `w-full rounded-lg duration-300 ease-in-out\r\n         ${\r\n           dropzoneState.isDragAccept\r\n             ? 'border-green-500'\r\n             : dropzoneState.isDragReject || isFileTooBig\r\n               ? 'border-red-500'\r\n               : 'border-gray-300'\r\n         }`,\r\n          className,\r\n        )}\r\n        {...rootProps}\r\n      >\r\n        {children}\r\n      </div>\r\n      <Input\r\n        ref={dropzoneState.inputRef}\r\n        disabled={isLOF}\r\n        {...dropzoneState.getInputProps()}\r\n        className={`${isLOF ? 'cursor-not-allowed' : ''}`}\r\n      />\r\n    </div>\r\n  );\r\n});\r\n\r\nFileInput.displayName = 'FileInput';\r\n",
  "/ReactFormMaker/enhancements/FileUploader/variants/DefaultFileUploader.tsx": "'use client';\r\n\r\nimport { useState } from 'react';\r\nimport {\r\n  FileUploader,\r\n  FileUploaderContent,\r\n  FileUploaderItem,\r\n  FileInput,\r\n  FileUploaderProps,\r\n} from '@/components/ReactFormMaker/enhancements/FileUploader/FileUploader';\r\nimport { Paperclip } from 'lucide-react';\r\nimport { DropzoneOptions } from 'react-dropzone';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface FileSvgDrawProps {\r\n  placeholder?: string | undefined;\r\n}\r\n\r\nconst FileSvgDraw = ({ placeholder }: FileSvgDrawProps) => {\r\n  return (\r\n    <>\r\n      <svg\r\n        className=\"w-8 h-8 mb-3 text-gray-500 dark:text-gray-400\"\r\n        aria-hidden=\"true\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        fill=\"none\"\r\n        viewBox=\"0 0 20 16\"\r\n      >\r\n        <path\r\n          stroke=\"currentColor\"\r\n          strokeLinecap=\"round\"\r\n          strokeLinejoin=\"round\"\r\n          strokeWidth=\"2\"\r\n          d=\"M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2\"\r\n        />\r\n      </svg>\r\n      <p className=\"mb-1 text-sm text-gray-500 dark:text-gray-400\">\r\n        <span className=\"font-semibold\">Click to upload</span>\r\n        &nbsp; or drag and drop\r\n      </p>\r\n      <p className=\"text-xs text-gray-500 dark:text-gray-400\">\r\n        {placeholder || 'Max file size: 4MB'}\r\n      </p>\r\n    </>\r\n  );\r\n};\r\n\r\nexport interface DefaultFileUploaderProps\r\n  extends Omit<FileUploaderProps, 'dropzoneOptions'>,\r\n    React.HTMLAttributes<HTMLDivElement> {\r\n  placeholder?: string;\r\n  value: File[] | null;\r\n  onValueChange: (value: File[] | null) => void;\r\n  dropzoneOptions?: DropzoneOptions;\r\n  className?: string;\r\n}\r\n\r\nconst DefaultFileUploader = ({\r\n  placeholder,\r\n  ...props\r\n}: DefaultFileUploaderProps) => {\r\n  const [files, setFiles] = useState<File[] | null>(props.value || null);\r\n\r\n  const dropZoneConfig = {\r\n    maxFiles: 5,\r\n    maxSize: 1024 * 1024 * 4,\r\n    multiple: true,\r\n  };\r\n\r\n  const handleOnchange = (files: File[] | null) => {\r\n    setFiles(files);\r\n    if (props.onValueChange) props.onValueChange(files);\r\n  };\r\n\r\n  return (\r\n    <FileUploader\r\n      value={files}\r\n      onValueChange={handleOnchange}\r\n      dropzoneOptions={props.dropzoneOptions || dropZoneConfig}\r\n      className={cn(\r\n        'relative bg-background rounded-lg p-2 border border-input shadow-sm',\r\n        props.className,\r\n      )}\r\n    >\r\n      <FileInput className=\"outline-dashed outline-1 outline-white\">\r\n        <div className=\"flex items-center justify-center flex-col pt-3 pb-4 w-full \">\r\n          <FileSvgDraw placeholder={placeholder} />\r\n        </div>\r\n      </FileInput>\r\n      <FileUploaderContent>\r\n        {files &&\r\n          files.length > 0 &&\r\n          files.map((file, i) => (\r\n            <FileUploaderItem key={i} index={i}>\r\n              <Paperclip className=\"h-4 w-4 stroke-current\" />\r\n              <span>{file.name}</span>\r\n            </FileUploaderItem>\r\n          ))}\r\n      </FileUploaderContent>\r\n    </FileUploader>\r\n  );\r\n};\r\n\r\nexport default DefaultFileUploader;\r\n",
  "/ReactFormMaker/enhancements/InputPasswordVisibility.tsx": "import React from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Button } from '@/components/ui/button';\r\nimport { EyeClosedIcon, EyeOpenIcon } from '@radix-ui/react-icons';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nconst InputPasswordVisibility = React.forwardRef<\r\n  HTMLInputElement,\r\n  FieldParams<any>\r\n>(({ zFields, fieldProps, indexField, id }, _ref) => {\r\n  const [showPassword, setShowPassword] = React.useState(false);\r\n\r\n  const inputValue: string =\r\n    zFields.value !== undefined ? String(zFields.value) : '';\r\n\r\n  return (\r\n    <div className={cn('flex flex-row items-center', fieldProps.className)}>\r\n      <Input\r\n        id={id ?? fieldProps.inputName}\r\n        className=\"rounded-[var(--radius)_0px_0px_var(--radius)] w-[calc(100%_-_49px)] border-r-[none]\"\r\n        key={indexField}\r\n        type={showPassword ? 'text' : 'password'}\r\n        placeholder={fieldProps.placeholder}\r\n        {...zFields}\r\n        value={inputValue}\r\n      />\r\n      <Button\r\n        className=\"rounded-[0px_var(--radius)_var(--radius)_0px]\"\r\n        variant=\"outline\"\r\n        type=\"button\"\r\n        onClick={() => setShowPassword((prev) => !prev)}\r\n      >\r\n        {showPassword ? <EyeOpenIcon /> : <EyeClosedIcon />}\r\n      </Button>\r\n    </div>\r\n  );\r\n});\r\nInputPasswordVisibility.displayName = 'InputPasswordVisibility';\r\n\r\nexport default InputPasswordVisibility;\r\n",
  "/ReactFormMaker/enhancements/MultiSelect/BadgeItem.tsx": "import React, { forwardRef } from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { Cross1Icon } from '@radix-ui/react-icons';\r\nimport { Option } from '../../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\nexport interface BadgeItemParams extends React.ComponentProps<'div'> {\r\n  option: Option | undefined;\r\n  onRemove: (value: string | number) => void;\r\n  className?: string;\r\n}\r\n\r\nconst BadgeItem = forwardRef<HTMLDivElement, BadgeItemParams>((props, ref) => {\r\n  const { option, onRemove, className, ...rest } = props;\r\n\r\n  const [isHovered, setIsHovered] = React.useState(false);\r\n\r\n  if (!option) return null;\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={cn(\r\n        'flex flex-row items-center justify-between px-2 break-words py-1 rounded-lg text-primary-background border border-input bg-background shadow-sm gap-2 transition-colors w-full max-w-full',\r\n        { 'bg-accent': isHovered },\r\n        className,\r\n      )}\r\n    >\r\n      {option && option.label}\r\n      <button\r\n        className={cn(\r\n          'flex item-center justify-center rounded-full bg-muted text-primary-background h-3 w-3 shadow-sm hover:bg-accent hover:text-accent-foreground transition',\r\n          { 'bg-accent text-accent-foreground scale-110 ': isHovered },\r\n        )}\r\n      >\r\n        <Cross1Icon\r\n          className={cn('w-3 h-3')}\r\n          onClick={() => onRemove(option.value)}\r\n          onMouseEnter={() => setIsHovered(true)}\r\n          onMouseLeave={() => setIsHovered(false)}\r\n        />\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nBadgeItem.displayName = 'BadgeItem';\r\n\r\nexport default BadgeItem;\r\n",
  "/ReactFormMaker/enhancements/MultiSelect/MultiSelect.tsx": "'use client';\r\n\r\nimport * as React from 'react';\r\nimport { CaretSortIcon, CheckIcon } from '@radix-ui/react-icons';\r\n\r\nimport { cn } from '@/lib/utils';\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command';\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover';\r\nimport useResizeObserver from '@react-hook/resize-observer';\r\nimport { ClassValue } from 'clsx';\r\nimport BadgeItem from './BadgeItem';\r\n\r\nexport type Option = { value: string | number; label: string };\r\n\r\nexport interface MultiSelectParams\r\n  extends React.ComponentProps<typeof Popover> {\r\n  defaultValues?: string[];\r\n  onChange: (values: string[] | number[]) => void;\r\n  options: { value: string | number; label: string }[];\r\n  placeholder?: string;\r\n  legend?: string;\r\n  id: string;\r\n  className?: ClassValue[] | string | undefined;\r\n}\r\n/**\r\n * ## MultiSelect Autocomplete\r\n *\r\n * A select autocomplete component that allows the user to select an option from a list of options.\r\n *\r\n * ### Attributes\r\n *\r\n * | Name | isRequired | Description | Type |\r\n * | --- | --- | --- | --- |\r\n * | defaultValue | false | The default value of the select autocomplete | string |\r\n * | onChange | true | The function to call when the value changes | (value: string) => void |\r\n * | options | true | The list of options to select from | { value: string; label: string }[] |\r\n * | placeholder | false | The placeholder text | string |\r\n * | legend | false | The legend text | string |\r\n *\r\n * #### Other attributes\r\n *\r\n * | Name | Description | Type |\r\n * | --- | --- | --- |\r\n * | children | The children of the component | React.ReactNode |\r\n * | open | The state of the popover | boolean |\r\n * | defaultOpen | The default state of the popover | boolean |\r\n * | onOpenChange | The function to call when the popover state changes | (open: boolean) => void |\r\n * | modal | The modal state of the popover | boolean |\r\n *\r\n * ### Usage & comportment\r\n *\r\n * - On Focus: The component displays a list of options.\r\n * - On Blur: The component hides the list of options.\r\n * - On Click: The component selects an option and puts it in the input. (the value is stored in the state)\r\n * - On Change: The component calls the `onChange` function with the selected value.\r\n *\r\n *\r\n * @param param0\r\n * @returns\r\n */\r\nexport const MultiSelect = React.forwardRef<HTMLDivElement, MultiSelectParams>(\r\n  (\r\n    {\r\n      defaultValues,\r\n      onChange,\r\n      options,\r\n      placeholder,\r\n      legend = 'Select option...',\r\n      id,\r\n      className,\r\n      ...props\r\n    }: MultiSelectParams,\r\n    ref,\r\n  ) => {\r\n    const inputTrigger = React.useRef<HTMLDivElement>(null);\r\n    const [open, setOpen] = React.useState(props.defaultOpen || false);\r\n    const [value, setValue] = React.useState<string[] | number[]>(\r\n      defaultValues || [],\r\n    );\r\n    const [currentOption, setCurrentOption] = React.useState<Option[] | null>(\r\n      options,\r\n    );\r\n    const [widthCombobox, setWidthCombobox] = React.useState<number | null>(\r\n      null,\r\n    );\r\n\r\n    useResizeObserver(inputTrigger, (entry) => {\r\n      setWidthCombobox(entry.borderBoxSize[0].inlineSize);\r\n    });\r\n\r\n    function pushValue(newValue: string | number): void {\r\n      if (\r\n        (value.every((item) => typeof item === 'string') &&\r\n          typeof newValue === 'string') ||\r\n        (value.length === 0 && typeof newValue === 'string')\r\n      ) {\r\n        const newArr = [...(value as string[]), newValue];\r\n        setValue(newArr);\r\n        onChange(newArr);\r\n      } else if (\r\n        (value.every((item) => typeof item === 'number') &&\r\n          typeof newValue === 'number') ||\r\n        (value.length === 0 && typeof newValue === 'number')\r\n      ) {\r\n        const newArr = [...(value as number[]), newValue];\r\n        setValue(newArr);\r\n        onChange(newArr);\r\n      } else {\r\n        console.warn(\r\n          'HAS every item go number ?',\r\n          value.every((item) => typeof item === 'number'),\r\n          value,\r\n        );\r\n        console.warn(\r\n          `Type mismatch: expected 'string' or 'number', got ${typeof newValue}`,\r\n        );\r\n      }\r\n    }\r\n\r\n    function removeValue(valueToRemove: string | number) {\r\n      let newArr: typeof value;\r\n      if (\r\n        (value.every((item) => typeof item === 'string') &&\r\n          typeof valueToRemove === 'string') ||\r\n        (value.length === 0 && typeof valueToRemove === 'string')\r\n      ) {\r\n        newArr = value.filter((v) => v !== valueToRemove) as string[];\r\n      } else if (\r\n        (value.every((item) => typeof item === 'number') &&\r\n          typeof valueToRemove === 'number') ||\r\n        (value.length === 0 && typeof valueToRemove === 'number')\r\n      ) {\r\n        newArr = (value as number[]).filter((v) => v !== valueToRemove);\r\n      } else {\r\n        console.warn(\r\n          `Type mismatch: expected 'string' or 'number', got ${typeof valueToRemove}`,\r\n        );\r\n        return;\r\n      }\r\n      setValue(newArr);\r\n      onChange(newArr);\r\n      if (newArr.length === 0) {\r\n        setCurrentOption(options);\r\n      }\r\n    }\r\n\r\n    const handleInputChange = (valueLabel: string) => {\r\n      const newValue = options.filter((option) =>\r\n        option.label\r\n          .toLowerCase()\r\n          .trim()\r\n          .includes(valueLabel.toLowerCase().trim()),\r\n      );\r\n\r\n      setCurrentOption(newValue);\r\n    };\r\n\r\n    function renderBadges() {\r\n      if (!value.length) return <span>{legend}</span>;\r\n      return value.map((v) => {\r\n        const optionItem = options.find((option) => option.value === v);\r\n        // eslint-disable-next-line react/jsx-no-bind\r\n        return <BadgeItem key={v} option={optionItem} onRemove={removeValue} />;\r\n      });\r\n    }\r\n\r\n    return (\r\n      <div ref={ref} className=\"w-full\">\r\n        <Popover open={open} onOpenChange={setOpen} {...props}>\r\n          <PopoverTrigger asChild>\r\n            <div\r\n              ref={inputTrigger}\r\n              className={cn(\r\n                'w-full max-w-full wrap p-2 inline-flex rounded-md transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50',\r\n                'border border-input bg-background-muted shadow-sm hover:bg-accent hover:text-accent-foreground',\r\n                className,\r\n              )}\r\n              role=\"combobox\"\r\n              aria-expanded={open}\r\n              aria-controls={id}\r\n              aria-haspopup=\"listbox\"\r\n              aria-owns={id}\r\n              aria-autocomplete=\"list\"\r\n              id={id}\r\n            >\r\n              <div className=\"flex flex-wrap gap-2 w-full max-w-full\">\r\n                {renderBadges()}\r\n              </div>\r\n              <CaretSortIcon className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\r\n            </div>\r\n          </PopoverTrigger>\r\n          <PopoverContent\r\n            className=\"w-[100%] p-0\"\r\n            style={{\r\n              width: `${widthCombobox}px`,\r\n            }}\r\n          >\r\n            <Command>\r\n              <CommandInput\r\n                placeholder={placeholder}\r\n                className=\"h-9\"\r\n                onValueChange={(output) => handleInputChange(output)}\r\n              />\r\n              <CommandList>\r\n                <CommandEmpty>No option found.</CommandEmpty>\r\n                <CommandGroup>\r\n                  {currentOption &&\r\n                    currentOption.map((option) => (\r\n                      <CommandItem\r\n                        key={option.value}\r\n                        value={option.label}\r\n                        onSelect={(currentValue) => {\r\n                          const selectedValue = options.find(\r\n                            (optionElement) =>\r\n                              optionElement.label === currentValue,\r\n                          )?.value;\r\n\r\n                          if (!selectedValue) {\r\n                            return;\r\n                          }\r\n\r\n                          // eslint-disable-next-line @typescript-eslint/no-unused-expressions\r\n                          value.includes(selectedValue as never)\r\n                            ? removeValue(selectedValue)\r\n                            : pushValue(selectedValue);\r\n                        }}\r\n                      >\r\n                        {option.label}\r\n                        <CheckIcon\r\n                          className={cn(\r\n                            'ml-auto h-4 w-4',\r\n                            value.includes(option.value as never)\r\n                              ? 'opacity-100'\r\n                              : 'opacity-0',\r\n                          )}\r\n                        />\r\n                      </CommandItem>\r\n                    ))}\r\n                </CommandGroup>\r\n              </CommandList>\r\n            </Command>\r\n          </PopoverContent>\r\n        </Popover>\r\n      </div>\r\n    );\r\n  },\r\n);\r\nMultiSelect.displayName = 'MultiSelect';\r\nexport default MultiSelect;\r\n",
  "/ReactFormMaker/enhancements/PhoneInput.tsx": "import * as React from 'react';\r\nimport { CheckIcon, ChevronsUpDown } from 'lucide-react';\r\nimport * as RPNInput from 'react-phone-number-input';\r\nimport flags from 'react-phone-number-input/flags';\r\n\r\nimport { Button } from '@/components/ui/button';\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command';\r\nimport { Input } from '@/components/ui/input';\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover';\r\nimport { cn } from '@/lib/utils';\r\nimport { ScrollArea } from '@radix-ui/react-scroll-area';\r\nimport { CountryCode } from 'libphonenumber-js/core';\r\n\r\ninterface CountrySelectOptionProps extends RPNInput.FlagProps {\r\n  selectedCountry: RPNInput.Country;\r\n  onChange: (country: RPNInput.Country) => void;\r\n}\r\n\r\ntype IpApiInfo = {\r\n  ip: string;\r\n  network: string;\r\n  version: string;\r\n  city: string;\r\n  region: string;\r\n  region_code: string;\r\n  country: string;\r\n  country_name: string;\r\n  country_code: CountryCode;\r\n  country_code_iso3: string;\r\n  country_capital: string;\r\n  country_tld: string;\r\n  continent_code: string;\r\n  in_eu: boolean;\r\n  postal: string;\r\n  latitude: number;\r\n  longitude: number;\r\n  timezone: string;\r\n  utc_offset: string;\r\n  country_calling_code: string;\r\n  currency: string;\r\n  currency_name: string;\r\n  languages: string;\r\n  country_area: number;\r\n  country_population: number;\r\n  asn: string;\r\n  org: string;\r\n};\r\n\r\ntype PhoneInputProps = Omit<\r\n  React.ComponentProps<'input'>,\r\n  'onChange' | 'value' | 'ref'\r\n> &\r\n  Omit<RPNInput.Props<typeof RPNInput.default>, 'onChange'> & {\r\n    onChange?: (value: RPNInput.Value) => void;\r\n  };\r\n\r\nconst InputComponent = React.forwardRef<\r\n  HTMLInputElement,\r\n  React.ComponentProps<'input'>\r\n>(({ className, ...props }, ref) => (\r\n  <Input\r\n    className={cn('rounded-e-lg rounded-s-none', className)}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n));\r\nInputComponent.displayName = 'InputComponent';\r\n\r\ntype CountryEntry = { label: string; value: RPNInput.Country | undefined };\r\n\r\ntype CountrySelectProps = {\r\n  disabled?: boolean;\r\n  value: RPNInput.Country;\r\n  options: CountryEntry[];\r\n  onChange: (country: RPNInput.Country) => void;\r\n};\r\n\r\nfunction FlagComponent({ country, countryName }: RPNInput.FlagProps) {\r\n  const Flag = flags[country];\r\n\r\n  return (\r\n    <span className=\"flex h-4 w-6 overflow-hidden rounded-sm bg-foreground/20\">\r\n      {Flag && <Flag title={countryName} />}\r\n    </span>\r\n  );\r\n}\r\n\r\nfunction CountrySelectOption({\r\n  country,\r\n  countryName,\r\n  selectedCountry,\r\n  onChange,\r\n}: CountrySelectOptionProps) {\r\n  return (\r\n    <CommandItem className=\"gap-2\" onSelect={() => onChange(country)}>\r\n      <FlagComponent country={country} countryName={countryName} />\r\n      <span className=\"flex-1 text-sm\">{countryName}</span>\r\n      <span className=\"text-sm text-foreground/50\">{`+${RPNInput.getCountryCallingCode(country)}`}</span>\r\n      <CheckIcon\r\n        className={`ml-auto size-4 ${country === selectedCountry ? 'opacity-100' : 'opacity-0'}`}\r\n      />\r\n    </CommandItem>\r\n  );\r\n}\r\n\r\nfunction CountrySelect({\r\n  disabled,\r\n  value: selectedCountry,\r\n  options: countryList,\r\n  onChange,\r\n}: CountrySelectProps) {\r\n  return (\r\n    <Popover>\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"outline\"\r\n          className=\"flex gap-1 rounded-e-none rounded-s-lg border-r-0 px-3 focus:z-10\"\r\n          disabled={disabled}\r\n        >\r\n          <FlagComponent\r\n            country={selectedCountry}\r\n            countryName={selectedCountry}\r\n          />\r\n          <ChevronsUpDown\r\n            className={cn(\r\n              '-mr-2 size-4 opacity-50',\r\n              disabled ? 'hidden' : 'opacity-100',\r\n            )}\r\n          />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent className=\"w-[300px] p-0\">\r\n        <Command>\r\n          <CommandInput placeholder=\"Search country...\" />\r\n          <CommandList>\r\n            <ScrollArea className=\"h-72\">\r\n              <CommandEmpty>No country found.</CommandEmpty>\r\n              <CommandGroup>\r\n                {countryList.map(({ value, label }) =>\r\n                  value ? (\r\n                    <CountrySelectOption\r\n                      key={value}\r\n                      country={value}\r\n                      countryName={label}\r\n                      selectedCountry={selectedCountry}\r\n                      onChange={onChange}\r\n                    />\r\n                  ) : null,\r\n                )}\r\n              </CommandGroup>\r\n            </ScrollArea>\r\n          </CommandList>\r\n        </Command>\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n\r\nconst PhoneInput: React.ForwardRefExoticComponent<PhoneInputProps> =\r\n  React.forwardRef<React.ElementRef<typeof RPNInput.default>, PhoneInputProps>(\r\n    ({ className, onChange, ...props }, ref) => {\r\n      const [defaultCountry, setDefaultCountry] = React.useState<\r\n        RPNInput.Country | undefined\r\n      >(undefined);\r\n\r\n      React.useEffect(() => {\r\n        const fetchCountry = async () => {\r\n          try {\r\n            const response = await fetch('https://ipapi.co/json/');\r\n            const data = (await response.json()) as IpApiInfo;\r\n            setDefaultCountry(data.country_code);\r\n          } catch (error) {\r\n            console.warn('Error fetching geolocation data:', error);\r\n          }\r\n        };\r\n\r\n        fetchCountry().catch((error) => {\r\n          console.warn('Error fetching country data:', error);\r\n        });\r\n      }, []);\r\n\r\n      return (\r\n        // eslint-disable-next-line react/jsx-pascal-case\r\n        <RPNInput.default\r\n          ref={ref}\r\n          international\r\n          defaultCountry={defaultCountry}\r\n          className={cn('flex', className)}\r\n          flagComponent={FlagComponent}\r\n          countrySelectComponent={CountrySelect}\r\n          inputComponent={InputComponent}\r\n          smartCaret\r\n          focusInputOnCountrySelection\r\n          addInternationalOption\r\n          /**\r\n           * Handles the onChange event.\r\n           *\r\n           * react-phone-number-input might trigger the onChange event as undefined\r\n           * when a valid phone number is not entered. To prevent this,\r\n           * the value is coerced to an empty string.\r\n           *\r\n           * @param {E164Number | undefined} value - The entered value\r\n           */\r\n          onChange={(value) => onChange?.(value || ('' as RPNInput.Value))}\r\n          {...props}\r\n        />\r\n      );\r\n    },\r\n  );\r\nPhoneInput.displayName = 'PhoneInput';\r\n\r\nexport default PhoneInput;\r\n",
  "/ReactFormMaker/enhancements/SelectAutocomplete.tsx": "'use client';\r\n\r\nimport * as React from 'react';\r\nimport { CaretSortIcon, CheckIcon } from '@radix-ui/react-icons';\r\n\r\nimport { cn } from '@/lib/utils';\r\nimport { Button } from '@/components/ui/button';\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command';\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover';\r\nimport {\r\n  isOption,\r\n  isOptionsArray,\r\n  Option,\r\n} from '../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\nexport interface SelectAutocompleteParams\r\n  extends React.ComponentProps<typeof Popover> {\r\n  defaultValue?: string | number;\r\n  onChange: (value: string | number | null) => void;\r\n  options: Option[] | string[];\r\n  placeholder?: string;\r\n  legend?: string;\r\n  id: string;\r\n}\r\n/**\r\n * ## Select Autocomplete\r\n *\r\n * A select autocomplete component that allows the user to select an option from a list of options.\r\n *\r\n * ### Attributes\r\n *\r\n * | Name | isRequired | Description | Type |\r\n * | --- | --- | --- | --- |\r\n * | defaultValue | false | The default value of the select autocomplete | string |\r\n * | onChange | true | The function to call when the value changes | (value: string) => void |\r\n * | options | true | The list of options to select from | { value: string; label: string }[] |\r\n * | placeholder | false | The placeholder text | string |\r\n * | legend | false | The legend text | string |\r\n *\r\n * #### Other attributes\r\n *\r\n * | Name | Description | Type |\r\n * | --- | --- | --- |\r\n * | children | The children of the component | React.ReactNode |\r\n * | open | The state of the popover | boolean |\r\n * | defaultOpen | The default state of the popover | boolean |\r\n * | onOpenChange | The function to call when the popover state changes | (open: boolean) => void |\r\n * | modal | The modal state of the popover | boolean |\r\n *\r\n * ### Usage & comportment\r\n *\r\n * - On Focus: The component displays a list of options.\r\n * - On Blur: The component hides the list of options.\r\n * - On Click: The component selects an option and puts it in the input. (the value is stored in the state)\r\n * - On Change: The component calls the `onChange` function with the selected value.\r\n *\r\n *\r\n * @param param0\r\n * @returns\r\n */\r\nexport function SelectAutocomplete({\r\n  defaultValue,\r\n  onChange,\r\n  options,\r\n  placeholder,\r\n  legend = 'Select option...',\r\n  id,\r\n  ...props\r\n}: SelectAutocompleteParams) {\r\n  const [open, setOpen] = React.useState(props.defaultOpen || false);\r\n  const [value, setValue] = React.useState(defaultValue || null);\r\n  const [currentOption, setCurrentOption] = React.useState<Option[] | string[]>(\r\n    options,\r\n  );\r\n\r\n  const handleInputChange = (data: string) => {\r\n    if (!data || data === '') setCurrentOption(options);\r\n    else if (isOptionsArray(options)) {\r\n      setCurrentOption(\r\n        options.filter((optionItem) =>\r\n          optionItem.label\r\n            .toLowerCase()\r\n            .trim()\r\n            .includes(data.toLowerCase().trim()),\r\n        ),\r\n      );\r\n    } else {\r\n      setCurrentOption(\r\n        options.filter((optionItem) =>\r\n          optionItem.toLowerCase().trim().includes(data.toLowerCase().trim()),\r\n        ),\r\n      );\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={setOpen}>\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"outline\"\r\n          role=\"combobox\"\r\n          aria-expanded={open}\r\n          className=\"w-[200px] justify-between\"\r\n          aria-controls={id}\r\n          aria-haspopup=\"listbox\"\r\n          aria-owns={id}\r\n          aria-autocomplete=\"list\"\r\n          aria-activedescendant={value ? `option-${value}` : undefined}\r\n          id={id}\r\n        >\r\n          {value\r\n            ? (() => {\r\n                const selected = options.find((option) =>\r\n                  isOption(option) ? option.value === value : option === value,\r\n                );\r\n                if (!selected) return legend;\r\n                if (isOption(selected)) return selected.label;\r\n                if (typeof selected === 'string') return selected;\r\n                return legend;\r\n              })()\r\n            : legend}\r\n          <CaretSortIcon className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent className=\"w-[200px] p-0\">\r\n        <Command>\r\n          <CommandInput\r\n            placeholder={placeholder}\r\n            className=\"h-9\"\r\n            onValueChange={(inputValue) => handleInputChange(inputValue)}\r\n          />\r\n          <CommandList>\r\n            <CommandEmpty>No option found.</CommandEmpty>\r\n            <CommandGroup>\r\n              {currentOption &&\r\n                currentOption.map((option) => (\r\n                  <CommandItem\r\n                    id={`option-${isOption(option) ? option.value : option}`}\r\n                    key={isOption(option) ? option.value : option}\r\n                    value={isOption(option) ? option.label : option}\r\n                    onSelect={(currentValue) => {\r\n                      const selectedValue = isOptionsArray(options)\r\n                        ? options.find(\r\n                            (optionItem) => optionItem.label === currentValue,\r\n                          )\r\n                        : options.find(\r\n                            (optionItem) => optionItem === currentValue,\r\n                          );\r\n                      if (!selectedValue) {\r\n                        return;\r\n                      }\r\n                      const extractedValue = isOption(selectedValue)\r\n                        ? selectedValue.value\r\n                        : selectedValue;\r\n                      const isUnselecting = extractedValue === value;\r\n                      setValue(isUnselecting ? '' : extractedValue);\r\n                      if (!isUnselecting) setOpen(false);\r\n                    }}\r\n                  >\r\n                    {isOption(option) ? option.label : option}\r\n                    <CheckIcon\r\n                      className={cn(\r\n                        'ml-auto h-4 w-4',\r\n                        value === (isOption(option) ? option.value : option)\r\n                          ? 'opacity-100'\r\n                          : 'opacity-0',\r\n                      )}\r\n                    />\r\n                  </CommandItem>\r\n                ))}\r\n            </CommandGroup>\r\n          </CommandList>\r\n        </Command>\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n",
  "/ReactFormMaker/enhancements/SelectSimple.tsx": "import React from 'react';\r\nimport {\r\n  Select,\r\n  SelectTrigger,\r\n  SelectValue,\r\n  SelectContent,\r\n  SelectGroup,\r\n  SelectLabel,\r\n  SelectItem,\r\n} from '@/components/ui/select';\r\nimport * as SelectPrimitive from '@radix-ui/react-select';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\r\nimport { mergeRefs } from '@/lib/utils';\r\n\r\nconst SelectSimple = React.forwardRef<\r\n  React.ElementRef<typeof SelectPrimitive.Trigger>, // Type attendu par SelectTrigger\r\n  FieldParams\r\n>(\r\n  (\r\n    { zFields, fieldProps, indexField }: FieldParams,\r\n    ref: React.ForwardedRef<React.ElementRef<typeof SelectPrimitive.Trigger>>,\r\n  ) => {\r\n    const { ref: zFieldsRef, ...restZFields } = zFields;\r\n    return (\r\n      <Select\r\n        key={indexField}\r\n        // className={fieldProps.className}\r\n        disabled={fieldProps.disabled}\r\n        onValueChange={(value: string | number) => {\r\n          // si la valeut est un string numeraire alors on le change en number\r\n          let newValue = value;\r\n          if (\r\n            typeof value === 'string' &&\r\n            Number.isFinite(parseInt(value, 10))\r\n          ) {\r\n            newValue = Number(value);\r\n          }\r\n          zFields.onChange(newValue);\r\n        }}\r\n        {...restZFields}\r\n      >\r\n        <SelectTrigger ref={mergeRefs(ref, zFieldsRef)}>\r\n          <SelectValue placeholder={fieldProps.placeholder} />\r\n        </SelectTrigger>\r\n        <SelectContent>\r\n          <SelectGroup>\r\n            <SelectLabel>{fieldProps.label}</SelectLabel>\r\n            {fieldProps.options?.map((option) => (\r\n              <SelectItem\r\n                key={isOption(option) ? `select-item-${option.value}` : option}\r\n                value={isOption(option) ? (option.value as string) : option}\r\n              >\r\n                {isOption(option) ? option.label : option}\r\n              </SelectItem>\r\n            ))}\r\n          </SelectGroup>\r\n        </SelectContent>\r\n      </Select>\r\n    );\r\n  },\r\n);\r\nSelectSimple.displayName = 'SelectSimple';\r\n\r\nexport default SelectSimple;\r\n",
  "/ReactFormMaker/enhancements/TileSelector/TileMultiSelector.tsx": "import React, { useState, useEffect, useRef, forwardRef } from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\r\nimport TileSelectorItem from './TileSelectorItem';\r\nimport {\r\n  isOption,\r\n  Option,\r\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\r\nimport { ClassValue } from 'clsx';\r\n\r\nexport interface TileMultiSelectorProps {\r\n  options: string[] | Option[];\r\n  onSelect?: (values: string[] | number[]) => void;\r\n  onChange?: (values: string[] | number[]) => void;\r\n  onBlur?: (values: string[]) => void;\r\n  value?: string[];\r\n  disabled?: boolean;\r\n  ref?: React.Ref<HTMLDivElement>;\r\n  defaultValue: string[];\r\n  legend?: string;\r\n  label?: string;\r\n  itemClassName?: string;\r\n  className?: ClassValue[] | string | undefined;\r\n  id?: string;\r\n  excludes?: string[] | number[];\r\n  icon?: React.ReactNode;\r\n}\r\n\r\nconst TileMultiSelector = forwardRef<HTMLDivElement, TileMultiSelectorProps>(\r\n  (props, ref) => {\r\n    const {\r\n      options,\r\n      onSelect,\r\n      onChange,\r\n      defaultValue = [],\r\n      className,\r\n      disabled,\r\n      id,\r\n      legend,\r\n      itemClassName,\r\n      excludes,\r\n    } = props;\r\n    const [selectedValues, setSelectedValues] = useState<string[] | number[]>(\r\n      defaultValue,\r\n    );\r\n    const [focusedIndex, setFocusedIndex] = useState(0);\r\n    const uuids = useGenerateUUIDs(\r\n      options.map((item) => (isOption(item) ? item.value : item)),\r\n    );\r\n    const itemsRef = useRef<(HTMLDivElement | null)[]>([]);\r\n\r\n    function isChildFocused(\r\n      activeElement: Element | null = document.activeElement,\r\n    ) {\r\n      return itemsRef.current.some((item) => item === activeElement);\r\n    }\r\n\r\n    const handleChange = (value: string | number) => {\r\n      let newSelectedValues: string[] | number[] = [];\r\n      if (selectedValues && selectedValues.includes(value as never)) {\r\n        newSelectedValues = selectedValues.filter((v) => v !== value) as\r\n          | string[]\r\n          | number[];\r\n      } else {\r\n        newSelectedValues = [...selectedValues, value] as string[] | number[];\r\n      }\r\n\r\n      setSelectedValues(newSelectedValues);\r\n      onSelect && onSelect(newSelectedValues);\r\n      onChange && onChange(newSelectedValues);\r\n    };\r\n\r\n    const handleKeyDown = (e: React.KeyboardEvent) => {\r\n      if (!isChildFocused) {\r\n        return;\r\n      }\r\n\r\n      if (e.key === 'ArrowDown') {\r\n        setFocusedIndex((prevIndex) => (prevIndex + 1) % options.length);\r\n      } else if (e.key === 'ArrowUp') {\r\n        setFocusedIndex(\r\n          (prevIndex) => (prevIndex - 1 + options.length) % options.length,\r\n        );\r\n      } else if (e.key === 'Enter' || e.key === ' ') {\r\n        const optionSelected = options[focusedIndex];\r\n        handleChange(\r\n          isOption(optionSelected) ? optionSelected.label : optionSelected,\r\n        );\r\n      }\r\n    };\r\n\r\n    useEffect(() => {\r\n      itemsRef.current[focusedIndex]?.focus();\r\n    }, [focusedIndex]);\r\n\r\n    function isSelected(item: string | Option) {\r\n      if (!selectedValues || !selectedValues.length) {\r\n        return false;\r\n      }\r\n      return selectedValues.includes(\r\n        (isOption(item) ? item.value : item) as never,\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        id={id}\r\n        aria-disabled={disabled}\r\n        role=\"group\"\r\n        aria-labelledby=\"tile-multi-selector-legend\"\r\n        className={cn('flex flex-col p-4', className)}\r\n        onKeyDown={handleKeyDown}\r\n      >\r\n        {<legend className=\"text-sm font-semibold\">{legend}</legend>}\r\n        {options.map((item, index) => {\r\n          const itemValue = isOption(item) ? item.label : item;\r\n          function isExcluded() {\r\n            return (\r\n              excludes &&\r\n              excludes.includes(\r\n                (isOption(itemValue) ? itemValue.value : itemValue) as never,\r\n              )\r\n            );\r\n          }\r\n\r\n          return (\r\n            <TileSelectorItem\r\n              disabled={disabled || isExcluded()}\r\n              key={uuids[index]}\r\n              option={item}\r\n              isSelected={isSelected(item)}\r\n              onSelect={handleChange}\r\n              className={itemClassName}\r\n              ref={(el) => {\r\n                itemsRef.current[index] = el;\r\n              }}\r\n              id={'tileMultiSelectorItem-' + itemValue}\r\n              icon={props.icon ?? null}\r\n            />\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  },\r\n);\r\n\r\nTileMultiSelector.displayName = 'TileMultiSelector';\r\n\r\nexport default TileMultiSelector;\r\n",
  "/ReactFormMaker/enhancements/TileSelector/TileSelector.tsx": "import React, { useState, useEffect, useRef, forwardRef } from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\r\nimport TileSelectorItem from './TileSelectorItem';\r\nimport {\r\n  isOption,\r\n  Option,\r\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\ninterface TileSelectorProps {\r\n  options: string[] | Option[];\r\n  onSelect?: (value: string) => void;\r\n  onChange?: (value: string) => void;\r\n  onBlur?: (value: string) => void;\r\n  onClick?: (value: string | number) => void;\r\n  value?: string;\r\n  disabled?: boolean;\r\n  ref?: React.Ref<HTMLDivElement>;\r\n  defaultValue: string;\r\n  legend?: string;\r\n  label?: string;\r\n  itemClassName?: string;\r\n  className?: string;\r\n  id?: string;\r\n  excludes?: string[] | number[];\r\n}\r\n\r\nconst TileSelector = forwardRef<HTMLDivElement, TileSelectorProps>(\r\n  (props, ref) => {\r\n    const {\r\n      options,\r\n      onSelect,\r\n      onChange,\r\n      onClick,\r\n      defaultValue,\r\n      className,\r\n      disabled,\r\n      id,\r\n      legend,\r\n      label,\r\n      itemClassName,\r\n      excludes,\r\n    } = props;\r\n    const [selectedValue, setSelectedValue] = useState<string | number | null>(\r\n      defaultValue,\r\n    );\r\n    const [focusedIndex, setFocusedIndex] = useState(0);\r\n    const uuids = useGenerateUUIDs(\r\n      options.map((item) => (isOption(item) ? item.value : item)),\r\n    );\r\n    const itemsRef = useRef<(HTMLDivElement | null)[]>([]);\r\n\r\n    function isChildFocused(\r\n      activeElement: Element | null = document.activeElement,\r\n    ) {\r\n      return itemsRef.current.some((item) => item === activeElement);\r\n    }\r\n\r\n    const handleChange = (value: string) => {\r\n      const option = options.find(\r\n        (item) => (isOption(item) ? item.label : item) === value,\r\n      );\r\n      if (!option) {\r\n        return;\r\n      }\r\n\r\n      const newValue =\r\n        value === selectedValue\r\n          ? null\r\n          : isOption(option)\r\n            ? option.value\r\n            : option;\r\n\r\n      if (!newValue) {\r\n        setSelectedValue(null);\r\n        return;\r\n      }\r\n\r\n      setSelectedValue(newValue);\r\n      if (onClick && newValue) {\r\n        onClick(newValue);\r\n      }\r\n    };\r\n\r\n    const handleKeyDown = (e: React.KeyboardEvent) => {\r\n      if (!isChildFocused) {\r\n        return;\r\n      }\r\n\r\n      if (e.key === 'ArrowDown') {\r\n        setFocusedIndex((prevIndex) => (prevIndex + 1) % options.length);\r\n      } else if (e.key === 'ArrowUp') {\r\n        setFocusedIndex(\r\n          (prevIndex) => (prevIndex - 1 + options.length) % options.length,\r\n        );\r\n      } else if (e.key === 'Enter' || e.key === ' ') {\r\n        const optionSelected = options[focusedIndex];\r\n        handleChange(\r\n          isOption(optionSelected) ? optionSelected.label : optionSelected,\r\n        );\r\n      }\r\n    };\r\n\r\n    useEffect(() => {\r\n      itemsRef.current[focusedIndex]?.focus();\r\n    }, [focusedIndex]);\r\n\r\n    function isSelected(item: string | Option) {\r\n      return selectedValue === (isOption(item) ? item.value : item);\r\n    }\r\n\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        id={id}\r\n        aria-disabled={disabled}\r\n        role=\"radiogroup\"\r\n        aria-labelledby=\"tile-selector-legend\"\r\n        className={cn('flex flex-col p-4', className)}\r\n        onKeyDown={handleKeyDown}\r\n      >\r\n        {<legend className=\"text-sm font-semibold\">{legend}</legend>}\r\n        {options.map((item, index) => {\r\n          const itemValue = isOption(item) ? item.value : item;\r\n          function isExcluded() {\r\n            return excludes && excludes.includes(itemValue as never);\r\n          }\r\n\r\n          return (\r\n            <TileSelectorItem\r\n              disabled={disabled || isExcluded()}\r\n              key={uuids[index]}\r\n              option={item}\r\n              isSelected={isSelected(item)}\r\n              onSelect={handleChange}\r\n              className={itemClassName}\r\n              ref={(el) => {\r\n                itemsRef.current[index] = el;\r\n              }}\r\n              id={'tileSelectorItem-' + itemValue}\r\n            />\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  },\r\n);\r\n\r\nTileSelector.displayName = 'TileSelector';\r\n\r\nexport default TileSelector;\r\n",
  "/ReactFormMaker/enhancements/TileSelector/TileSelectorItem.tsx": "import React, { forwardRef } from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { Check } from 'lucide-react';\r\nimport {\r\n  isOption,\r\n  Option,\r\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\ninterface TileSelectorItemProps {\r\n  option: string | Option;\r\n  isSelected: boolean;\r\n  onSelect: (value: string | number) => void;\r\n  className?: string;\r\n  id?: string | undefined;\r\n  disabled?: boolean;\r\n  icon?: React.ReactNode;\r\n}\r\n\r\nconst TileSelectorItem = forwardRef<HTMLDivElement, TileSelectorItemProps>(\r\n  ({ option, isSelected, onSelect, className, id, disabled, icon }, ref) => {\r\n    const TileSelectorItemStyle = cn(\r\n      'w-full flex flex-row items-center justify-start p-4 border border-gray-300 rounded-md cursor-pointer mb-2 shadow-sm transition-colors',\r\n      {\r\n        'bg-primary text-primary-foreground hover:bg-primary/90': isSelected,\r\n      },\r\n      {\r\n        'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground':\r\n          !isSelected,\r\n      },\r\n      {\r\n        'cursor-not-allowed opacity-50': disabled,\r\n      },\r\n      className,\r\n    );\r\n\r\n    function useValue(option: string | Option): string | number {\r\n      return isOption(option) ? option.value : option;\r\n    }\r\n\r\n    function useLabel(option: string | Option) {\r\n      return isOption(option) ? option.label : option;\r\n    }\r\n\r\n    const handleKeyDown = (e: React.KeyboardEvent) => {\r\n      if (e.key === 'Enter' || e.key === ' ') {\r\n        if (disabled) {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          return;\r\n        }\r\n        onSelect(useValue(option));\r\n      }\r\n    };\r\n\r\n    return (\r\n      <div\r\n        id={id}\r\n        ref={ref}\r\n        className={TileSelectorItemStyle}\r\n        role=\"radio\"\r\n        aria-disabled={disabled}\r\n        aria-checked={isSelected}\r\n        tabIndex={disabled ? -1 : 0}\r\n        onClick={() => {\r\n          if (disabled) return;\r\n          onSelect(useValue(option));\r\n        }}\r\n        onKeyDown={(e) => handleKeyDown(e)}\r\n      >\r\n        <div className=\"flex items-center justify-center w-6 h-6 mr-2\">\r\n          {icon\r\n            ? icon\r\n            : isSelected && (\r\n                <Check className=\"w-4 h-4 text-primary-foreground\" />\r\n              )}\r\n        </div>\r\n        {useLabel(option)}\r\n      </div>\r\n    );\r\n  },\r\n);\r\n\r\nexport default TileSelectorItem;\r\n",
  "/ReactFormMaker/enhancements/YearsDropdown.tsx": "import { Button } from '@/components/ui/button';\r\nimport {\r\n  Carousel,\r\n  CarouselContent,\r\n  CarouselItem,\r\n  CarouselNext,\r\n  CarouselPrevious,\r\n} from '@/components/ui/carousel';\r\nimport { cn } from '@/lib/utils';\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@radix-ui/react-popover';\r\nimport { ChevronDown } from 'lucide-react';\r\nimport React from 'react';\r\nimport { DropdownOption, DropdownProps, useDayPicker } from 'react-day-picker';\r\n\r\nexport interface YearsDropdownProps extends DropdownProps {\r\n  selectedYear: number;\r\n  setSelectedYear: React.Dispatch<React.SetStateAction<number>>;\r\n  range?: 'from' | 'to';\r\n}\r\n\r\nexport interface DateRange {\r\n  from: Date;\r\n  to: Date;\r\n}\r\n\r\nexport default function YearsDropdownCustom({\r\n  selectedYear,\r\n  setSelectedYear,\r\n  range = 'from',\r\n}: YearsDropdownProps) {\r\n  const { goToMonth, selected } = useDayPicker();\r\n  const [isOpen, setIsOpen] = React.useState(false);\r\n\r\n  const selectedData: DateRange = selected ?? {\r\n    from: new Date(),\r\n    to: new Date(),\r\n  };\r\n\r\n  const currentYear = new Date().getFullYear();\r\n  const decade = parseInt(`${currentYear.toString().slice(0, -1)}0`, 10);\r\n\r\n  const decades = Array.from({ length: 200 }, (_, i) => decade - 100 + i);\r\n\r\n  const segementDecade: Array<DropdownOption[]> = decades.reduce(\r\n    (acc: DropdownOption[][], year, index) => {\r\n      if (index % 10 === 0) {\r\n        acc.push([\r\n          {\r\n            value: year,\r\n            label: year.toString(),\r\n            disabled: false,\r\n          },\r\n        ]);\r\n      } else {\r\n        acc[acc.length - 1].push({\r\n          value: year,\r\n          label: year.toString(),\r\n          disabled: false,\r\n        });\r\n      }\r\n      return acc;\r\n    },\r\n    [],\r\n  );\r\n\r\n  function indexToStart(): number {\r\n    const index = segementDecade.findIndex((decadeData) => {\r\n      return decadeData.some((option) => {\r\n        return option.value === selectedYear;\r\n      });\r\n    });\r\n    return index;\r\n  }\r\n\r\n  return (\r\n    <Popover\r\n      onOpenChange={(e) => {\r\n        setIsOpen(e);\r\n      }}\r\n    >\r\n      <PopoverTrigger asChild>\r\n        <Button variant=\"ghost\">\r\n          {selectedYear}\r\n          <ChevronDown\r\n            orientation={isOpen ? 'up' : 'down'}\r\n            className={cn(\r\n              'h-4 w-4 transition-all transform duration-300 rotate-0',\r\n              isOpen && 'transform rotate-180',\r\n            )}\r\n          />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent className=\"w-auto p-0 z-10\">\r\n        <div className=\"bg-[white] w-[265px] items-center flexjustify-center p-3 acity-100 z-10 rounded-lg shadow-md border \">\r\n          <Carousel\r\n            opts={{\r\n              align: 'start',\r\n              startIndex: indexToStart(),\r\n            }}\r\n            className=\"w-[240px] max-w-sm\"\r\n          >\r\n            <CarouselContent>\r\n              {segementDecade.map((decade, index) => (\r\n                <CarouselItem\r\n                  key={decade[0].label}\r\n                  className=\"flex flex-row items-center justify-center w-full h-full flex-wrap m-2\"\r\n                >\r\n                  {decade.map((option) => (\r\n                    <Button\r\n                      key={option.value}\r\n                      onClick={() => {\r\n                        const newDate = new Date(\r\n                          option.value,\r\n                          selectedData[range]?.getMonth() ||\r\n                            new Date().getMonth(),\r\n                        );\r\n                        goToMonth(newDate);\r\n                        setSelectedYear(option.value);\r\n                      }}\r\n                      variant=\"ghost\"\r\n                      className={cn(\r\n                        'w-20 h-10',\r\n                        option.value === selectedYear &&\r\n                          'bg-primary text-primary-foreground',\r\n                      )}\r\n                    >\r\n                      {option.label}\r\n                    </Button>\r\n                  ))}\r\n                </CarouselItem>\r\n              ))}\r\n            </CarouselContent>\r\n            <CarouselPrevious />\r\n            <CarouselNext />\r\n          </Carousel>\r\n        </div>\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n",
  "/ReactFormMaker/formElements/DivElementField.tsx": "import React from 'react';\r\nimport { Slottable } from '@radix-ui/react-slot';\r\nimport {\r\n  CompositeField,\r\n  DividerReactFormMaker,\r\n  FieldReactFormMaker,\r\n} from '../interfaces/FieldInterfaces';\r\nimport { ElementField } from '../interfaces/ElementField';\r\n\r\ninterface DivElementFieldProps {\r\n  elementField: DividerReactFormMaker;\r\n  uuid: string;\r\n  FormFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[];\r\n}\r\n\r\nconst DivElementField: React.FC<DivElementFieldProps> = ({\r\n  elementField,\r\n  uuid,\r\n  FormFieldsMap,\r\n}) => {\r\n  return (\r\n    <div\r\n      key={uuid}\r\n      className={`${elementField.className} ${elementField.isHide ? 'hidden' : ''}`}\r\n    >\r\n      {\r\n        // Si l'élément comprend des sous-champs, on continue de les mapper\r\n        elementField.fields && FormFieldsMap(elementField.fields)\r\n      }\r\n      <Slottable>\r\n        {\r\n          // Si le champ est de type custom, on clone l'élément JSX et on lui passe les props\r\n          elementField.children &&\r\n            React.cloneElement(elementField.children as React.ReactElement, {})\r\n        }\r\n      </Slottable>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DivElementField;\r\n",
  "/ReactFormMaker/formElements/FormFieldElement.tsx": "import React from 'react';\r\nimport {\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n  FormControl,\r\n  FormDescription,\r\n  FormMessage,\r\n} from '@/components/ui/form';\r\nimport { Slottable } from '@radix-ui/react-slot';\r\nimport { FieldValues, Path, UseFormReturn } from 'react-hook-form';\r\nimport { ElementField } from '../interfaces/ElementField';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { CustomInputFieldElementParams } from '../interfaces/CustomInputFieldElementParams';\r\nimport { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\r\n\r\ninterface FormFieldElementProps<T extends FieldValues> {\r\n  elementField: FieldReactFormMaker;\r\n  index: string;\r\n  form: UseFormReturn<T>;\r\n  InpuTComponentCallBack: (params: FieldParams) => JSX.Element;\r\n}\r\n\r\nfunction FormFieldElement<T extends FieldValues>({\r\n  elementField,\r\n  index: key,\r\n  form,\r\n  InpuTComponentCallBack,\r\n}: FormFieldElementProps<T>) {\r\n  return (\r\n    <FormField\r\n      key={'fomr-field-element-' + key}\r\n      control={form.control}\r\n      name={elementField.inputName as Path<T>}\r\n      render={({ field }) => (\r\n        <FormItem\r\n          className=\"flex flex-col\"\r\n          key={'formitem' + key}\r\n          onBlur={(e: any) => {\r\n            if (elementField.onBlur) {\r\n              e.controlField = field;\r\n              e.form = form;\r\n              elementField.onBlur(e);\r\n            }\r\n          }}\r\n          onSelect={(e: any) => {\r\n            if (elementField.onSelect) {\r\n              e.controlField = field;\r\n              e.form = form;\r\n              elementField.onSelect(e);\r\n            }\r\n          }}\r\n          onChange={(e: any) => {\r\n            if (elementField.onChange) {\r\n              e.controlField = field;\r\n              e.form = form;\r\n              elementField.onChange(e);\r\n            }\r\n          }}\r\n          onClick={(e: any) => {\r\n            if (elementField.onClick) {\r\n              e.controlField = field;\r\n              e.form = form;\r\n              elementField.onClick(e);\r\n            }\r\n          }}\r\n        >\r\n          {elementField.label && !elementField.isSecure && (\r\n            <FormLabel htmlFor={elementField.inputName}>\r\n              {elementField.label}\r\n            </FormLabel>\r\n          )}\r\n          <FormControl>\r\n            <InpuTComponentCallBack\r\n              zFields={field}\r\n              fieldProps={elementField}\r\n              indexField={'input' + key}\r\n            />\r\n          </FormControl>\r\n          {elementField.description && !elementField.isSecure && (\r\n            <FormDescription>{elementField.description}</FormDescription>\r\n          )}\r\n          <FormMessage />\r\n          {elementField.children &&\r\n            React.isValidElement(elementField.children) &&\r\n            React.cloneElement(elementField.children, {\r\n              zFields: field,\r\n              fieldProps: elementField,\r\n              index: key,\r\n              ...elementField.props,\r\n            } as CustomInputFieldElementParams<any>)}\r\n        </FormItem>\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nexport default FormFieldElement;\r\n",
  "/ReactFormMaker/formElements/InputComponent.tsx": "import React, { useMemo, useState } from 'react';\r\nimport TextInput from '../inputs/TextInput';\r\nimport PasswordInput from '../inputs/PasswordInput';\r\nimport SelectInput from '../inputs/SelectInput';\r\nimport TextareaInput from '../inputs/TextareaInput';\r\nimport DateInput from '../inputs/DateInput';\r\nimport RadioInput from '../inputs/RadioInput';\r\nimport CheckboxInput from '../inputs/CheckboxInput';\r\nimport SwitchInput from '../inputs/SwitchInput';\r\nimport NumberInput from '../inputs/NumberInput';\r\nimport FileInput from '../inputs/FileInput';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { v4 as uuidV4 } from 'uuid';\r\nimport TileSelectorInput from '../inputs/TileSelectorInput';\r\nimport TileMultiSelectorInput from '../inputs/TileMultiselectorInput';\r\nimport SelectAutocompleteInput from '../inputs/SelectAutocompleteInput';\r\nimport PhoneNumberInput from '../inputs/PhoneNumberInput';\r\nimport FileDropZone from '../inputs/FileUploaderInput';\r\nimport MultiSelectInput from '../inputs/MultiSelectInput';\r\nimport DateRangeInput from '../inputs/DateRangeInput';\r\n\r\n/**\r\n * InputComponent is a versatile component that renders different types of input fields\r\n * based on the `inputType` provided in the `fieldProps`. It supports various input types\r\n * such as text, password, select, textarea, date, dateRange, radio, checkbox, switch, file,\r\n * number, and custom components.\r\n *\r\n * @param {FieldParams} params - The parameters for the input field.\r\n * @param {Object} params.fieldProps - The properties of the field.\r\n * @param {string} params.fieldProps.inputType - The type of input to render.\r\n * @param {React.ReactNode} params.fieldProps.children - The children elements for custom input.\r\n * @param {number} params.indexField - The index of the field.\r\n *\r\n * @returns {JSX.Element} The rendered input component based on the **input type**.\r\n *\r\n * ---\r\n *\r\n * @see {@link FieldParams} for the interface used in the `params` argument.\r\n */\r\nfunction InputComponent(params: FieldParams) {\r\n  const {\r\n    fieldProps: { inputType, customInputFieldElement },\r\n    indexField,\r\n  } = params;\r\n\r\n  //const [uuid, setUuid] = useState<string>(uuidV4());\r\n  const uuid = useMemo(() => uuidV4(), []);\r\n\r\n  switch (inputType) {\r\n    case 'text':\r\n      return <TextInput {...params} key={uuid} />;\r\n    case 'password':\r\n      return <PasswordInput {...params} key={uuid} />;\r\n    case 'select':\r\n      return <SelectInput {...params} key={uuid} />;\r\n    case 'selectAutocomplete':\r\n      return <SelectAutocompleteInput {...params} key={uuid} />;\r\n    case 'multiSelect':\r\n      return <MultiSelectInput {...params} key={uuid} />;\r\n    case 'textarea':\r\n      return <TextareaInput {...params} key={uuid} />;\r\n    case 'date':\r\n      return <DateInput {...params} key={uuid} />;\r\n    case 'dateRange':\r\n      return <DateRangeInput {...params} key={uuid} />;\r\n    case 'radio':\r\n      return <RadioInput {...params} key={uuid} />;\r\n    case 'checkbox':\r\n      return <CheckboxInput {...params} key={uuid} />;\r\n    case 'switch':\r\n      return <SwitchInput {...params} key={uuid} />;\r\n    case 'file':\r\n      return <FileInput {...params} key={uuid} />;\r\n    case 'fileDropZone':\r\n      return <FileDropZone {...params} key={uuid} />;\r\n    case 'number':\r\n      return <NumberInput {...params} key={uuid} />;\r\n    case 'tileSelector':\r\n      return <TileSelectorInput {...params} key={uuid} />;\r\n    case 'tileMultiSelector':\r\n      return <TileMultiSelectorInput {...params} key={uuid} />;\r\n    case 'phoneNumber':\r\n      return <PhoneNumberInput {...params} key={uuid} />;\r\n    case 'custom':\r\n      return React.cloneElement(customInputFieldElement as React.ReactElement, {\r\n        ...params,\r\n      });\r\n    default:\r\n      return (\r\n        <p key={uuid}>{`Type d'input non reconnu : ${inputType as string}`}</p>\r\n      );\r\n  }\r\n}\r\n\r\nexport default InputComponent;\r\n",
  "/ReactFormMaker/formElements/mapChildrenWithForm.tsx": "import React from 'react';\r\nimport { UseFormReturn } from 'react-hook-form';\r\n\r\ninterface FormEvent extends React.SyntheticEvent {\r\n  form: any;\r\n}\r\n\r\n/**\r\n * Maps over the children components and injects the form object into event handlers.\r\n * - - -\r\n * @param childrenComponents - The children components to be processed.\r\n * @param form - The form object to be injected into event handlers.\r\n * @returns A new set of children components with the form object injected into their event handlers.\r\n */\r\nconst mapChildrenWithForm = (\r\n  childrenComponents: React.ReactNode,\r\n  form: UseFormReturn<any>,\r\n): React.ReactNode =>\r\n  React.Children.map(childrenComponents, (child) => {\r\n    if (React.isValidElement(child)) {\r\n      const newProps = { ...child.props };\r\n      Object.keys(newProps).forEach((propName) => {\r\n        if (typeof newProps[propName] === 'function') {\r\n          const originalEventHandler = newProps[propName];\r\n          newProps[propName] = (event: FormEvent) => {\r\n            event.form = form;\r\n            originalEventHandler(event);\r\n          };\r\n        }\r\n      });\r\n      return React.cloneElement(child, newProps);\r\n    }\r\n    return child;\r\n  });\r\n\r\nexport default mapChildrenWithForm;\r\n",
  "/ReactFormMaker/formElements/Stepper/StepperContext.tsx": "import React from 'react';\r\nimport { UseFormReturn, FieldValues, Path } from 'react-hook-form';\r\nimport { CompositeField } from '../../interfaces/FieldInterfaces';\r\nimport {\r\n  isFieldReactFormMaker,\r\n  isStepReactFormMaker,\r\n} from '../../utils/typeGuards/compositeField.TypeGuards';\r\nimport stepReducer, { initialSteps } from './SteppersElements/stepReducer';\r\nimport { z } from 'zod';\r\nimport {\r\n  orientationMutable,\r\n  StepElement,\r\n  StepFormState,\r\n  StepperContextProps,\r\n} from './SteppersElements/StepperContext.interface';\r\nimport { usePromiseObserver } from '@/lib/usePromiseObserver';\r\nimport { CommandManager } from '@/lib/commandManager';\r\n\r\nlet bounced = 0;\r\n\r\nconst StepperContext = React.createContext<\r\n  StepperContextProps<any> | undefined\r\n>(undefined);\r\n\r\nfunction extractFieldNamesFromStep(\r\n  step: CompositeField,\r\n  FieldNames: string[] = [],\r\n): string[] {\r\n  if (step.fields && step.fields.length > 0) {\r\n    step.fields.forEach((field) => {\r\n      if (isFieldReactFormMaker(field)) {\r\n        FieldNames.push(field.inputName);\r\n      } else {\r\n        extractFieldNamesFromStep(field, FieldNames);\r\n      }\r\n    });\r\n  }\r\n  return FieldNames;\r\n}\r\n\r\n/**\r\n * ### Stepper Provider\r\n *\r\n * The `StepperProvider` component is a component that allows you to manage the state of the stepper.\r\n * This Provider is used specifically for the stepper in the form.\r\n *\r\n * ---\r\n *\r\n * #### Proprieties to pass\r\n *\r\n * - `children`: used to display the children of the component\r\n * - `form`: used to manage the form state inside each step\r\n * - `formfields`:  used to manage the steps and the rendering of the form\r\n * - `zObject`:  used to manage the validation of the form\r\n * - `orientation`: used to manage the orientation of the stepper (default: 'horizontal')\r\n *\r\n * ---\r\n *\r\n * For more information, see the {@link StepperProvider} interface or the {@link StepperContextProps} interface\r\n * @param param0\r\n * @returns\r\n */\r\nexport const StepperProvider = <T extends FieldValues>({\r\n  children,\r\n  form,\r\n  formfields,\r\n  zObject,\r\n  orientation = 'horizontal',\r\n}: {\r\n  children: React.ReactNode;\r\n  form: UseFormReturn<T>;\r\n  formfields: CompositeField[];\r\n  orientation?: 'vertical' | 'horizontal';\r\n  zObject: { [key in keyof T]: z.ZodType<T[key], z.ZodTypeDef, T[key]> };\r\n}) => {\r\n  const [stepIndex, setStepIndex] = React.useState<number>(0);\r\n  const [orientationMutable, setOrientationMutable] =\r\n    React.useState<orientationMutable>({ orientation, isOriginal: true });\r\n\r\n  const onBeforeNextStepMapper = React.useMemo(() => {\r\n    return formfields\r\n      .filter((field) => isStepReactFormMaker(field))\r\n      .reduce(\r\n        (acc, step) => {\r\n          if (step.onBeforeNextStep) {\r\n            acc[step.stepName] = step.onBeforeNextStep;\r\n          }\r\n          return acc;\r\n        },\r\n        {} as {\r\n          [key: string]: (data: {\r\n            submissionState: StepFormState<T>;\r\n            form: UseFormReturn<T>;\r\n          }) => Promise<boolean>;\r\n        },\r\n      );\r\n  }, [formfields]);\r\n\r\n  const handlersObserver = usePromiseObserver<\r\n    {\r\n      submissionState: StepFormState<T>;\r\n      form: UseFormReturn<T>;\r\n    },\r\n    boolean\r\n  >(onBeforeNextStepMapper);\r\n\r\n  const inputsNamesBySteps: string[][] = React.useMemo(() => {\r\n    return formfields.map((stepField) => {\r\n      return extractFieldNamesFromStep(stepField);\r\n    });\r\n  }, [formfields]);\r\n\r\n  const [steps, dispatch] = React.useReducer(\r\n    stepReducer,\r\n    formfields,\r\n    initialSteps,\r\n  );\r\n\r\n  const getFieldStatesBySteps = (\r\n    index: number = stepIndex,\r\n  ): StepFormState<T> => {\r\n    const StepFormState: StepFormState<T> = {\r\n      isValidStep: true,\r\n      fieldStatesDetails: {},\r\n    };\r\n    const currentInputsNames = inputsNamesBySteps[index] as Path<T>[];\r\n    currentInputsNames.forEach((inputName) => {\r\n      let isValid = false;\r\n      const value = form.getValues(inputName);\r\n      const fiedState = form.getFieldState(inputName);\r\n      const zField = zObject[inputName];\r\n\r\n      const { invalid, isDirty } = fiedState;\r\n      const fieldHasValue: boolean = value !== undefined;\r\n      const fieldIsNullable: boolean = zField.isNullable();\r\n      const fieldIsOptional: boolean = zField.isOptional();\r\n      if (fieldIsOptional || fieldIsNullable) {\r\n        isValid = isDirty ? !invalid : true;\r\n      } else {\r\n        isValid = isDirty ? !invalid : fieldHasValue;\r\n      }\r\n      const keyName = inputName as string;\r\n      if (!isValid) {\r\n        StepFormState.isValidStep = false;\r\n      }\r\n      StepFormState.fieldStatesDetails[keyName] = {\r\n        isValid,\r\n        value,\r\n        FieldState: fiedState,\r\n        zField,\r\n      };\r\n    });\r\n\r\n    return StepFormState;\r\n  };\r\n\r\n  React.useEffect(() => {\r\n    dispatch({ type: 'CHANGE_FOCUS', currentStepIndex: stepIndex });\r\n  }, [stepIndex]);\r\n\r\n  const triggeringFormStep = async (\r\n    currentStepIndex: number,\r\n  ): Promise<boolean> => {\r\n    const inputsNames = inputsNamesBySteps[currentStepIndex] as Path<T>[];\r\n    return await form.trigger(inputsNames);\r\n  };\r\n\r\n  const executeStepCompletion = async (currentStepIndex: number) => {\r\n    const dispachQueue = new CommandManager({\r\n      dispatch,\r\n      stepIndex: currentStepIndex,\r\n    });\r\n\r\n    dispachQueue.addCommands([\r\n      {\r\n        name: 'setDone',\r\n        command: async ({ dispatch, stepIndex }) => {\r\n          dispatch({ type: 'SET_DONE', currentStepIndex: stepIndex });\r\n          return { success: true };\r\n        },\r\n      },\r\n      {\r\n        name: 'setStrictDisabledEffect',\r\n        command: async ({ dispatch }) => {\r\n          dispatch({ type: 'SET_STRICT_DISABLED_EFFECT' });\r\n          return { success: true };\r\n        },\r\n      },\r\n      {\r\n        name: 'setBeforeDisabledEffect',\r\n        command: async ({ dispatch }) => {\r\n          dispatch({ type: 'SET_BETFORE_DISABLED_EFFECT' });\r\n          return { success: true };\r\n        },\r\n      },\r\n    ]);\r\n    await dispachQueue.execute();\r\n  };\r\n\r\n  const getNbSteps = () => steps.length;\r\n\r\n  const getCurrentStep = () => steps[stepIndex];\r\n\r\n  const goToStep = async (newStepIndex: number) => {\r\n    if (stepIndex === newStepIndex) {\r\n      return;\r\n    } else if (steps[newStepIndex].isdisabled) {\r\n      return;\r\n    } else if (stepIndex > newStepIndex) {\r\n      setStepIndex(newStepIndex);\r\n      return;\r\n    }\r\n    triggeringFormStep(stepIndex).then((isValid) => {\r\n      if (isValid) {\r\n        executeStepCompletion(stepIndex).then(() => {\r\n          setStepIndex(newStepIndex);\r\n        });\r\n      } else {\r\n        dispatch({ type: 'REMOVE_DONE', currentStepIndex: stepIndex });\r\n      }\r\n    });\r\n  };\r\n\r\n  const goNextStep = (): void => {\r\n    triggeringFormStep(stepIndex).then((isValid) => {\r\n      if (isValid) {\r\n        if (steps[stepIndex].onBeforeNextStep) {\r\n          const submissionState = getFieldStatesBySteps();\r\n          const data = {\r\n            submissionState,\r\n            form,\r\n          };\r\n          handlersObserver.execute(steps[stepIndex].stepName, data);\r\n          steps[stepIndex].onBeforeNextStep(data).then((isSwitch: boolean) => {\r\n            if (isSwitch) {\r\n              executeStepCompletion(stepIndex).then(() => {\r\n                setStepIndex(stepIndex + 1);\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          executeStepCompletion(stepIndex).then(() => {\r\n            setStepIndex(stepIndex + 1);\r\n          });\r\n        }\r\n      } else {\r\n        dispatch({ type: 'REMOVE_DONE', currentStepIndex: stepIndex });\r\n      }\r\n    });\r\n  };\r\n\r\n  const goPreviousStep = (): void => {\r\n    if (stepIndex > 0) {\r\n      setStepIndex(stepIndex - 1);\r\n    }\r\n  };\r\n\r\n  const getPreviousStep = (): StepElement | undefined => {\r\n    if (stepIndex > 0) {\r\n      return steps[stepIndex - 1];\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const getNextStep = (): StepElement | undefined => {\r\n    if (stepIndex < steps.length - 1) {\r\n      return steps[stepIndex + 1];\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const shiftOrientation = (width: number): void => {\r\n    const { orientation: currentOrientation, isOriginal } = orientationMutable;\r\n    if (width < 640) {\r\n      if (currentOrientation === 'vertical' && isOriginal) {\r\n        setOrientationMutable({ orientation: 'horizontal', isOriginal: false });\r\n      }\r\n    } else if (currentOrientation === 'horizontal' && !isOriginal) {\r\n      setOrientationMutable({ orientation: 'vertical', isOriginal: true });\r\n    }\r\n  };\r\n\r\n  const getListenerObserver = (\r\n    index: number,\r\n  ): 'idle' | 'loading' | 'resolved' | 'rejected' => {\r\n    const { stepName } = steps[index];\r\n    return handlersObserver.listener(stepName);\r\n  };\r\n\r\n  return (\r\n    <StepperContext.Provider\r\n      value={{\r\n        steps,\r\n        getNbSteps,\r\n        getCurrentStep,\r\n        goToStep,\r\n        goNextStep,\r\n        goPreviousStep,\r\n        form: form as UseFormReturn<T>,\r\n        getFieldStatesBySteps,\r\n        getPreviousStep,\r\n        getNextStep,\r\n        stepIndex,\r\n        orientation: orientationMutable.orientation,\r\n        shiftOrientation,\r\n        getListenerObserver,\r\n      }}\r\n    >\r\n      {children}\r\n    </StepperContext.Provider>\r\n  );\r\n};\r\n\r\n/**\r\n * ### Stepper Context Hook\r\n *\r\n * Hook to use the stepper context in a functional component of stepper components\r\n *\r\n * @returns StepperContextProps\r\n *\r\n * ---\r\n *\r\n * Must be used within a StepperProvider\r\n *\r\n * ---\r\n *\r\n * For more information, see the {@link StepperContextProps} interface\r\n */\r\nexport const useStepper = <T extends FieldValues>() => {\r\n  const context = React.useContext(\r\n    StepperContext as React.Context<StepperContextProps<T> | undefined>,\r\n  );\r\n  if (!context) {\r\n    throw new Error('useStepper must be used within a StepperProvider');\r\n  }\r\n  return context;\r\n};\r\n",
  "/ReactFormMaker/formElements/Stepper/StepperForm.componenent.tsx": "import React from 'react';\r\nimport { FieldValues, UseFormReturn } from 'react-hook-form';\r\nimport { StepperProvider } from './StepperContext';\r\nimport { StepperContent } from './SteppersElements/StepperContent';\r\nimport FooterStepperReactHookForm from './SteppersElements/FooterSteppers.component';\r\nimport {\r\n  CompositeField,\r\n  ReactFormMakerStep,\r\n} from '../../interfaces/FieldInterfaces';\r\nimport { Stepper } from './SteppersElements/Stepper.component';\r\nimport NavigationStepper from './SteppersElements/HeaderStepper/HeaderStepper.componenent';\r\nimport { useStepperItemsMap } from './SteppersElements/useStepperItemMap.hook';\r\n\r\ninterface StepperFormProps<T extends FieldValues> {\r\n  form: UseFormReturn<T>;\r\n  formfields: CompositeField[];\r\n  zObject: any;\r\n  orientation: 'horizontal' | 'vertical';\r\n  formFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[];\r\n}\r\n\r\n/**\r\n * ### StepperForm Component\r\n *\r\n * The StepperForm component is the complete component that manages the forms generated by React Form Maker under a Stepper distribution interface.\r\n *\r\n * ---\r\n *\r\n * #### Behavior\r\n *\r\n * ##### It intuitively to its own size.\r\n * To avoid overloading className configurations, ReactFormMaker's StepperForm compoenent adapts its ergonomics to the layout. In vertical mode, for example, if the space allocated to it is too small for the display to be adapted to the user experience. The component will naturally choose a more suitable format.\r\n *\r\n * ##### Advanced management of the form.\r\n *\r\n * The StepperForm is managed by the `ReactFormMakerStep` interface. This interface includes functions handlers that allow you to interact with the various states of the form throughout its lifecycle. So you can influence and control the form at any time.\r\n *\r\n * For more information, see the {@link ReactFormMakerStep} interface.\r\n *\r\n * ---\r\n * @param\r\n * @returns\r\n */\r\nconst StepperForm = <T extends FieldValues>({\r\n  form,\r\n  formfields,\r\n  zObject,\r\n  orientation,\r\n  formFieldsMap: FormFieldsMap,\r\n}: StepperFormProps<T>) => {\r\n  const { StepperItemsMap } = useStepperItemsMap(FormFieldsMap);\r\n  return (\r\n    <StepperProvider<T>\r\n      form={form}\r\n      formfields={formfields}\r\n      zObject={zObject}\r\n      orientation={orientation}\r\n    >\r\n      <Stepper<T>>\r\n        <NavigationStepper />\r\n        <div className=\"flex flex-col min-w-0 flex-auto\">\r\n          <StepperContent className=\"flex flex-row min-h-[400px]\">\r\n            {StepperItemsMap(formfields)}\r\n          </StepperContent>\r\n          <FooterStepperReactHookForm />\r\n        </div>\r\n      </Stepper>\r\n    </StepperProvider>\r\n  );\r\n};\r\n\r\nexport default StepperForm;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/FooterSteppers.component.tsx": "import { Button } from '@/components/ui/button';\r\nimport React from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { ButtonProps } from 'react-day-picker';\r\nimport { useStepper } from '../StepperContext';\r\n\r\ninterface FooterStepperReactHookFormProps extends Omit<ButtonProps, 'variant'> {\r\n  className?: string;\r\n  variant?:\r\n    | 'outline'\r\n    | 'ghost'\r\n    | 'default'\r\n    | 'link'\r\n    | 'destructive'\r\n    | 'secondary'\r\n    | null\r\n    | undefined;\r\n}\r\n\r\n/**\r\n * ### FooterStepperReactHookForm Component\r\n *\r\n * The footer of the stepper is a component that allows you to navigate between the steps of the stepper.\r\n *\r\n * The footer is composed of two buttons:\r\n *  - The first button allows you to go back to the previous step.\r\n *  - The second button allows you to go to the next step.\r\n *\r\n * The footer is displayed at the bottom of the stepper.\r\n *\r\n * #### Behavior\r\n *\r\n *  - If the current step is the first step, the previous button is disabled.\r\n *  - If the previous step is disabled, the previous button is disabled.\r\n *  - If Steps is not valid, the next button is disabled.\r\n *  - If the current step is the last step, the next button is replaced by a submit button.\r\n */\r\nconst FooterStepperReactHookForm = React.forwardRef<\r\n  HTMLButtonElement,\r\n  FooterStepperReactHookFormProps\r\n>(({ className = '', variant = 'default' }, ref) => {\r\n  const {\r\n    getFieldStatesBySteps,\r\n    goNextStep,\r\n    goPreviousStep,\r\n    getCurrentStep,\r\n    getNbSteps,\r\n    getPreviousStep,\r\n    getListenerObserver,\r\n  } = useStepper();\r\n\r\n  const step = getCurrentStep();\r\n\r\n  function isLastStep() {\r\n    return getCurrentStep().stepIndex === getNbSteps() - 1;\r\n  }\r\n\r\n  function hasPreviousButton() {\r\n    const prevStep = getPreviousStep();\r\n    if (getCurrentStep().stepIndex === 0) {\r\n      return false;\r\n    }\r\n    if (prevStep?.disabledBefore && prevStep.isDone) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function formIsLoading(): boolean {\r\n    return getListenerObserver(getCurrentStep().stepIndex) === 'loading';\r\n  }\r\n\r\n  return (\r\n    <footer\r\n      ref={ref}\r\n      className={cn(\r\n        'flex flex-col-reverse align-center sm:flex-row sm:justify-between transition-all duration-300',\r\n        step.footerClassName,\r\n      )}\r\n    >\r\n      {hasPreviousButton() ? (\r\n        <Button\r\n          className=\"w-full sm:w-auto mt-2\"\r\n          onClick={goPreviousStep}\r\n          type=\"button\"\r\n          variant=\"secondary\"\r\n          disabled={formIsLoading()}\r\n        >\r\n          Previous\r\n        </Button>\r\n      ) : (\r\n        <div />\r\n      )}\r\n      {isLastStep() ? (\r\n        <Button\r\n          className=\"w-full sm:w-auto mt-2\"\r\n          type=\"submit\"\r\n          disabled={!getFieldStatesBySteps().isValidStep || formIsLoading()}\r\n        >\r\n          {step.buttonNextContent ? step.buttonNextContent : 'Previous'}\r\n        </Button>\r\n      ) : (\r\n        <Button\r\n          className=\"w-full sm:w-auto mt-2\"\r\n          onClick={goNextStep}\r\n          type=\"button\"\r\n          disabled={!getFieldStatesBySteps().isValidStep || formIsLoading()}\r\n          variant={variant}\r\n        >\r\n          {step.buttonNextContent ? step.buttonNextContent : 'Next'}\r\n        </Button>\r\n      )}\r\n      {step?.additionalButtons}\r\n    </footer>\r\n  );\r\n});\r\n\r\nFooterStepperReactHookForm.displayName = 'FooterStepperReactHookForm';\r\n\r\nexport default FooterStepperReactHookForm;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.componenent.tsx": "import React from 'react';\r\nimport HeaderStepperItem from './HeaderStepperItem/HeaderStepperItem.component';\r\nimport { useHeaderStepper } from './HeaderStepper.hook';\r\nimport HeaderStepperStyle from './HeaderStepper.style';\r\n\r\n/**\r\n * ### NavigationStepper Component\r\n *\r\n * The navigation bar varies according to the oriantation defined in the form.\r\n *\r\n * The navigation has been designed to be both perfectly responsive to the space allocated to it on the screen.\r\n *\r\n * #### Behavior\r\n *\r\n * Breakpoints are defined to adapt the size of the navigation bar to the space available on the screen.\r\n *\r\n * - if the space width can't contain name of the steps, the name will be hidden.\r\n * - If the space is less than 768px, the navigation bar will be horizontal.\r\n * - If the space is greater than 768px, the orientation will be respected.\r\n */\r\nfunction NavigationStepper() {\r\n  const { navRef, stepElements, steps, orientation, size } = useHeaderStepper();\r\n\r\n  const styleProps = {\r\n    orientation,\r\n    size,\r\n    stepsLength: steps.length,\r\n  };\r\n\r\n  const Style = new HeaderStepperStyle(styleProps);\r\n  return (\r\n    <nav ref={navRef} className={Style.navClass} style={Style.navStyle}>\r\n      {steps.map((step, index) => {\r\n        return (\r\n          <HeaderStepperItem\r\n            step={step}\r\n            index={index}\r\n            size={size}\r\n            ref={(el) => {\r\n              stepElements.current[index] = el;\r\n            }}\r\n          />\r\n        );\r\n      })}\r\n    </nav>\r\n  );\r\n}\r\n\r\nexport default NavigationStepper;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.hook.tsx": "import { useRef, useState } from 'react';\r\nimport { useStepper } from '../../StepperContext';\r\nimport useResizeObserver from '@react-hook/resize-observer';\r\nimport { StepElement } from '../StepperContext.interface';\r\n\r\ninterface HeaderStepperReturn {\r\n  /**\r\n   * Reference to the stepper navigation element\r\n   * @type {React.RefObject<HTMLDivElement>}\r\n   * @default null\r\n   */\r\n  navRef: React.RefObject<HTMLDivElement>;\r\n  /**\r\n   * Reference to the steps elements in the stepper navigation\r\n   * Used to calculate the height of the stepper navigation in vertical orientation\r\n   * and determine the height of the stepper navigation in horizontal orientation\r\n   * @type {React.MutableRefObject<(HTMLDivElement | null)[]>}\r\n   * @default []\r\n   */\r\n  stepElements: React.MutableRefObject<(HTMLDivElement | null)[]>;\r\n  /**\r\n   * Array of step elements\r\n   * @type {StepElement[]}\r\n   */\r\n  steps: StepElement[];\r\n  /**\r\n   * Orientation of the stepper defined in the StepperContext and passed to the HeaderStepper\r\n   * @type {string}\r\n   */\r\n  orientation: string;\r\n  /**\r\n   * Size of the stepper navigation\r\n   * Observed by the ResizeObserver to calculate the height and width of the stepper navigation\r\n   * @type {SizeElement}\r\n   */\r\n  size: SizeElement;\r\n}\r\n\r\nexport interface SizeElement {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * Hook to manage the stepper navigation element\r\n * @returns {HeaderStepperReturn}\r\n */\r\nexport function useHeaderStepper(): HeaderStepperReturn {\r\n  const navRef = useRef<HTMLDivElement>(null);\r\n  const stepElements = useRef<(HTMLDivElement | null)[]>([]);\r\n  const { steps, orientation } = useStepper();\r\n  const [size, setSize] = useState<SizeElement>({\r\n    width: 0,\r\n    height: 0,\r\n  });\r\n\r\n  const calculateNavHeight = () => {\r\n    if (orientation === 'vertical') {\r\n      const totalHeight: number = stepElements.current.reduce((sum, el) => {\r\n        return sum + (el?.offsetHeight || 0) + 24;\r\n      }, 0);\r\n      return Math.floor(totalHeight);\r\n    } else {\r\n      const heights = stepElements.current\r\n        .filter((el) => el !== null)\r\n        .map((el) => el!.offsetHeight || 150);\r\n\r\n      if (heights.length === 0) {\r\n        return 150;\r\n      }\r\n\r\n      const maxHeight: number = Math.max(...heights);\r\n      return Math.floor(maxHeight);\r\n    }\r\n  };\r\n\r\n  function calculateNavWidth(entry: ResizeObserverEntry) {\r\n    if (orientation === 'horizontal') {\r\n      return entry.contentRect.width;\r\n    } else {\r\n      return 270;\r\n    }\r\n  }\r\n\r\n  if (typeof window !== 'undefined') {\r\n    useResizeObserver(navRef, (entry) => {\r\n      setSize({\r\n        width: calculateNavWidth(entry),\r\n        height: calculateNavHeight(),\r\n      });\r\n    });\r\n  }\r\n\r\n  return {\r\n    navRef,\r\n    stepElements,\r\n    steps,\r\n    orientation,\r\n    size,\r\n  };\r\n}\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.style.ts": "import { cn } from '@/lib/utils';\r\n\r\ninterface StyleProps {\r\n  orientation: string;\r\n  size: { width: number; height: number };\r\n  stepsLength: number;\r\n}\r\n\r\n/**\r\n * Class to manage the style of the stepper navigation\r\n * @class HeaderStepperStyle\r\n * @param {StyleProps} props - Props to manage the style of the stepper navigation\r\n * @property {string} navClass - Class to apply to the stepper navigation could be horizontal or vertical\r\n * @property {React.CSSProperties} navStyle - Style to apply to the stepper navigation could be width whene orientation is horizontal or height when orientation is vertical\r\n */\r\nclass HeaderStepperStyle {\r\n  navClass: string;\r\n  navStyle: React.CSSProperties;\r\n\r\n  constructor(props: StyleProps) {\r\n    this.navClass = cn({\r\n      'flex flex-row items-center justify-between min-h-full sm:px-8 md:px-12 lg:px-24 xl:px-32 mb-4 sm:mb-[72px]':\r\n        props.orientation === 'horizontal',\r\n      'flex flex-col gap-2 min-w-[270px] h-full max-h-full overflow-y-auto justify-start scrollbar-gray':\r\n        props.orientation !== 'horizontal',\r\n    });\r\n\r\n    this.navStyle =\r\n      props.orientation === 'horizontal'\r\n        ? {\r\n            marginBottom:\r\n              props.size.width / props.stepsLength - 12 > 80 ? '72px' : '12px',\r\n          }\r\n        : { width: props.size.width };\r\n  }\r\n}\r\n\r\nexport default HeaderStepperStyle;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.component.tsx": "// HeaderStepperItem.component.tsx\r\nimport React, { forwardRef } from 'react';\r\nimport { useHeaderStepperItem } from './useHeaderStepperItem.hook';\r\nimport StepInfoDisplay from './StepInfoDisplay.component';\r\nimport {\r\n  HeaderStepperItemInterface,\r\n  HeaderStepperItemProps,\r\n} from './HeaderStepperItem.interface';\r\n\r\n/**\r\n * ### HeaderStepperItem Component\r\n *\r\n * The items represent the control points of the breadcrumb trail generated by navigation from the configuration passed in the form and the various ReactFormMakerSteps that make it up.\r\n *\r\n *\r\n *\r\n * ---\r\n *\r\n * #### Behavior\r\n *\r\n * ##### Horizontal Orientation\r\n *\r\n * - The items are clickable and allow the user to navigate to the corresponding step.\r\n * - The items display the name of the step if the space available on the screen allows it.\r\n * - Legend is a tooltip that displays the description of the step.\r\n * - The space available on the screen is calculated based on the width of the nav and the number of steps. Steps are hidden if the space is not enough.\r\n *\r\n * ##### Vertical Orientation\r\n *\r\n * - The legend is displayed on the right of the step name.\r\n * - The step item adaptes its height to the space available for readability of the legend.\r\n * - If the space is not enought, this item change to horizontal orientation.\r\n */\r\nconst HeaderStepperItem: HeaderStepperItemInterface = forwardRef<\r\n  HTMLDivElement,\r\n  HeaderStepperItemProps\r\n>((props, ref) => {\r\n  const {\r\n    stepName,\r\n    legend,\r\n    isLastStep,\r\n    localRef,\r\n    styles,\r\n    maxWidth,\r\n    icon,\r\n    ajustHeightProgressBar,\r\n    positionTooltip,\r\n    infoShouldBeDisplayed,\r\n    goToStep,\r\n    orientation,\r\n    formIsLoading,\r\n  } = useHeaderStepperItem({ ...props, ref });\r\n\r\n  const { index } = props;\r\n\r\n  return (\r\n    <React.Fragment key={index}>\r\n      <div\r\n        className={`${styles.stepDirectionContainerClass} ${styles.cursorClass}`}\r\n        onClick={(e) => {\r\n          if (formIsLoading()) return;\r\n          goToStep(index);\r\n        }}\r\n      >\r\n        {icon()}\r\n        {infoShouldBeDisplayed(maxWidth) && (\r\n          <div\r\n            className={styles.positionLabelClass}\r\n            style={{\r\n              width: orientation === 'horizontal' ? `${maxWidth}px` : '80%',\r\n            }}\r\n          >\r\n            <StepInfoDisplay\r\n              key={index}\r\n              stepName={stepName}\r\n              legend={legend}\r\n              orientation={orientation}\r\n              maxWidth={maxWidth}\r\n              opacityClass={styles.opacityClass}\r\n              positionTooltip={positionTooltip}\r\n              ref={localRef}\r\n            />\r\n          </div>\r\n        )}\r\n      </div>\r\n      {!isLastStep() && (\r\n        <div\r\n          className={`${styles.progressBarPositionClass} ${styles.barProgressClass}`}\r\n          style={ajustHeightProgressBar()}\r\n        ></div>\r\n      )}\r\n    </React.Fragment>\r\n  );\r\n});\r\n\r\nHeaderStepperItem.displayName = 'HeaderStepperItem';\r\n\r\nexport default HeaderStepperItem;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.interface.tsx": "import { StepElement } from '../../StepperContext.interface';\r\nimport { SizeElement } from '../HeaderStepper.hook';\r\nimport { ReactFormMakerStep } from '@/components/ReactFormMaker/interfaces/FieldInterfaces';\r\n\r\n/**\r\n * **Properties for the HeaderStepperItem component**\r\n * @interface HeaderStepperItemProps\r\n *\r\n * ---\r\n *\r\n * @param {StepElement} step - The step element. See {@link StepElement}\r\n * @param {SizeElement} size - The size of the step element. See {@link SizeElement}\r\n * @param {number} index - The index of the step element.\r\n */\r\nexport type HeaderStepperItemProps = {\r\n  step: StepElement;\r\n  size: SizeElement;\r\n  index: number;\r\n};\r\n\r\n/**\r\n * ### HeaderStepperItem Component\r\n *\r\n * This component represents an item in the header stepper.\r\n * It uses the `useHeaderStepperItem` hook to manage its state and behavior.\r\n *\r\n * The items represent the control points of the breadcrumb trail generated by navigation from the configuration passed in the form and the various ReactFormMakerSteps that make it up.\r\n *\r\n * See {@link ReactFormMakerStep}\r\n *\r\n * ---\r\n *\r\n * @param {HeaderStepperItemProps} props - The properties for the component.\r\n * @param {StepElement} props.step - The step element.\r\n * @param {SizeElement} props.size - The size of the step element.\r\n * @param {number} props.index - The index of the step element.\r\n */\r\nexport type HeaderStepperItemInterface = React.ForwardRefExoticComponent<\r\n  HeaderStepperItemProps & React.RefAttributes<HTMLDivElement>\r\n> & {\r\n  displayName?: string;\r\n};\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.style.ts": "// HeaderStepperItem.style.ts\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface StyleProps {\r\n  isdisabled: boolean;\r\n  isCurrent: boolean;\r\n  isDone: boolean;\r\n  currentStepIndex: number;\r\n  stepIndex: number;\r\n  orientation: string;\r\n}\r\n\r\nclass HeaderStepperItemStyle {\r\n  opacityClass: string;\r\n  cursorClass: string;\r\n  barProgressClass: string;\r\n  stepDirectionContainerClass: string;\r\n  positionLabelClass: string;\r\n  progressBarPositionClass: string;\r\n\r\n  constructor(props: StyleProps) {\r\n    this.opacityClass = cn(\r\n      'opacity-60', // Default opacity\r\n      {\r\n        'opacity-80': props.isDone,\r\n        'opacity-100': props.isCurrent,\r\n        'opacity-40': props.isdisabled,\r\n      },\r\n    );\r\n\r\n    this.cursorClass = cn({\r\n      'cursor-not-allowed': props.isdisabled,\r\n      'cursor-pointer': !props.isdisabled,\r\n    });\r\n\r\n    this.barProgressClass = cn({\r\n      'bg-primary': props.currentStepIndex > props.stepIndex,\r\n      'bg-gray-200': props.currentStepIndex <= props.stepIndex,\r\n    });\r\n\r\n    this.stepDirectionContainerClass = cn({\r\n      'flex flex-col items-center justify-center mx-2 relative w-8 h-8 z-10':\r\n        props.orientation === 'horizontal',\r\n      'flex flex-row relative': props.orientation !== 'horizontal',\r\n    });\r\n\r\n    this.positionLabelClass = cn({\r\n      'w-1 h-8 text-center absolute top-0 transform translate-y-[32px] flex flex-col h-24':\r\n        props.orientation === 'horizontal',\r\n      'text-start absolute top-0 transform translate-x-[32px] flex flex-col h-24':\r\n        props.orientation !== 'horizontal',\r\n    });\r\n\r\n    this.progressBarPositionClass = cn({\r\n      'flex-1 h-0.5': props.orientation === 'horizontal',\r\n      'flex-1 w-0.5 ml-3': props.orientation !== 'horizontal',\r\n    });\r\n  }\r\n}\r\n\r\nexport default HeaderStepperItemStyle;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/StepInfoDisplay.component.tsx": "// StepInfoDisplay.component.tsx\r\nimport React, { forwardRef } from 'react';\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipProvider,\r\n  TooltipTrigger,\r\n} from '@radix-ui/react-tooltip';\r\nimport { Large, Muted } from '@/components/ui/Typography';\r\n\r\ntype StepInfoDisplayProps = {\r\n  stepName: string;\r\n  legend: string | undefined;\r\n  orientation: string;\r\n  maxWidth: number;\r\n  opacityClass: string;\r\n  positionTooltip: () => 'center' | 'start' | 'end';\r\n};\r\n\r\nconst StepInfoDisplay = forwardRef<HTMLDivElement, StepInfoDisplayProps>(\r\n  (\r\n    { stepName, legend, orientation, maxWidth, opacityClass, positionTooltip },\r\n    ref,\r\n  ) => {\r\n    return (\r\n      <>\r\n        {orientation === 'horizontal' ? (\r\n          <TooltipProvider delayDuration={300}>\r\n            <Tooltip>\r\n              <TooltipTrigger disabled>\r\n                <span className={`max-h-[72px] line-clamp-3 ${opacityClass}`}>\r\n                  {stepName}\r\n                </span>\r\n              </TooltipTrigger>\r\n              <TooltipContent\r\n                side=\"bottom\"\r\n                align={positionTooltip()}\r\n                className=\"z-99 bg-[#000000FE] p-2 rounded-lg\"\r\n              >\r\n                <Muted className=\"max-w-[200px] block \">{legend}</Muted>\r\n              </TooltipContent>\r\n            </Tooltip>\r\n          </TooltipProvider>\r\n        ) : (\r\n          <div className={opacityClass} ref={ref}>\r\n            <Large className=\"text-md\">{stepName}</Large>\r\n            <Muted>{legend}</Muted>\r\n          </div>\r\n        )}\r\n      </>\r\n    );\r\n  },\r\n);\r\n\r\nStepInfoDisplay.displayName = 'StepInfoDisplay';\r\n\r\nexport default StepInfoDisplay;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/useHeaderStepperItem.hook.tsx": "// useHeaderStepperItem.hook.ts\r\nimport { useCallback, useRef, useImperativeHandle, createElement } from 'react';\r\nimport HeaderStepperItemStyle from './HeaderStepperItem.style';\r\nimport { useStepper } from '@/components/ReactFormMaker/formElements/Stepper/StepperContext';\r\nimport { Circle, CircleCheck, CircleDashed, CircleDotIcon } from 'lucide-react';\r\nimport { SizeElement } from '../HeaderStepper.hook';\r\nimport { StepElement } from '../../StepperContext.interface';\r\n\r\ninterface UseHeaderStepperItemProps {\r\n  step: StepElement;\r\n  index: number;\r\n  size: SizeElement;\r\n  ref: React.Ref<HTMLDivElement>;\r\n}\r\n\r\nexport function useHeaderStepperItem({\r\n  step,\r\n  size,\r\n  index,\r\n  ref,\r\n}: UseHeaderStepperItemProps) {\r\n  const { stepName, stepIndex, legend, isNext, isDone, isdisabled, isCurrent } =\r\n    step;\r\n\r\n  const { getCurrentStep, steps, goToStep, orientation, getListenerObserver } =\r\n    useStepper();\r\n\r\n  const localRef = useRef<HTMLDivElement | null>(null);\r\n  useImperativeHandle(ref, () => localRef.current as HTMLDivElement);\r\n\r\n  const styleProps = {\r\n    isdisabled,\r\n    isCurrent,\r\n    isDone,\r\n    currentStepIndex: getCurrentStep().stepIndex,\r\n    stepIndex,\r\n    orientation,\r\n  };\r\n\r\n  const styles = new HeaderStepperItemStyle(styleProps);\r\n\r\n  const isLastStep = useCallback(\r\n    () => stepIndex === steps.length - 1,\r\n    [stepIndex, steps.length],\r\n  );\r\n\r\n  const maxWidth =\r\n    size.width > 0 ? Math.floor(size.width / steps.length - 12) : 150;\r\n\r\n  const icon = useCallback(() => {\r\n    if (step.IconStep) {\r\n      return createElement(step.IconStep, { className: styles.opacityClass });\r\n    }\r\n    if (isCurrent) return <CircleDotIcon className={styles.opacityClass} />;\r\n    if (isDone) return <CircleCheck className={styles.opacityClass} />;\r\n    if (isdisabled) return <CircleDashed className={styles.opacityClass} />;\r\n    if (isNext) return <Circle className={styles.opacityClass} />;\r\n    return <Circle className={styles.opacityClass} />;\r\n  }, [isCurrent, isDone, isNext, isdisabled, styles.opacityClass]);\r\n\r\n  const ajustHeightProgressBar = () => {\r\n    if (orientation === 'horizontal') return { height: '1px' };\r\n    const heightBar =\r\n      localRef.current !== null\r\n        ? {\r\n            'min-height': localRef.current.offsetHeight.toString() + 'px',\r\n            'max-height': localRef.current.offsetHeight.toString() + 'px',\r\n          }\r\n        : { flex: 1 };\r\n    return heightBar;\r\n  };\r\n\r\n  const positionTooltip = (): 'start' | 'end' | 'center' => {\r\n    if (orientation === 'horizontal') {\r\n      if (stepIndex === 0) return 'start';\r\n      if (stepIndex === steps.length - 1) return 'end';\r\n      return 'center';\r\n    }\r\n    return 'start';\r\n  };\r\n\r\n  const infoShouldBeDisplayed = (maxWidth: number) => {\r\n    if (orientation === 'horizontal') return maxWidth > 80;\r\n    return true;\r\n  };\r\n\r\n  function formIsLoading(): boolean {\r\n    return getListenerObserver(getCurrentStep().stepIndex) === 'loading';\r\n  }\r\n\r\n  return {\r\n    stepName,\r\n    legend,\r\n    isLastStep,\r\n    localRef,\r\n    styles,\r\n    maxWidth,\r\n    icon,\r\n    ajustHeightProgressBar,\r\n    positionTooltip,\r\n    infoShouldBeDisplayed,\r\n    goToStep,\r\n    orientation,\r\n    formIsLoading,\r\n  };\r\n}\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/Stepper.component.tsx": "import React, { ReactNode, useEffect } from 'react';\r\nimport { FieldValues } from 'react-hook-form';\r\nimport useResizeObserver from '@react-hook/resize-observer';\r\nimport { cn } from '@/lib/utils';\r\nimport { useStepper } from '../StepperContext';\r\n\r\ninterface StepperProps<T extends FieldValues> {\r\n  children: ReactNode;\r\n}\r\n/**\r\n * ### Stepper Component\r\n *\r\n * The `Stepper` component is a component that allows you to display the stepper.\r\n *\r\n * ---\r\n *\r\n * #### Behavior\r\n *  > _Becarfull ! Orientation define the orientation of navigation stepper_\r\n *\r\n * - The orientation of the stepper is updated when the width of the container changes.\r\n * - The orientation of the stepper is horizontal by default.\r\n * - The orientation of the stepper is horizontal when the width of the container is less than 768px.\r\n *\r\n * ---\r\n *\r\n *\r\n * @param param0\r\n * @returns\r\n */\r\nconst Stepper = <T extends FieldValues>({\r\n  children,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement> & StepperProps<T>) => {\r\n  const { orientation: stepperOrientation, shiftOrientation } = useStepper();\r\n  const wrapperRef = React.useRef<HTMLDivElement>(null);\r\n  const [cnOrientation, setCnOrientation] =\r\n    React.useState<string>(' flex flex-row');\r\n\r\n  useResizeObserver(wrapperRef, (entry) => {\r\n    shiftOrientation(entry.contentRect.width);\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (stepperOrientation === 'horizontal') {\r\n      setCnOrientation(' flex flex-col gap-4');\r\n    } else {\r\n      setCnOrientation(' flex flex-row');\r\n    }\r\n  }, [stepperOrientation]);\r\n\r\n  return (\r\n    <div\r\n      ref={wrapperRef}\r\n      className={cn('relative ', props.className) + cnOrientation}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport { Stepper };\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperContent.tsx": "import { cn } from '@/lib/utils';\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { useStepper } from '../StepperContext';\r\n\r\n/**\r\n * ### StepperContent Component\r\n *\r\n * The `StepperContent` component is a component that allows you to display the content of the stepper.\r\n * Here, the content of the stepper is displayed in a horizontal way. A slider is used to display the content of the stepper.\r\n *\r\n * ---\r\n *\r\n * #### Behavior\r\n *\r\n * - Position of the slider is updated when the step index changes.\r\n * - The slider is translated by the percentage of the step index.\r\n * - First Div is the container of the slider in overflow hidden (don't show the content outside the container).\r\n */\r\nconst StepperContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.HTMLAttributes<HTMLDivElement>\r\n>(({ className, ...props }, ref) => {\r\n  const sliderRef = useRef<HTMLDivElement>(null);\r\n  const { stepIndex, getNbSteps } = useStepper();\r\n\r\n  useEffect(() => {\r\n    const newPos = stepIndex * 100;\r\n    sliderRef.current?.style.setProperty(\r\n      'transform',\r\n      `translateX(-${newPos}%)`,\r\n    );\r\n  }, [stepIndex]);\r\n\r\n  return (\r\n    <div ref={ref} className=\"overflow-hidden flex-auto\">\r\n      <div\r\n        ref={sliderRef}\r\n        className={cn(\r\n          'flex',\r\n          `w-[${getNbSteps() * 100}%]`,\r\n          'transition-transform',\r\n          'duration-300',\r\n          'transform',\r\n          'ease-in-out',\r\n          className,\r\n        )}\r\n        {...props}\r\n      />\r\n    </div>\r\n  );\r\n});\r\nStepperContent.displayName = 'StepperContent';\r\n\r\nexport { StepperContent };\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperContext.interface.tsx": "import { FieldError, FieldValues, UseFormReturn } from 'react-hook-form';\r\nimport { z } from 'zod';\r\nimport { ReactFormMakerStep } from '../../../interfaces/FieldInterfaces';\r\n\r\n/**\r\n * **Define the structure of a field state in the stepper context**\r\n *\r\n * _Cette interface résume l'état d'un champs selon le formContext de React Hook Form_\r\n */\r\nexport interface FieldState<T> {\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the field is valid**\r\n   *\r\n   * _The valid state is a boolean that indicates if React Hook Form considers the field to be valid.\r\n   * More explicitly, it is the result of the validation of the field by the zod schema._\r\n   */\r\n  invalid: boolean;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the field is dirty**\r\n   * _The dirty state is a boolean that indicates if the field has been modified by the user._\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the field is touched**\r\n   * _The touched state is a boolean that indicates if the field has been touched by the user._\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the field is validating**\r\n   *\r\n   * _The validating state is a boolean that indicates if the field is currently being validated by the zod schema._\r\n   */\r\n  isValidating: boolean;\r\n\r\n  /**\r\n   * @type {FieldError | undefined}\r\n   *\r\n   * **Define the error of the field**\r\n   *\r\n   * _The error state is an object that contains the error message if the field is invalid._\r\n   * _If the field is valid, the error state is undefined._\r\n   * _The error message is the message returned by the zod schema if the field is invalid._\r\n   *\r\n   * @see {@link FieldError}\r\n   */\r\n  error?: FieldError | undefined;\r\n}\r\n\r\n/**\r\n * **Define the structure of a field state detail in the stepper context for each fields**\r\n *\r\n * _This interface summarizes the state of a field according to the formContext of React Hook Form_\r\n */\r\nexport interface FieldStatesDetail<T> {\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Defines whether the field is considered valid as a whole.**\r\n   *\r\n   * _The fluctuation of this value is arbitrary and depends on whether the original field has optional or nullable attributes._\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * @type {any}\r\n   *\r\n   * **Value of the field**\r\n   *\r\n   * _The value of the field is the value entered by the user in the field._\r\n   * _This value can be the default value applied by the program._\r\n   */\r\n  value: any;\r\n\r\n  /**\r\n   * @type {FieldState<T>}\r\n   *\r\n   * **State of the field**\r\n   *\r\n   * _Allows you to obtain more details about the reason for the isValid state_\r\n   *\r\n   * @see {@link FieldState}\r\n   */\r\n  FieldState: FieldState<T>;\r\n\r\n  /**\r\n   * @type {z.ZodType<T>}\r\n   *\r\n   * **Zod schema of the field**\r\n   *\r\n   * _The zod schema of the field is the schema used to validate the field._\r\n   *\r\n   * @see {@link z.ZodType}\r\n   */\r\n  zField: z.ZodType<T>;\r\n}\r\n\r\n/**\r\n * **Define the structure of a step form state in the stepper context**\r\n *\r\n * This interface brings together all the status of the fields that make it up. It provides a general overview of form status, as well as precise details on the status of each form.\r\n */\r\nexport interface StepFormState<T> {\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the step is valid**\r\n   *\r\n   * _The isValidStep state defines whether the step is considered valid as a whole._\r\n   *\r\n   * _This state is a general synthesis of all the fields that make it up. It is true if all fields are considered valid._\r\n   *\r\n   * ---\r\n   *\r\n   * > **Warning**: this state does not ensure that nullable or optional fields are in a dirty state.\r\n   */\r\n  isValidStep: boolean;\r\n\r\n  /**\r\n   * @type {FieldStatesDetail<T>[]}\r\n   *\r\n   * **Details of the fields of the step**\r\n   *\r\n   * _The fieldStatesDetails state is a list of all the fields that make up the step, with their respective states._\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link FieldStatesDetail}\r\n   */\r\n  fieldStatesDetails: { [key: string]: FieldStatesDetail<T> };\r\n}\r\n\r\n/**\r\n * **Define the structure of a step element in the stepper context**\r\n *\r\n * _Step Element is a representation of a step, it contains all the information needed to manage the step and its fields_\r\n * _Here states could be managed to know if the step is done, current, next, disabled, subjected to strict effect or subjected to disabled effect_\r\n *\r\n * ---\r\n *\r\n * @param {number} stepIndex - The index of the step in the stepper\r\n * @param {boolean} isDone - The state of the step, if it is done or not\r\n * @param {boolean} isCurrent - The state of the step, if it is the current step or not\r\n * @param {boolean} isNext - The state of the step, if it is the next step or not\r\n * @param {boolean} isdisabled - The state of the step, if it is disabled or not\r\n * @param {string[]} subjectedStrictSteps - list of other steps that block this step due to their strict effect\r\n * @param {string[]} subjectedDisabledBeforeSteps - list of other steps that block this step due to their constraint effect after their respective submission: “disabledBefore state”.\r\n *\r\n * ---\r\n *\r\n * @extends {ReactFormMakerStep}\r\n * @see {@link ReactFormMakerStep}\r\n */\r\nexport interface StepElement extends ReactFormMakerStep {\r\n  /**\r\n   * @type {number}\r\n   *\r\n   * **Indexation of the step in the stepper**\r\n   *\r\n   * _Index is incremented by 1 for each step_\r\n   *\r\n   * _Index starts at 0_\r\n   *\r\n   */\r\n  stepIndex: number;\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the step is done**\r\n   * The isDone state defines whether the part of the form it contains, as well as each step field, has been filled in and defined as correct.\r\n   *\r\n   * _The state can change when one of the fields has been changed and returns an error, or when the next step is taken (a partial submission is then executed)._\r\n   */\r\n  isDone: boolean;\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the step is the current step**\r\n   *\r\n   * The isCurrent state defines whether the step is the one currently displayed in the stepper.\r\n   *\r\n   * _This field is used to follow the step displayed on the screen when the carousel is slid._\r\n   */\r\n  isCurrent: boolean;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the step is the next step**\r\n   *\r\n   * The isNext state defines whether the step is the next step to be displayed in the stepper.\r\n   *\r\n   * _This field is used to follow the step displayed on the screen when the carousel is slid._\r\n   */\r\n  isNext: boolean;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * **Define if the step is disabled**\r\n   *\r\n   * The isDisabled state is an overview of whether the step can be consulted by the user.\r\n   * The isDisabled state depends on its default state, but can also be forced by adjacent steps (preceding or following)\r\n   *\r\n   *_see next two properties_.\r\n   */\r\n  isdisabled: boolean;\r\n\r\n  /**\r\n   * @type {string[]}\r\n   *\r\n   * **List of other steps that block this step due to their strict effect**\r\n   *\r\n   * The subjectedStrictSteps state is a list of other steps that block this step due to their strict effect.\r\n   *\r\n   *  _If the table contains at least one value, the step is considered disabled._\r\n   */\r\n  subjectedStrictSteps: string[];\r\n\r\n  /**\r\n   * @type {string[]}\r\n   *\r\n   * **List of other steps that block this step due to their constraint effect after their respective submission: “disabledBefore state”**\r\n   *\r\n   * The subjectedDisabledBeforeSteps state is a list of other steps that block this step due to their constraint effect after their respective submission: “disabledBefore state”.\r\n   *\r\n   * _If the table contains at least one value, the step is considered disabled._\r\n   */\r\n  subjectedDisabledBeforeSteps: string[];\r\n}\r\n\r\n/**\r\n * **Stepper Context to manage the steps of a form in a stepper components**\r\n *\r\n * _The stepper context is a context that allows you to manage the steps of a form in a stepper._\r\n *\r\n * ---\r\n *\r\n * @param {StepElement[]} steps - List of steps\r\n * @param {() => number} getNbSteps - Get the number of steps in the stepper\r\n * @param {() => StepElement} getCurrentStep - Get the current step in the stepper\r\n * @param {(stepIndex: number) => void} goToStep - Go to a specific step in the stepper\r\n * @param {() => void} goNextStep - Go to the next step in the stepper\r\n * @param {() => void} goPreviousStep - Go to the previous step in the stepper\r\n * @param {UseFormReturn<T>} form - Access the form context of React Hook Form\r\n * @param {() => StepFormState<T>} getFieldStatesBySteps - Get the state of the fields of the form according to the steps\r\n * @param {() => StepElement | undefined} getPreviousStep - Get the previous step in the stepper\r\n * @param {() => StepElement | undefined} getNextStep - Get the next step in the stepper\r\n * @param {number} stepIndex - Index of the current step in the stepper\r\n * @param {'vertical' | 'horizontal'} orientation - orientation of the stepper\r\n * @param {(width: number) => void} shiftOrientation - Shift the orientation of the stepper\r\n *\r\n */\r\nexport interface StepperContextProps<T extends FieldValues> {\r\n  /**\r\n   * @type {StepElement[]}\r\n   *\r\n   * **List of steps**\r\n   *\r\n   * _The steps state is a list of all the steps that make up the form._\r\n   *\r\n   * For more information :  {@link StepElement}\r\n   */\r\n  steps: StepElement[];\r\n\r\n  /**\r\n   * **Get the number of steps in the stepper**\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getNbSteps: () => number;\r\n  /**\r\n   * ** Get the current step in the stepper**\r\n   * @returns {StepElement}\r\n   *\r\n   * For more informations see : {@link StepElement}\r\n   */\r\n  getCurrentStep: () => StepElement;\r\n\r\n  /**\r\n   * **Go to a specific step in the stepper**\r\n   *\r\n   * _handle the transition between steps_\r\n   *\r\n   * @param {number} stepIndex - The index of the step in the stepper\r\n   *\r\n   * @returns {void}\r\n   */\r\n  goToStep: (stepIndex: number) => void;\r\n\r\n  /**\r\n   * **Go to the next step in the stepper**\r\n   *\r\n   * _handle the transition between steps by incrementing the step index_\r\n   *\r\n   * @returns {void}\r\n   */\r\n  goNextStep: () => void;\r\n\r\n  /**\r\n   * **Go to the previous step in the stepper**\r\n   *\r\n   * _handle the transition between steps by decrementing the step index_\r\n   *\r\n   * @returns {void}\r\n   */\r\n  goPreviousStep: () => void;\r\n\r\n  /**\r\n   * **Access the form context of React Hook Form**\r\n   *\r\n   * _ Used to manage the form and its fields_\r\n   *\r\n   * @type {UseFormReturn<T>}\r\n   *\r\n   * For more informations see : {@link UseFormReturn}\r\n   */\r\n  form: UseFormReturn<T>;\r\n\r\n  /**\r\n   * **Get the state of the fields of the form according to the steps**\r\n   *\r\n   * _Used to manage the form and its fields whene the step form has presubmitted_\r\n   *\r\n   * @returns {StepFormState<T>}\r\n   * For more informations see : {@link StepFormState}\r\n   */\r\n  getFieldStatesBySteps: (stepIndex?: number) => StepFormState<T>;\r\n\r\n  /**\r\n   * **Get the previous step in the stepper**\r\n   *\r\n   * _Is used for control management between different step states if there are causal links between_\r\n   *\r\n   * @returns {StepElement | undefined}\r\n   * For more informations see : {@link StepElement}\r\n   */\r\n  getPreviousStep: () => StepElement | undefined;\r\n\r\n  /**\r\n   * **Get the next step in the stepper**\r\n   *\r\n   * _Is used for control management between different step states if there are causal links between_\r\n   * @returns {StepElement | undefined}\r\n   */\r\n  getNextStep: () => StepElement | undefined;\r\n\r\n  /**\r\n   * @type {number}\r\n   *\r\n   * **Index of the current step in the stepper**\r\n   */\r\n  stepIndex: number;\r\n\r\n  /**\r\n   * @type {'vertical' | 'horizontal'}\r\n   *\r\n   * **orientation of the stepper**\r\n   *\r\n   * _Becarful, the orientation is mutable_\r\n   *\r\n   * _The orientation state is a string that indicates the orientation of the stepper._\r\n   *\r\n   * For more informations see : {@link orientationMutable}\r\n   */\r\n  orientation: 'vertical' | 'horizontal';\r\n\r\n  /**\r\n   * **Shift the orientation of the stepper**\r\n   *\r\n   * _The orientation of the stepper is shifted according to the width of the component_\r\n   * @param width\r\n   * @returns\r\n   */\r\n  shiftOrientation: (width: number) => void;\r\n\r\n  /**\r\n   * **Get the state of the listener observer**\r\n   * _The listener observer is a state that allows you to know the status of the listener_\r\n   * @param key\r\n   * @returns\r\n   */\r\n  getListenerObserver: (\r\n    index: number,\r\n  ) => 'idle' | 'loading' | 'resolved' | 'rejected';\r\n}\r\n\r\n/**\r\n * **Define the structure of the orientation mutable**\r\n *\r\n * _This interface summarizes the orientation of the stepper and its mutability_\r\n *\r\n * ---\r\n *\r\n * @param {'vertical' | 'horizontal'} orientation - The orientation of the stepper\r\n * @param {boolean} isOriginal - The state of the orientation, if it is the original orientation or not\r\n */\r\nexport interface orientationMutable {\r\n  /**\r\n   * @type {'vertical' | 'horizontal'}\r\n   *\r\n   * Define the orientation of the stepper\r\n   */\r\n  orientation: 'vertical' | 'horizontal';\r\n\r\n  /**\r\n   * @type {boolean}\r\n   *\r\n   * Define if the orientation is the original orientation\r\n   *\r\n   * _If the orientation has been mutated by program, the isOriginal state is false_\r\n   */\r\n  isOriginal: boolean;\r\n}\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperItems.tsx": "import { cn } from '@/lib/utils';\r\nimport React from 'react';\r\nimport { useStepper } from '../StepperContext';\r\nimport { Loader2 } from 'lucide-react';\r\n\r\nconst StepperItem = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.HTMLAttributes<HTMLDivElement>\r\n>(({ className, ...props }, ref) => {\r\n  const { getListenerObserver, stepIndex } = useStepper();\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      role=\"group\"\r\n      aria-roledescription=\"slide\"\r\n      className={cn(\r\n        'min-w-0 shrink-0 grow-0 basis-full px-4 relative',\r\n        className,\r\n      )}\r\n      {...props}\r\n    >\r\n      {getListenerObserver(stepIndex) === 'loading' && (\r\n        <div className=\"flex justify-center items-center w-full backdrop-brightness-[110%] h-full absolute z-10 backdrop-blur-[2px]  bg-[#ffffff66] transition-all duration-300\">\r\n          <Loader2 size={32} className=\"animate-spin\" />\r\n        </div>\r\n      )}\r\n      {props.children}\r\n    </div>\r\n  );\r\n});\r\nStepperItem.displayName = 'StepperItem';\r\n\r\nexport { StepperItem };\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/stepReducer.ts": "import { CompositeField } from '@/components/ReactFormMaker/interfaces/FieldInterfaces';\r\nimport { isStepReactFormMaker } from '@/components/ReactFormMaker/utils/typeGuards/compositeField.TypeGuards';\r\nimport { StepElement } from './StepperContext.interface';\r\n\r\ntype TypeReducerActionNames =\r\n  | 'CHANGE_FOCUS'\r\n  | 'SET_DONE'\r\n  | 'REMOVE_DONE'\r\n  | 'SET_STRICT_DISABLED_EFFECT'\r\n  | 'SET_BETFORE_DISABLED_EFFECT';\r\n\r\ntype ActionType = {\r\n  type: TypeReducerActionNames;\r\n  currentStepIndex?: number;\r\n};\r\n\r\nexport function setStrictDisabledEffect(state: StepElement[]): StepElement[] {\r\n  const disabledAfterBy: string[] = [];\r\n\r\n  return state.map((step: StepElement) => {\r\n    const newStep = {\r\n      ...step,\r\n      subjectedStrictSteps: [...disabledAfterBy],\r\n      isdisabled:\r\n        disabledAfterBy.length > 0 ||\r\n        step.subjectedDisabledBeforeSteps.length > 0,\r\n    };\r\n    if (step.isStrict && !step.isDone) {\r\n      disabledAfterBy.push(step.stepName);\r\n    }\r\n    return newStep;\r\n  });\r\n}\r\n\r\nexport function setDisabledBeforeEffect(state: StepElement[]): StepElement[] {\r\n  const disabledBeforeBy: string[] = [];\r\n\r\n  const currentStates = state.map((step: StepElement) => {\r\n    return step;\r\n  });\r\n\r\n  const newStates = currentStates.reverse().map((step: StepElement) => {\r\n    const newStep = {\r\n      ...step,\r\n      subjectedDisabledBeforeSteps: [...disabledBeforeBy],\r\n      isdisabled:\r\n        disabledBeforeBy.length > 0 ||\r\n        step.subjectedStrictSteps.length > 0 ||\r\n        (step.disabledBefore !== undefined &&\r\n          step.disabledBefore === true &&\r\n          step.isDone),\r\n    };\r\n    if (step.disabledBefore && step.isDone) {\r\n      disabledBeforeBy.push(step.stepName);\r\n    }\r\n    return newStep;\r\n  });\r\n\r\n  return newStates.reverse();\r\n}\r\n\r\nexport function initialSteps(formfields: CompositeField[]): StepElement[] {\r\n  const currentForm: StepElement[] = formfields\r\n    .filter((field) => isStepReactFormMaker(field))\r\n    .map((step, index) => ({\r\n      ...step,\r\n      stepIndex: index,\r\n      isDone: false,\r\n      isCurrent: index === 0,\r\n      isNext: index === 1,\r\n      isdisabled: false,\r\n      subjectedStrictSteps: [],\r\n      subjectedDisabledBeforeSteps: [],\r\n    }));\r\n\r\n  const currentFormWithStrictEffect = setStrictDisabledEffect(currentForm);\r\n  return setDisabledBeforeEffect(currentFormWithStrictEffect);\r\n}\r\n\r\nconst stepReducer = (\r\n  state: StepElement[],\r\n  action: ActionType,\r\n): StepElement[] => {\r\n  switch (action.type) {\r\n    case 'SET_STRICT_DISABLED_EFFECT':\r\n      return setStrictDisabledEffect(state);\r\n\r\n    case 'SET_BETFORE_DISABLED_EFFECT':\r\n      return setDisabledBeforeEffect(state);\r\n\r\n    case 'CHANGE_FOCUS':\r\n      return state.map((step, index) => {\r\n        if (action.currentStepIndex === undefined) {\r\n          throw new Error(\r\n            'currentStepIndex is required for CHANGE_FOCUS action',\r\n          );\r\n        }\r\n        if (index === action.currentStepIndex) {\r\n          return {\r\n            ...step,\r\n            isCurrent: true,\r\n            isNext: false,\r\n          };\r\n        }\r\n        if (index === action.currentStepIndex + 1) {\r\n          return {\r\n            ...step,\r\n            isNext: true,\r\n            isCurrent: false,\r\n          };\r\n        }\r\n        return {\r\n          ...step,\r\n          isCurrent: false,\r\n          isNext: false,\r\n        };\r\n      });\r\n    case 'SET_DONE':\r\n      return state.map((step, index) => {\r\n        if (index === action.currentStepIndex) {\r\n          return {\r\n            ...step,\r\n            isDone: true,\r\n          };\r\n        }\r\n        return step;\r\n      });\r\n    case 'REMOVE_DONE':\r\n      return state.map((step, index) => {\r\n        if (index === action.currentStepIndex) {\r\n          return {\r\n            ...step,\r\n            isDone: false,\r\n          };\r\n        }\r\n        return step;\r\n      });\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport default stepReducer;\r\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/useStepperItemMap.hook.tsx": "import React, { useCallback } from 'react';\r\nimport {\r\n  CompositeField,\r\n  FieldReactFormMaker,\r\n  ReactFormMakerStep,\r\n} from '../../../interfaces/FieldInterfaces';\r\nimport { StepperItem } from './StepperItems';\r\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\r\nimport { isStepReactFormMaker } from '../../../utils/typeGuards/compositeField.TypeGuards';\r\nimport { H3, Lead } from '@/components/ui/Typography';\r\n\r\ninterface UseStepperItemsMapReturn {\r\n  /**\r\n   * ### Array of StepperItems components\r\n   *\r\n   * This function allows you to map the form fields to the StepperItems component.\r\n   *\r\n   * ---\r\n   *\r\n   *  #### StepperItem Content\r\n   *\r\n   * The StepperItem component is a component that allows you to display the content of the stepper :\r\n   *  - The title of the step is displayed in a `H3` tag.\r\n   *  - The legend of the step is displayed in a `Lead` tag. (optional, if the legend is not defined, the tag is not displayed)\r\n   *  - Rest of fields are displayed by the `FieldReactFormMaker` present in the each `ReactFormMakerStep` object.\r\n   *\r\n   * ---\r\n   *\r\n   * For more information, see the {@link FieldReactFormMaker} and {@link ReactFormMakerStep} interfaces.\r\n   *\r\n   * @param formfields\r\n   * @returns\r\n   */\r\n  StepperItemsMap: (\r\n    formfields: CompositeField[],\r\n  ) => (React.ReactElement<typeof StepperItem> | null)[];\r\n}\r\n\r\nexport function useStepperItemsMap(\r\n  FormFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[],\r\n): UseStepperItemsMapReturn {\r\n  const StepperItemsMap = useCallback(\r\n    (\r\n      formfields: CompositeField[],\r\n    ): (React.ReactElement<typeof StepperItem> | null)[] => {\r\n      const uuids = useGenerateUUIDs<CompositeField>(formfields);\r\n\r\n      return formfields.map((element, index) => {\r\n        if (isStepReactFormMaker(element)) {\r\n          return (\r\n            <StepperItem\r\n              key={uuids[index]}\r\n              className={`${element.className} ${element.isHide ? 'hidden' : ''}`}\r\n            >\r\n              <H3 className={element?.legendClassName}>{element.stepName}</H3>\r\n              {element?.legend && (\r\n                <Lead className={element?.legendClassName}>\r\n                  {element.legend}\r\n                </Lead>\r\n              )}\r\n              {FormFieldsMap(element.fields as FieldReactFormMaker[])}\r\n            </StepperItem>\r\n          );\r\n        }\r\n        return null;\r\n      });\r\n    },\r\n    [FormFieldsMap],\r\n  );\r\n\r\n  return { StepperItemsMap };\r\n}\r\n",
  "/ReactFormMaker/FormFields/Class/FieldFactory/FieldFactory.class.ts": "import { z, ZodNumber, ZodString, ZodType, ZodTypeDef } from 'zod';\r\nimport {\r\n  DividerReactFormMaker,\r\n  FieldReactFormMaker,\r\n  InputType,\r\n  ReactFormMakerFieldset,\r\n} from '../../../interfaces/FieldInterfaces';\r\nimport { FormFieldEvent } from '../../../interfaces/FormFieldEvent';\r\n\r\nimport {\r\n  isBetween,\r\n  islaterThan,\r\n  isOlderThan,\r\n  SimpleDurationValues,\r\n} from '../../../utils/validators/dateValidators';\r\nimport { CustomInputFieldElementParams } from '@/components/ReactFormMaker/interfaces/CustomInputFieldElementParams';\r\nimport React from 'react';\r\nimport { Option } from '@/components/ReactFormMaker/utils/typeGuards/optionsFields.TypeGuards';\r\nimport { FieldValue } from 'react-hook-form';\r\n\r\n/**\r\n * Represents a condition where a value must be in the past.\r\n */\r\ntype Past = 'past';\r\n\r\n/**\r\n * Represents a condition where a value must be in the future.\r\n */\r\ntype Future = 'future';\r\n\r\n/**\r\n * Represents a condition where a value must be more than a specified duration.\r\n *\r\n * @property {string} type - The type of condition, which is always 'moreThan' for this interface.\r\n * @property {SimpleDurationValues} value - The duration value that the condition is compared against.\r\n */\r\ntype OlderThan = { type: 'olderThan'; value: SimpleDurationValues };\r\n\r\n/**\r\n * Represents a condition where a value must be less than a specified duration.\r\n *\r\n * @property {string} type - The type of the condition, which is always 'olderThan'.\r\n * @property {SimpleDurationValues} value - The value that the condition is compared against.\r\n */\r\ntype LaterThan = { type: 'laterThan'; value: SimpleDurationValues };\r\n\r\n/**\r\n * Represents a type that indicates a difference of values. Is used to calculate the difference in a DateRangeType between two `from` values and `to` values.\r\n *\r\n * @property type - A string literal type that is always 'differenceOf'.\r\n * @property value - An object of type `SimpleDurationValues` that holds the duration values.\r\n */\r\ntype IsBetween = { type: 'isBetween'; value: SimpleDurationValues };\r\n\r\ntype IsOutside = { type: 'isOutside'; value: SimpleDurationValues };\r\n\r\n// Définition du type ZodeDateType\r\n/**\r\n * Represents a type for date validation in Zod.\r\n *\r\n * This type can be one of the following:\r\n * - `Past`: A date must be in the past.\r\n * - `Future`: A date must be in the future.\r\n * - `OlderThan`: Defines a difference between today's date and the input selected by the user, e.g.{type : olderThan, value: {years: 18}} to define a birthDate for which the user must select a date prior to 18 years of age\r\n * - `LaterThan`: Defines a difference between today's date and the input selected by the user, e.g.{type : laterThan, value: {weeks: 1}} to define a date that must be at least 1 week away\r\n * - `ZodType<any, ZodTypeDef, any>`: A generic Zod type for any date validation.\r\n */\r\ntype ZodeDateType =\r\n  | Past\r\n  | Future\r\n  | OlderThan\r\n  | LaterThan\r\n  | ZodType<any, ZodTypeDef, any>;\r\n\r\n/**\r\n * Represents a date range with a start date (`from`) and an end date (`to`).\r\n *\r\n * @typedef {Object} DateRangeType\r\n * @property {ZodeDateType} from - The start date of the range.\r\n * @property {ZodeDateType} to - The end date of the range.\r\n */\r\ntype DateRangeType = {\r\n  from: ZodeDateType;\r\n  to: ZodeDateType;\r\n};\r\n\r\n/**\r\n * A type representing a date range, which can be one of the following:\r\n * - `DateRangeType`: A custom type representing a range of dates.\r\n * - `DifferenceOf`: A custom type representing the difference between two dates.\r\n * - `ZodType<any, ZodTypeDef, any>`: A Zod schema type that can validate any value.\r\n */\r\ntype ZodDateRangeType =\r\n  | DateRangeType\r\n  | IsBetween\r\n  | IsOutside\r\n  | ZodType<any, ZodTypeDef, any>;\r\n\r\n/**\r\n * Converts a string to a no-spaces string by replacing all spaces with underscores.\r\n * If the input string contains spaces, a warning is logged to the console.\r\n *\r\n * @param value - The input string to be converted.\r\n * @returns The converted string with spaces replaced by underscores.\r\n */\r\nfunction createNoSpacesString(value: string): string {\r\n  if (value.includes(' ')) {\r\n    console.warn(`Name of field cannot contain spaces: ${value}`);\r\n    return value.trim().replaceAll(' ', '_');\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Determines the Zod type based on the input value's type.\r\n *\r\n * @param value - The value to determine the type for.\r\n * @returns A ZodType corresponding to the type of the input value.\r\n *\r\n * The function returns:\r\n * - `z.string()` if the value is a string.\r\n * - `z.number()` if the value is a number.\r\n * - `z.boolean()` if the value is a boolean.\r\n * - `z.object(value)` if the value is an object.\r\n * - `z.any()` for any other type.\r\n */\r\nfunction defineType(value: any): ZodType<any, ZodTypeDef, any> {\r\n  switch (typeof value) {\r\n    case 'string':\r\n      return z.string();\r\n    case 'number':\r\n      return z.number();\r\n    case 'boolean':\r\n      return z.boolean();\r\n    case 'object':\r\n      return z.object(value);\r\n    default:\r\n      return z.any();\r\n  }\r\n}\r\n\r\nfunction stringifyDuration(duration: SimpleDurationValues): string {\r\n  const { years, months, weeks, days } = duration;\r\n  const parts = [];\r\n  if (years) parts.push(`${years} year${years > 1 ? 's' : ''}`);\r\n  if (weeks) parts.push(`${weeks} week${weeks > 1 ? 's' : ''}`);\r\n  if (months) parts.push(`${months} month${months > 1 ? 's' : ''}`);\r\n  if (days) parts.push(`${days} day${days > 1 ? 's' : ''}`);\r\n\r\n  return parts.join(', ');\r\n}\r\n\r\n/**\r\n * @template T - The type of the form data.\r\n *\r\n *\r\n * @attribute {T} inputName - The name of the input field.\r\n * @class Field\r\n * @implements {FieldReactFormMaker}\r\n */\r\nexport default class Field<T extends FieldReactFormMaker> {\r\n  inputName: string;\r\n  label?: string;\r\n  placeholder?: string;\r\n  defaultValues: any;\r\n  zodObject: ZodType<any, ZodTypeDef, any> | undefined;\r\n  inputType: InputType = 'text';\r\n  // defaultValue?: any;\r\n  options?: string[] | Option[];\r\n  className?: string;\r\n  isHide?: boolean;\r\n  disabled?: boolean | undefined;\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  legend?: string;\r\n  legendClassName?: string;\r\n  description?: string;\r\n  isSecure?: boolean;\r\n  children?: React.ReactNode;\r\n  customInputFieldElement?: React.ReactNode;\r\n  props?: Record<string, any>;\r\n  onBlur?: ((event: FormFieldEvent) => void) | undefined;\r\n  onSelect?: ((event: FormFieldEvent) => void) | undefined;\r\n  onChange?: ((event: FormFieldEvent) => void) | undefined;\r\n  onClick?: ((event: FormFieldEvent) => void) | undefined;\r\n\r\n  constructor(name: string, entries?: Partial<T>) {\r\n    this.inputName = createNoSpacesString(name);\r\n    if (entries) Object.assign(this, entries);\r\n  }\r\n\r\n  /**\r\n   * Creates a Zod schema from a list of options.\r\n   *\r\n   * @param options - An array of options which can be either strings or objects with a `value` property.\r\n   * @param hasMultipleInput - A boolean indicating if the input can have multiple values. Defaults to `false`.\r\n   * @returns A Zod schema that validates the provided options.\r\n   *\r\n   * @remarks\r\n   * - If `options` contains objects, it assumes each object has a `value` property and creates a schema based on the type of the first `value`.\r\n   * - If `options` contains strings, it creates an enum schema from the strings.\r\n   * - The schema includes a refinement to ensure the value is one of the provided options.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const options = ['option1', 'option2', 'option3'];\r\n   * const schema = createEnumFromOptions(options);\r\n   * // schema will be a Zod enum schema for the provided options\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const options = [{ value: 1, label: \"first Label\" }, { value: 2, label: \"second Label\" }];\r\n   * const schema = createEnumFromOptions(options);\r\n   * // schema will be a Zod schema based on the type of the `value` property\r\n   * ```\r\n   */\r\n  private createEnumFromOptions(\r\n    options: string[] | Option[],\r\n    hasMultipleInput?: boolean,\r\n  ): ZodType<any, ZodTypeDef, any> {\r\n    hasMultipleInput = hasMultipleInput || false;\r\n    //define options type\r\n    const isComplexeOption =\r\n      typeof options[0] === 'object' && options[0].hasOwnProperty('value');\r\n    let zodObject: ZodType<any, ZodTypeDef, any>;\r\n    if (isComplexeOption) {\r\n      options = options as Option[];\r\n      const typeValue = defineType(options[0].value);\r\n      zodObject = hasMultipleInput ? z.array(typeValue) : typeValue;\r\n    } else {\r\n      zodObject = hasMultipleInput\r\n        ? z.array(z.enum(options as [string, ...string[]]))\r\n        : z.enum(options as [string, ...string[]]);\r\n    }\r\n\r\n    zodObject.refine(\r\n      (data) => {\r\n        if (isComplexeOption) {\r\n          options = options as Option[];\r\n          return options.some((option) => option.value === data);\r\n        } else {\r\n          return options.includes(data);\r\n        }\r\n      },\r\n      {\r\n        message: 'Invalid option selected',\r\n      },\r\n    );\r\n\r\n    return zodObject;\r\n  }\r\n\r\n  /**\r\n   * Defines a Zod date type based on the provided `ZodeDateType`.\r\n   *\r\n   * @param type - The type of date validation to apply. It can be one of the following:\r\n   * - 'past': Validates that the date is in the past.\r\n   * - 'future': Validates that the date is in the future.\r\n   * - An object with a `type` property:\r\n   *   - `{ type: 'olderThan', value: Date }`: Validates that the date is older than the specified value.\r\n   *   - `{ type: 'laterThan', value: Date }`: Validates that the date is later than the specified value.\r\n   * - An instance of `ZodType`: Uses the provided Zod type for validation.\r\n   *\r\n   * @returns A Zod date type with the specified validation.\r\n   */\r\n  private defineZodDateType(type: ZodeDateType): ZodType<any, ZodTypeDef, any> {\r\n    switch (type) {\r\n      case 'past':\r\n        return z.date().refine((date) => date < new Date(), {\r\n          message: 'Date must be in the past',\r\n        });\r\n      case 'future':\r\n        return z.date().refine((date) => date > new Date(), {\r\n          message: 'Date must be in the future',\r\n        });\r\n      default:\r\n        if (typeof type === 'object' && 'type' in type) {\r\n          if (type.type === 'olderThan') {\r\n            return z.date().refine((date) => isOlderThan(date, type.value), {\r\n              message: `Date must be later than ${stringifyDuration(type.value)} ago`,\r\n            });\r\n          } else if (type.type === 'laterThan') {\r\n            return z.date().refine((date) => islaterThan(date, type.value), {\r\n              message: `Date must be older than ${stringifyDuration(type.value)} away`,\r\n            });\r\n          }\r\n        } else if (type instanceof ZodType) {\r\n          return type;\r\n        }\r\n    }\r\n\r\n    return z.date();\r\n  }\r\n\r\n  /**\r\n   * ** Set Config **\r\n   *\r\n   * You can set the config object for the field with this method :\r\n   *  - **label** : If you want to set a label it will be displayed above the field\r\n   *  - **placeholder** : If you want to set a placeholder\r\n   * - **defaultValues** : If you want to set a default value (warning: this value will be overrided by the value in the form)\r\n   * - **zodObject** : Set a zod object to validate the field (see zod documentation: https://zod.dev/\r\n   * - **inputType** : Set the type of the input. _is recommended to use the methods provided by the class to set the input type_\r\n   * - **options** : If you want to set options for a select or radio input (only used for select and radio input type)\r\n   * - **className** : If you want to set a class name to the\r\n   * - **isHide** : If you want to hide the field\r\n   * - **disabled** : If you want to disable the field\r\n   * - **fields** : If you want to set a fieldset\r\n   * - **legend** : If you want to set a legend to the fieldset\r\n   * - **legendClassName** : If you want to set a class name to the legend\r\n   * - **description** : If you want to set a description to the field\r\n   * - **isSecure** : If you want to set the field as secure\r\n   * - **children** : If you want to set children to the field (is recommended to use the methods provided by the class to set)\r\n   *\r\n   * ---\r\n   * Set the config object for the field\r\n   * @param entries config object to set\r\n   * @returns\r\n   */\r\n  setConfig(entries: Partial<FieldReactFormMaker>): this {\r\n    Object.assign(this, entries);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * The onBlur event of the input field.\r\n   * This is the onBlur event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * _This is optional._\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link FormFieldEvent}\r\n   */\r\n  public handlerBlur(callback: (e: FormFieldEvent) => void): this {\r\n    this.onBlur = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * The onFocus event of the input field.\r\n   * This is the onFocus event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<T> to the event for controlling the form directly from the event.\r\n   * _This is optional._\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link FormFieldEvent}\r\n   */\r\n  public handlerSelect(callback: (e: FormFieldEvent) => void): this {\r\n    this.onSelect = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * The onChange event of the input field.\r\n   * This is the onChange event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * _This is optional._\r\n   * You can use it to trigger the onChange event of the input field.\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link FormFieldEvent}\r\n   */\r\n  public handlerChange(callback: (e: FormFieldEvent) => void): this {\r\n    this.onChange = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Registers a callback function to be executed when a click event occurs on the form field.\r\n   * is used whene native trigger of click is on element of the field\r\n   * like TileSelector, TileMultiSelector, and cutom component\r\n   *\r\n   * @param callback - The function to be called when the click event is triggered.\r\n   *                   It receives a `FormFieldEvent` object as its argument.\r\n   * @returns The current instance of the class, allowing for method chaining.\r\n   */\r\n  public handlerClick(callback: (e: FormFieldEvent) => void): this {\r\n    this.onClick = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the input type to 'text' and optionally assigns a Zod schema object for validation.\r\n   *\r\n   * @param {ZodType<any, ZodTypeDef, String>} [zodObject] - Optional Zod schema object for validation. If not provided, defaults to a string schema.\r\n   * @returns {this} The current instance of the class for method chaining.\r\n   */\r\n  public text(zodObject?: ZodType<any, ZodTypeDef, String>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.string();\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.zodObject as ZodString;\r\n    this.inputType = 'text';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the field as a password input with optional Zod validation.\r\n   *\r\n   * @param zodObject - An optional Zod schema object for validating the password. If not provided, a default schema is used.\r\n   *   The default schema requires:\r\n   *   - A minimum length of 8 characters.\r\n   *   - At least one uppercase letter.\r\n   *   - At least one lowercase letter.\r\n   *   - At least one number.\r\n   *\r\n   * ---\r\n   * @info > If you use key name `password` exactly, and second password type with namekey `confirmPassword`, the form will automaticly check if the two passwords are the same. The seconde password will be deleted from returned data for security reason.\r\n   * @returns The current instance of the class for method chaining.\r\n   */\r\n  public password(zodObject?: ZodType<any, ZodTypeDef, String>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z\r\n        .string()\r\n        .min(6, {\r\n          message: 'Password must be at least 6 characters.',\r\n        })\r\n        .refine(\r\n          (data) => {\r\n            //regex password submition\r\n            return data.match(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/);\r\n          },\r\n          {\r\n            message:\r\n              'Password must contain at least one uppercase letter, one lowercase letter and one number.',\r\n          },\r\n        );\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.zodObject as ZodString;\r\n    this.inputType = 'password';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures the field as a select input with the provided options and optional Zod schema.\r\n   *\r\n   * @param option - An array of strings or Option objects representing the selectable options.\r\n   * @param zodObject - An optional Zod schema object for validating the selected option.\r\n   *  If not provided, a default schema is created based on the type of the options.\r\n   * @returns The current instance of the field for method chaining.\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link Option} for the interface used in the `option` argument.\r\n   * @see {@link createEnumFromOptions} for creating a Zod schema from the provided options when no Zod schema is provided.\r\n   */\r\n  public select(\r\n    option: string[] | Option[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option);\r\n    }\r\n\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'select';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures the field as a select autocomplete input.\r\n   *\r\n   * @param option - An array of strings or Option objects representing the selectable options.\r\n   * @param zodObject - An optional Zod schema object for validation. If not provided, a schema will be created from the options.\r\n   * If the options are strings, the schema will be an enum schema. If the options are objects, the schema will be based on the type of the `value` property.\r\n   * @returns The current instance of the class for method chaining.\r\n   *\r\n   * ---\r\n   *\r\n   * @see {@link Option} for the interface used in the `option` argument.\r\n   * @see {@link createEnumFromOptions} for creating a Zod schema from the provided options when no Zod schema is provided.\r\n   */\r\n  public selectAutocomplete(\r\n    option: string[] | Option[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option);\r\n    }\r\n\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'selectAutocomplete';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the input type to 'textarea' and optionally assigns a Zod validation schema.\r\n   *\r\n   * @param {ZodType<any, ZodTypeDef, String>} [zodObject] - Optional Zod validation schema for the textarea input. If not provided, defaults to a string schema.\r\n   * @returns {this} The current instance of the class for method chaining.\r\n   */\r\n  public textarea(zodObject?: ZodType<any, ZodTypeDef, String>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.string();\r\n    }\r\n    this.inputType = 'textarea';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the field type to 'date' and assigns a Zod date schema to the field.\r\n   *\r\n   * @param {ZodeDateType} [zodObject] - An optional Zod date schema object. If not provided, a default Zod date schema will be used.\r\n   * Possible values for the schema are:\r\n   * - **past**: The date must be in the past.\r\n   * - **future**: The date must be in the future.\r\n   * - **OlderThan**: The date must be more than a specified date. The schema must be an object with a `type` property set to 'moreThan' and a `value` property with the date to compare against.\r\n   * - **LaterThan**: The date must be less than a specified date. The schema must be an object with a `type` property set to 'lessThan' and a `value` property with the date to compare against.\r\n   * - A Zod schema object for date validation.\r\n   * @returns {this} The current instance of the class for method chaining.\r\n   *\r\n   * @remarks OlderThan and LaterThan are used to compare the date with a specified date. he used type is SimpleDurationValues\r\n   * SimpleDurationValues is an object with the following properties:\r\n   * ```typescript\r\n   * type SimpleDurationValues = {\r\n   *    years?: number;\r\n   *    months?: number;\r\n   *    weeks?: number;\r\n   *    days?: number;\r\n   * }\r\n   * ```\r\n   *\r\n   * ---\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   *\r\n   * const dateField = new Field('dateField').date('past'); ///on error return \"Date must be in the past\"\r\n   * const dateField = new Field('dateField').date('future'); ///on error return \"Date must be in the future\"\r\n   * const dateField = new Field('dateField').date({ type: 'LaterThan', value: { week: 1 } });\r\n   * //on error return : \"Date must be late than 1 week away\"\r\n   * const dateField = new Field('dateField').date({ type: 'OlderThan', value: { years: 18 } });\r\n   * //on error return : \"Date must be older than 18 years ago\"\r\n   *\r\n   * // Version with Zod schema if you want more specific validation\r\n   * const dateField = new Field('dateField').date(z.date().refine((date) => date > new Date(), { message: 'Date must be in the future' })); ///on error return \"Date must be in the future\"\r\n   *```\r\n   * ---\r\n   * @see {@link ZodeDateType} for the possible values for the Zod date schema.\r\n   * @see {@link defineZodDateType} for creating a Zod date schema based on the provided value.\r\n   * @see {@link SimpleDurationValues} for the interface used in the `value` property of the `moreThan` and `lessThan` schemas.\r\n   */\r\n  public date(zodDateHelper?: ZodeDateType): this {\r\n    if (!zodDateHelper || zodDateHelper === undefined) {\r\n      zodDateHelper = z.date();\r\n    } else {\r\n      zodDateHelper = this.defineZodDateType(zodDateHelper);\r\n    }\r\n    this.zodObject = zodDateHelper;\r\n    this.inputType = 'date';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Date Range Picker**\r\n   *\r\n   * ---\r\n   *\r\n   * @param {ZodDateRangeType} [zodObject] - An optional Zod date range schema object. If not provided, a default Zod date range schema will be used.\r\n   * Possible values for the schema are:\r\n   * - **isBetween**: The difference between the chosen dates must be less than the specified duration. The schema must be an object with a `type` property set to 'isBetween' and a `value` property with the duration to compare against.\r\n   * - **isOutside**: The difference between the chosen dates must be more than the specified duration. The schema must be an object with a `type` property set to 'isOutside' and a `value` property with the duration to compare against.\r\n   * - A Zod schema object for date range validation.\r\n   *\r\n   *  *ZodShema need to be an object with the following properties:*\r\n   *\r\n   * ```typescript\r\n   *       zodObject = z.object({\r\n   *     from: z.date(),\r\n   *     to: z.date(),\r\n   *   });\r\n   * ```\r\n   *\r\n   * ---\r\n   *\r\n   * @example\r\n   *\r\n   * ```typescript\r\n   * const dateRangeField = new Field('dateRangeField').dateRange({ type: 'isBetween', { weeks: 1 }});\r\n   * //on error return : \"The difference between the chosen dates must be less than 1 week\"\r\n   *\r\n   * const dateRangeField = new Field('dateRangeField').dateRange({ type: 'isOutside', { mouths: 1, years: 1 }});\r\n   * //on error return : \"The difference between the chosen dates must be more than 1 month and 1 year\"\r\n   *\r\n   * // Version with Zod schema if you want more specific validation\r\n   * const dateRangeField = new Field('dateRangeField').dateRange(z.object({\r\n   *    from: z.date().refine((date) => date < new Date(), { message: 'Date must be in the past' }),\r\n   *   to: z.date().refine((date) => date > new Date(), { message: 'Date must be in the future' }));\r\n   * }));\r\n   * ```\r\n   */\r\n  public dateRange(zodObject?: ZodDateRangeType): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.object({\r\n        from: z.date(),\r\n        to: z.date(),\r\n      });\r\n    } else {\r\n      if (typeof zodObject === 'object' && 'type' in zodObject) {\r\n        const { type, value } = zodObject;\r\n        switch (type) {\r\n          case 'isBetween':\r\n            zodObject = z\r\n              .object({\r\n                from: z.date(),\r\n                to: z.date(),\r\n              })\r\n              .superRefine((data, ctx) => {\r\n                const { from, to } = data;\r\n                if (from && to) {\r\n                  const constrainIsRespected = isBetween(from, to, value);\r\n                  if (!constrainIsRespected) {\r\n                    ctx.addIssue({\r\n                      code: z.ZodIssueCode.custom,\r\n                      message: `The difference between the chosen dates must be less than ${stringifyDuration(value)}`,\r\n                    });\r\n                  }\r\n                } else {\r\n                  ctx.addIssue({\r\n                    code: z.ZodIssueCode.custom,\r\n                    message: \"You must provide a 'from' and 'to' date\",\r\n                  });\r\n                }\r\n              });\r\n\r\n          case 'isOutside':\r\n            zodObject = z\r\n              .object({\r\n                from: z.date(),\r\n                to: z.date(),\r\n              })\r\n              .superRefine((data, ctx) => {\r\n                const { from, to } = data;\r\n                if (from && to) {\r\n                  const constrainIsRespected = !isBetween(from, to, value);\r\n                  if (!constrainIsRespected) {\r\n                    ctx.addIssue({\r\n                      code: z.ZodIssueCode.custom,\r\n                      message: `The difference between the chosen dates must be more than ${stringifyDuration(value)}`,\r\n                    });\r\n                  }\r\n                } else {\r\n                  ctx.addIssue({\r\n                    code: z.ZodIssueCode.custom,\r\n                    message: \"You must provide a 'from' and 'to' date\",\r\n                  });\r\n                }\r\n              });\r\n        }\r\n      } else if (zodObject instanceof ZodType) {\r\n        zodObject = zodObject;\r\n      } else if (\r\n        typeof zodObject === 'object' &&\r\n        'from' in zodObject &&\r\n        'to' in zodObject\r\n      ) {\r\n        zodObject = z.object({\r\n          from: this.defineZodDateType(zodObject.from),\r\n          to: this.defineZodDateType(zodObject.to),\r\n        });\r\n      } else {\r\n        console.warn('Invalid date range type');\r\n        zodObject = z.object({\r\n          from: z.date(),\r\n          to: z.date(),\r\n        });\r\n      }\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'dateRange';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * @beta This method is still in beta and may change in the future.\r\n   * ---\r\n   * define the field type as radio\r\n   */\r\n  public radio(\r\n    option: string[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option);\r\n    }\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'radio';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as checkbox\r\n   */\r\n  public checkbox(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.boolean();\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'checkbox';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as switch\r\n   */\r\n  public switch(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.boolean();\r\n    }\r\n    this.inputType = 'switch';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as file\r\n   */\r\n  public file(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.instanceof(File);\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'file';\r\n    return this;\r\n  }\r\n\r\n  public fileDropZone(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.array(z.instanceof(File));\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'fileDropZone';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as number\r\n   */\r\n  public number(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z\r\n        .string()\r\n        .refine((data) => !isNaN(Number(data)), {\r\n          message: 'Invalid number',\r\n        })\r\n        .transform((data) => Number(data));\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.zodObject as ZodNumber;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Field Type: Custom**\r\n   *\r\n   * ---\r\n   * Allows defining a custom field using a React component. This method is useful for integrating custom components\r\n   * into the form system while automatically wrapping the provided properties into the `props` key.\r\n   *\r\n   * ---\r\n   * @template T - The type of the specific properties for the custom component.\r\n   *\r\n   * @param {React.ComponentType<CustomInputFieldElementParams<T>>} type\r\n   * The React component to use as the custom field. This component must accept props conforming to `CustomInputFieldElementParams<T>`.\r\n   *\r\n   * @param {T} [props]\r\n   * The specific properties to pass to the custom component. These properties will automatically be wrapped into the `props` key.\r\n   * If no properties are provided, an empty object will be passed by default.\r\n   *\r\n   * @param {...React.ReactNode} children\r\n   * Optional React children to include within the custom component.\r\n   *\r\n   * @returns {this} The current instance of the class, allowing method chaining.\r\n   *\r\n   * ---\r\n   *\r\n   * @remarks\r\n   * - This method is useful for creating custom input fields that are not covered by the standard field types.\r\n   * - It allows for greater flexibility and customization in the form system.\r\n   * - The properties like `zFields`, `fieldProps`, and `index` will be dynamically injected into the cloned component.\r\n   */\r\n  public custom<T>(\r\n    type: React.ComponentType<\r\n      CustomInputFieldElementParams<\r\n        T extends Record<string, any> ? T : Record<string, any>\r\n      >\r\n    >,\r\n    props?: T,\r\n    ...children: React.ReactNode[]\r\n  ): this {\r\n    this.inputType = 'custom';\r\n\r\n    // Encapsuler automatiquement les propriétés dans un objet `props`\r\n    const wrappedProps: CustomInputFieldElementParams<\r\n      T extends Record<string, any> ? T : Record<string, any>\r\n    > = {\r\n      props: (props || {}) as T extends Record<string, any>\r\n        ? T\r\n        : Record<string, any>, // Si `props` est vide, on passe un objet vide\r\n    };\r\n\r\n    this.customInputFieldElement = React.createElement(\r\n      type,\r\n      wrappedProps,\r\n      ...children,\r\n    );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as tileSelector\r\n   */\r\n  public tileSelector(\r\n    option: string[] | Option[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    // if the option is a string array, convert it to an array of options with the same value and label\r\n    if (typeof option[0] === 'string') {\r\n      option = (option as string[]).map((value) => {\r\n        return { value, label: value } as Option;\r\n      });\r\n    }\r\n\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option);\r\n    }\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'tileSelector';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Field Type **\r\n   *\r\n   * ---\r\n   * define the field type as tileMultiSelector\r\n   */\r\n  public tileMultiSelector(\r\n    option: string[] | Option[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option, true);\r\n    }\r\n\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'tileMultiSelector';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **MultiSelect**\r\n   *\r\n   * ---\r\n   *\r\n   * define the field type as multiSelect\r\n   * @param option\r\n   * @param zodObject\r\n   * @returns\r\n   */\r\n  public multiSelect(\r\n    option: string[] | Option[],\r\n    zodObject?: ZodType<any, ZodTypeDef, any>,\r\n  ): this {\r\n    // if the option is a string array, convert it to an array of options with the same value and label\r\n    if (typeof option[0] === 'string') {\r\n      option = (option as string[]).map((value) => {\r\n        return { value, label: value } as Option;\r\n      });\r\n    }\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = this.createEnumFromOptions(option, true);\r\n    }\r\n    this.options = option;\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'multiSelect';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Phone Number field**\r\n   *\r\n   * ---\r\n   *\r\n   * Define the field type as phoneNumber\r\n   * @param zodObject\r\n   * *optional zod object to validate the phone number, if not provided a default zod object will be used to validate the phone number on **international format***\r\n   * @returns\r\n   */\r\n  public phoneNumber(zodObject?: ZodType<any, ZodTypeDef, any>): this {\r\n    if (!zodObject || zodObject === undefined) {\r\n      zodObject = z.string().refine((data) => {\r\n        return data.match(\r\n          /^\\+((?:9[679]|8[035789]|6[789]|5[90]|42|3[578]|2[1-689])|9[0-58]|8[1246]|6[0-6]|5[1-8]|4[013-9]|3[0-469]|2[70]|7|1)(?:\\W*\\d){0,13}\\d$/,\r\n        );\r\n      });\r\n    }\r\n    this.zodObject = zodObject;\r\n    this.inputType = 'phoneNumber';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Add childre JSX Element under the field**\r\n   *\r\n   * Set a component as children of the field\r\n   *\r\n   * @param children\r\n   * @returns\r\n   */\r\n  public Children<T>(\r\n    type: React.ComponentType<\r\n      CustomInputFieldElementParams<\r\n        T extends Record<string, any> ? T : Record<string, any>\r\n      >\r\n    >,\r\n    props?: T,\r\n    ...children: React.ReactNode[]\r\n  ): this {\r\n    // Encapsuler automatiquement les propriétés dans un objet `props`\r\n    const wrappedProps: CustomInputFieldElementParams<\r\n      T extends Record<string, any> ? T : Record<string, any>\r\n    > = {\r\n      props: (props || {}) as T extends Record<string, any>\r\n        ? T\r\n        : Record<string, any>, // Si `props` est vide, on passe un objet vide\r\n    };\r\n\r\n    this.children = React.createElement(type, wrappedProps, ...children);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Disabled input**\r\n   *\r\n   * @param value Can be use a codition to enable or disable the field, by default the field is disabled\r\n   * @returns\r\n   */\r\n  disable(value: boolean = true): this {\r\n    this.disabled = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * ** Hide input **\r\n   *\r\n   * @param value Can be use a codition to hide or show the field, by default the field is hidden\r\n   * @returns\r\n   */\r\n  hide(value: boolean = true): this {\r\n    this.isHide = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Optionnal input**\r\n   * @param value define the field as optional\r\n   * @returns\r\n   */\r\n  optionnal(value: boolean = true): this {\r\n    if (value) {\r\n      this.zodObject = this.zodObject\r\n        ? this.zodObject.optional()\r\n        : z.any().optional();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Define the field as nullable\r\n   * @param value define the field as nullable or not by default the field is nullable\r\n   * @returns\r\n   */\r\n  nullable(value: boolean = true): this {\r\n    if (value) {\r\n      this.zodObject = this.zodObject\r\n        ? this.zodObject.nullable()\r\n        : z.any().nullable();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Set error a single error message**\r\n   *\r\n   * ---\r\n   *\r\n   * Set a custom error message for the field. This method will override any previous error messages set for the field.\r\n   * * @param message The error message to set for the field.\r\n   * * @returns The current instance of the field for method chaining.\r\n   *\r\n   * ---\r\n   *\r\n   * *If you need to set complex error messages, you need to improve the setValidation method with a custom zod object.*\r\n   */\r\n  public err(message: string): this {\r\n    if (this.zodObject) {\r\n      this.zodObject = this.zodObject.refine(() => false, {\r\n        message,\r\n      });\r\n    } else {\r\n      this.zodObject = z.any().refine(() => false, {\r\n        message,\r\n      });\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** GETTER */\r\n\r\n  getConfig(): Partial<FieldReactFormMaker> {\r\n    return {\r\n      inputName: this.inputName,\r\n      label: this.label,\r\n      placeholder: this.placeholder,\r\n      defaultValues: this.defaultValues,\r\n      zodObject: this.zodObject,\r\n      inputType: this.inputType,\r\n      options: this.options,\r\n      className: this.className,\r\n      isHide: this.isHide,\r\n      disabled: this.disabled,\r\n      fields: this.fields,\r\n      legend: this.legend,\r\n      legendClassName: this.legendClassName,\r\n      description: this.description,\r\n      isSecure: this.isSecure,\r\n      children: this.children,\r\n      customInputFieldElement: this.customInputFieldElement,\r\n      props: this.props,\r\n    };\r\n  }\r\n  /**\r\n   * Get the field name\r\n   * @returns\r\n   */\r\n  getName(): string {\r\n    return this.inputName;\r\n  }\r\n\r\n  /**\r\n   * Get the field type\r\n   * @returns\r\n   */\r\n  getType(): InputType {\r\n    return this.inputType;\r\n  }\r\n\r\n  /**\r\n   * Get the field label\r\n   * @returns\r\n   */\r\n  getLabel(): string | undefined {\r\n    return this.label;\r\n  }\r\n\r\n  /**\r\n   * Get the field placeholder\r\n   * @returns\r\n   */\r\n  getPlaceholder(): string | undefined {\r\n    return this.placeholder;\r\n  }\r\n\r\n  /**\r\n   * Get the field default value\r\n   * @returns\r\n   */\r\n  getDefaultValues(): any {\r\n    return this.defaultValues;\r\n  }\r\n\r\n  getZodObject(): ZodType<any, ZodTypeDef, any> | undefined {\r\n    return this.zodObject;\r\n  }\r\n\r\n  getOptions(): string[] | Option[] | undefined {\r\n    return this.options;\r\n  }\r\n\r\n  getClassName(): string | undefined {\r\n    return this.className;\r\n  }\r\n\r\n  isHidden(): boolean | undefined {\r\n    return this.isHide;\r\n  }\r\n\r\n  isDisabled(): boolean | undefined {\r\n    return this.disabled;\r\n  }\r\n\r\n  getFields():\r\n    | (FieldReactFormMaker | DividerReactFormMaker | ReactFormMakerFieldset)[]\r\n    | undefined {\r\n    return this.fields;\r\n  }\r\n\r\n  getLegend(): string | undefined {\r\n    return this.legend;\r\n  }\r\n\r\n  getLegendClassName(): string | undefined {\r\n    return this.legendClassName;\r\n  }\r\n\r\n  getDescription(): string | undefined {\r\n    return this.description;\r\n  }\r\n\r\n  hasSecure(): boolean | undefined {\r\n    return this.isSecure;\r\n  }\r\n\r\n  getChildren(): React.ReactNode | undefined {\r\n    return this.children;\r\n  }\r\n\r\n  getCustomInputFieldElement(): React.ReactNode | undefined {\r\n    return this.customInputFieldElement;\r\n  }\r\n\r\n  getProps(): Record<string, any> | undefined {\r\n    return this.props;\r\n  }\r\n\r\n  /**\r\n   * Get the field value\r\n   * @returns\r\n   */\r\n  getValue(): any {\r\n    return this.props?.value;\r\n  }\r\n\r\n  /** SETTER */\r\n\r\n  /**\r\n   * Set the field name\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setName(value: string): this {\r\n    this.inputName = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the field label\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setLabel(value: string): this {\r\n    this.label = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the field placeholder\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setPlaceholder(value: string): this {\r\n    this.placeholder = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the field default value\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setDefaultValues(value: any): this {\r\n    this.defaultValues = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * set if the field is disabled\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setDisabled(value: boolean): this {\r\n    this.disabled = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the field zod object\r\n   * @param value\r\n   * @returns\r\n   */\r\n  setValidation(value: ZodType<any, ZodTypeDef, any>): this {\r\n    this.zodObject = value;\r\n    return this;\r\n  }\r\n}\r\n",
  "/ReactFormMaker/FormFields/Class/FieldFactory/README.MD": "# FieldFactory Class\r\n\r\n## Propriétés de la classe `FieldFactory`\r\n\r\n| Attribut          | Type                                               | Requis    | Description                                                                                                                                                       |\r\n| ----------------- | -------------------------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `inputName`       | `string`                                           | Requis    | Le nom du champ d'entrée. C'est la clé de l'objet retourné lorsque le formulaire est soumis.                                                                      |\r\n| `label`           | `string`                                           | Optionnel | Le label du champ d'entrée, affiché au-dessus du champ pour des raisons d'accessibilité.                                                                          |\r\n| `placeholder`     | `string`                                           | Optionnel | Le texte du placeholder affiché à l'intérieur du champ lorsqu'il est vide. Pertinent pour les types d'entrée comme texte, mot de passe, textarea, date et nombre. |\r\n| `inputType`       | `string`                                           | Requis    | Le type du champ d'entrée à afficher.                                                                                                                             |\r\n| `zodObject`       | `ZodType<any>`                                     | Optionnel | L'objet Zod utilisé pour valider le champ d'entrée. Recommandé pour une validation type-safe. [Plus d'infos](https://zod.dev/?id=primitives).                     |\r\n| `defaultValues`   | `any`                                              | Optionnel | Les valeurs par défaut affichées dans le champ d'entrée.                                                                                                          |\r\n| `options`         | `string[]` ou `{ value: string; label: string }[]` | Optionnel | Options pour les types d'entrée `select`, `radio` ou `checkbox`. Requis si le type d'entrée est l'un de ceux-ci.                                                  |\r\n| `className`       | `string`                                           | Optionnel | La classe CSS pour styliser le champ d'entrée en utilisant Tailwind CSS. [Plus d'infos](https://tailwindcss.com/).                                                |\r\n| `disabled`        | `boolean`                                          | Optionnel | Désactive le champ d'entrée lorsqu'il est vrai.                                                                                                                   |\r\n| `fields`          | `(extended CompositeField)[]`                      | Optionnel | Composants enfants affichés dans le champ d'entrée.                                                                                                               |\r\n| `isDiv`           | `boolean`                                          | Optionnel | Si vrai, rend le fieldset comme un `<div>` au lieu d'un `<fieldset>` sémantique.                                                                                  |\r\n| `legend`          | `string`                                           | Optionnel | La légende du champ d'entrée affichée comme le titre du fieldset.                                                                                                 |\r\n| `legendClassName` | `string`                                           | Optionnel | La classe CSS pour styliser la légende en utilisant Tailwind CSS.                                                                                                 |\r\n| `description`     | `string`                                           | Optionnel | Le texte de description affiché avec le champ d'entrée.                                                                                                           |\r\n| `isSecure`        | `boolean`                                          | Optionnel | Cache le champ d'entrée pour des raisons de sécurité lorsqu'il est vrai.                                                                                          |\r\n\r\n## Constructeur\r\n\r\n```typescript\r\nconstructor(name: string, entries?: Partial<T>) {\r\n  this.inputName = createNoSpacesString(name);\r\n  if (entries) Object.assign(this, entries);\r\n}\r\n```\r\n",
  "/ReactFormMaker/FormFields/Class/Fieldset.class.ts": "import {\r\n  DividerReactFormMaker,\r\n  FieldReactFormMaker,\r\n  ReactFormMakerFieldset,\r\n} from '../../interfaces/FieldInterfaces';\r\nimport { isCompositeField } from '../../utils/typeGuards/compositeField.TypeGuards';\r\nimport Field from './FieldFactory/FieldFactory.class';\r\nimport { TextField } from './TextFields.class';\r\n\r\ntype includedField =\r\n  | FieldReactFormMaker\r\n  | DividerReactFormMaker\r\n  | ReactFormMakerFieldset\r\n  | includedField[];\r\n\r\n/**\r\n * **FieldSet class**: This class is used to create a fieldset in a form.\r\n *\r\n * ---\r\n * *This class helps to formalize and structure a configuration for using React Form Macker, with an abstraction layer that facilitates use.*\r\n *\r\n * ---\r\n *\r\n * * @example\r\n *\r\n * ```ts\r\n *\r\n * const login = new Field('login').text();\r\n * const password = new Field('password').password();\r\n *\r\n *\r\n * const fieldset = new FieldSet(\r\n *    'login', //name of the fieldset\r\n *    { // Simple configuration of the fieldset\r\n *      legend: 'Login',\r\n *      className: 'w-full flex flex-col gap-4',\r\n *      legendClassName: 'text-lg font-bold',\r\n *    },\r\n *    [login, password] // Fields of the fieldset\r\n * )\r\n *\r\n * ```\r\n *\r\n * ---\r\n * * @param formName - The name of the fieldset.\r\n * * @param entries - The configuration of the fieldset.\r\n * * @param fields - The fields of the fieldset.\r\n *\r\n * ---\r\n *\r\n * @Advanced\r\n *\r\n * *You can use a Fasted div on horizontal mode to create a divider between fields. The divider is a field that contains other fields. You can use it to group fields together.*\r\n *\r\n * ```ts\r\n *\r\n * const login = new Field('login').text();\r\n * const password = new Field('password').password();\r\n * const firstName = new Field('firstName').text();\r\n * const lastName = new Field('lastName').text();\r\n *\r\n * const fieldset = new FieldSet(\r\n *   'register', //name of the fieldset\r\n *  {},\r\n *  [ login, [ firstName, lastName ], password ] // Fields of the fieldset : lastName and firstName are grouped together in a divider in a horizontal mode\r\n *\r\n *\r\n */\r\nexport default class FieldSet<T extends Partial<ReactFormMakerFieldset>> {\r\n  fieldset: string = '';\r\n  legend?: string;\r\n  legendClassName?: string;\r\n  className?: string;\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  isHide?: boolean;\r\n\r\n  constructor(formName: string, entries: T, fields: includedField[]) {\r\n    this.fieldset = formName;\r\n    if (entries) Object.assign(this, entries);\r\n    this.fields = fields.map((entry) => this.parseIncludedField(entry));\r\n  }\r\n\r\n  private parseIncludedField(\r\n    entries: includedField[] | includedField,\r\n  ): FieldReactFormMaker | DividerReactFormMaker | ReactFormMakerFieldset {\r\n    if (!Array.isArray(entries)) {\r\n      return entries;\r\n    }\r\n\r\n    let newDivider = {\r\n      isDiv: true,\r\n      className: 'w-full flex gap-4 justify-between',\r\n      fields: [],\r\n    } as DividerReactFormMaker;\r\n\r\n    entries.forEach((entry) => {\r\n      if (!entry) return;\r\n      newDivider.fields\r\n        ? newDivider.fields.push(this.parseIncludedField(entry))\r\n        : (newDivider.fields = [this.parseIncludedField(entry)]);\r\n    });\r\n\r\n    return newDivider;\r\n  }\r\n\r\n  public setConfig(config: Partial<T>): this {\r\n    Object.assign(this, config);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Define the legend of the fieldset**\r\n   * @param legend\r\n   * @returns\r\n   */\r\n  public setLegend(legend: string): this {\r\n    this.legend = legend;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Define the class of the legend**\r\n   * @param legendClassName\r\n   * @returns\r\n   */\r\n  public legendClass(legendClassName: string): this {\r\n    this.legendClassName = legendClassName;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * **Define the class of the fieldset**\r\n   * @param className\r\n   * @returns\r\n   */\r\n  public class = (className: string): this => {\r\n    this.className = className;\r\n    return this;\r\n  };\r\n}\r\n",
  "/ReactFormMaker/FormFields/Class/TextFields.class.ts": "import Field from './FieldFactory/FieldFactory.class';\r\nimport {\r\n  FieldReactFormMaker,\r\n  ReactFormMakerFieldset,\r\n} from '../../interfaces/FieldInterfaces';\r\nimport { z } from 'zod';\r\nimport { FormFieldEvent } from '../../interfaces/FormFieldEvent';\r\n\r\nexport class TextField extends Field<FieldReactFormMaker> {\r\n  constructor(name: string, config?: Partial<FieldReactFormMaker>) {\r\n    super(name);\r\n\r\n    this.text();\r\n    if (config) {\r\n      const currentConfig = this.getConfig();\r\n      this.setConfig({ ...currentConfig, ...config });\r\n    }\r\n    return this;\r\n  }\r\n\r\n  useRegex(regex: RegExp): this {\r\n    if (!this.zodObject) {\r\n      console.warn('You must set a zod object before using this method');\r\n      return this;\r\n    }\r\n    this.zodObject = this.zodObject.refine((data) => regex.test(data), {\r\n      message: 'Invalid input',\r\n    });\r\n    return this;\r\n  }\r\n\r\n  isEmail(): this {\r\n    if (!this.zodObject) {\r\n      this.zodObject;\r\n    }\r\n    this.setPlaceholder('Email');\r\n    this.zodObject = z.string().email({\r\n      message: 'Invalid email',\r\n    });\r\n    return this;\r\n  }\r\n\r\n  isUrl(): this {\r\n    if (!this.zodObject) {\r\n      this.zodObject;\r\n    }\r\n\r\n    this.zodObject = z.string().url({\r\n      message: 'Invalid url',\r\n    });\r\n\r\n    this.onSelect = (e: FormFieldEvent) => {\r\n      if (!e.target.value) {\r\n        e.target.value = 'https://';\r\n      }\r\n    };\r\n    return this;\r\n  }\r\n\r\n  isPassword(): this {\r\n    this.password();\r\n    this.setPlaceholder('********');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a second fieldText to confirm the password.\r\n   *\r\n   * This method is used to create a password confirmation field.\r\n   *\r\n   * /!\\ You must call this method after calling `password()` to set the zodObject.\r\n   * @returns\r\n   */\r\n  confirmPassword(\r\n    config?: Partial<Omit<FieldReactFormMaker, 'inputName'>>,\r\n  ): Field<FieldReactFormMaker> {\r\n    if (!this.zodObject) {\r\n      this.zodObject;\r\n    }\r\n    if (!this.inputType || this.inputType !== 'password') {\r\n      throw new Error(\r\n        'You must call password() before calling confirmPassword()',\r\n      );\r\n    }\r\n\r\n    //this.Children(ConfirmPasswordField);\r\n\r\n    const initialPasswordField = this.getConfig();\r\n\r\n    /**\r\n     * config?: Partial<FieldReactFormMaker>\r\n     */\r\n    const defaultconfig: FieldReactFormMaker = {\r\n      inputName: 'confirmPassword',\r\n      className: 'form-input',\r\n      placeholder: '*********',\r\n      inputType: 'password',\r\n      zodObject: z.string(),\r\n    };\r\n\r\n    const newField = new Field(`passwordWrapper`, {\r\n      isDiv: true,\r\n      className: 'flex flex-col',\r\n      fields: [\r\n        initialPasswordField as FieldReactFormMaker,\r\n        {\r\n          ...defaultconfig,\r\n          ...config,\r\n        },\r\n      ],\r\n    });\r\n    return newField;\r\n  }\r\n}\r\n",
  "/ReactFormMaker/FormFields/formfields.class.ts": "import { ReactFormMakerFieldset } from '../interfaces/FieldInterfaces';\r\n\r\nexport class FormFields {}\r\n",
  "/ReactFormMaker/hooks/useFormFieldsMap.tsx": "import React, { useCallback, useState } from 'react';\r\nimport {\r\n  CompositeField,\r\n  FieldReactFormMaker,\r\n} from '../interfaces/FieldInterfaces';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\r\nimport {\r\n  isDividerReactFormMaker,\r\n  isFieldReactFormMaker,\r\n  isReactFormMakerFieldset,\r\n} from '../utils/typeGuards/compositeField.TypeGuards';\r\nimport DivElementField from '../formElements/DivElementField';\r\nimport FormFieldElement from '../formElements/FormFieldElement';\r\nimport {\r\n  ControllerRenderProps,\r\n  FieldValues,\r\n  Path,\r\n  UseFormReturn,\r\n} from 'react-hook-form';\r\nimport InputComponent from '../formElements/InputComponent';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface UseFormFieldsMapReturn<T extends FieldValues> {\r\n  /**\r\n   * A memoized callback function that renders the `InputComponent` with the provided field parameters.\r\n   */\r\n  InpuTComponentCallBack: ({\r\n    zFields,\r\n    fieldProps,\r\n    indexField,\r\n  }: FieldParams<T>) => React.ReactElement<typeof InputComponent>;\r\n\r\n  /**\r\n   * **Generates an array of React elements or null based on the provided data fields.**\r\n   * - - -\r\n   * @param {CompositeField[]} dataField - An array of composite fields to be rendered.\r\n   * @returns {(React.JSX.Element | null)[]} An array of React elements or null.\r\n   *\r\n   * @callback FormFieldsMap\r\n   * - - -\r\n   * @example\r\n   * ``` javascript\r\n   * const fields = [\r\n   *   { type: 'divider', ... },\r\n   *   { type: 'field', ... }\r\n   * ];\r\n   * const renderedFields = FormFieldsMap(fields);\r\n   * ```\r\n   *  - - -\r\n   * @remarks\r\n   * - Uses `useState` to manage UUIDs for each field.\r\n   * - Uses `useEffect` to generate new UUIDs whenever `dataField` changes.\r\n   * - Renders different components based on the type of field.\r\n   * - Utilizes `isDividerReactFormMaker` and `isFieldReactFormMaker` to determine the type of field.\r\n   * - - -\r\n   * @see {@link uuidV4} for UUID generation.\r\n   * @see {@link DivElementField} for rendering divider elements.\r\n   * @see {@link FormFieldElement} for rendering form field elements.\r\n   */\r\n  FormFieldsMap: (dataField: CompositeField[]) => (React.ReactElement | null)[];\r\n\r\n  /**\r\n   * **Generates an array of Fieldset elements based on the provided form fields.**\r\n   * @param {CompositeField[]} formfields - An array of composite fields to be rendered.\r\n   * @returns {(React.JSX.Element | null)[]} An array of React elements or null.\r\n   *\r\n   * @callback FieldsetMap\r\n   * - - -\r\n   * @example\r\n   * ``` javascript\r\n   * const fields = [\r\n   *   { type: 'fieldset', ... },\r\n   *   { type: 'fieldset', ... }\r\n   * ];\r\n   * const renderedFields = FieldsetMap(fields);\r\n   * ```\r\n   *  - - -\r\n   * @remarks\r\n   * - Uses `useState` to manage UUIDs for each field.\r\n   * - Uses `useEffect` to generate new UUIDs whenever `formfields` changes.\r\n   * - Renders different components based on the type of field.\r\n   * - Utilizes `isReactFormMakerFieldset` to determine the type of field.\r\n   * - - -\r\n   * @see {@link uuidV4} for UUID generation.\r\n   */\r\n  FieldsetMap: (\r\n    formfields: CompositeField[],\r\n  ) => (React.ReactElement<'fieldset'> | null)[];\r\n}\r\n\r\nexport function useFormFieldsMap<T extends FieldValues>(\r\n  form: UseFormReturn<T>,\r\n): UseFormFieldsMapReturn<T> {\r\n  const InpuTComponentCallBack = useCallback(\r\n    ({\r\n      zFields,\r\n      fieldProps,\r\n      indexField,\r\n    }: FieldParams<T>): React.ReactElement<typeof InputComponent> => (\r\n      <InputComponent\r\n        zFields={zFields as ControllerRenderProps<T, Path<T>>}\r\n        fieldProps={fieldProps as FieldReactFormMaker}\r\n        indexField={indexField}\r\n      />\r\n    ),\r\n    [],\r\n  );\r\n\r\n  const FormFieldsMap = useCallback(\r\n    (dataField: CompositeField[]) => {\r\n      const uuids = useGenerateUUIDs<CompositeField>(dataField);\r\n\r\n      return dataField?.map((elementField: CompositeField, index) => {\r\n        if (isDividerReactFormMaker(elementField)) {\r\n          return (\r\n            <DivElementField\r\n              key={uuids ? uuids[index] : index}\r\n              elementField={elementField}\r\n              uuid={uuids[index]}\r\n              FormFieldsMap={FormFieldsMap}\r\n            />\r\n          );\r\n        }\r\n        if (isFieldReactFormMaker(elementField)) {\r\n          return (\r\n            <div role=\"form-field-element\" className=\"mb-4\" key={uuids[index]}>\r\n              <FormFieldElement<T>\r\n                elementField={elementField}\r\n                index={'FormFieldElement' + uuids[index] + index}\r\n                form={form}\r\n                InpuTComponentCallBack={InpuTComponentCallBack}\r\n              />\r\n            </div>\r\n          );\r\n        }\r\n        return null;\r\n      });\r\n    },\r\n    [form],\r\n  );\r\n\r\n  const FieldsetMap = useCallback(\r\n    (\r\n      formfields: CompositeField[],\r\n    ): (React.ReactElement<'fieldset'> | null)[] => {\r\n      const uuids = useGenerateUUIDs<CompositeField>(formfields);\r\n\r\n      return formfields.map((element, index) => {\r\n        if (isReactFormMakerFieldset(element)) {\r\n          return (\r\n            <fieldset\r\n              key={uuids ? 'fieldset' + uuids[index] : 'fieldset' + index}\r\n              className={cn({ hidden: element.isHide }, element.className)}\r\n            >\r\n              {element.legend && (\r\n                <legend\r\n                  key={uuids[index] + 'legend'}\r\n                  className={cn(\r\n                    'text-lg font-bold pb-3',\r\n                    element.legendClassName,\r\n                  )}\r\n                >\r\n                  {element.legend}\r\n                </legend>\r\n              )}\r\n              {FormFieldsMap(element.fields as FieldReactFormMaker[])}\r\n            </fieldset>\r\n          );\r\n        }\r\n        return null;\r\n      });\r\n    },\r\n    [FormFieldsMap],\r\n  );\r\n\r\n  return { InpuTComponentCallBack, FormFieldsMap, FieldsetMap };\r\n}\r\n",
  "/ReactFormMaker/hooks/useFormHandlers.hook.ts": "// hooks/useFormHandlers.ts\r\nimport {\r\n  SubmitHandler,\r\n  SubmitErrorHandler,\r\n  FieldErrors,\r\n  FieldValues,\r\n} from 'react-hook-form';\r\n\r\ninterface UserFormHandlerParams<T extends FieldValues> {\r\n  /**\r\n   * Function to be called when the form is submitted. This function will be called with the data or errors.\r\n   * @param data Represents the data of the form when the form is submitted.\r\n   * @param errors Represents the errors of the form when the form is submitted.\r\n   * @returns\r\n   */\r\n  onSubmit: (data: false | T, errors: false | FieldErrors<T>) => void;\r\n}\r\n\r\ninterface UseFormHandlersReturn<T extends FieldValues> {\r\n  /**\r\n   * Function to be called when the form is submitted.\r\n   * This is an abstraction to the `onSubmit` function provided by the user. Used with OnInvalid and OnValid, this twin function will call the user's `onSubmit` function with the data or errors.\r\n   * @param data\r\n   */\r\n  onValid: SubmitHandler<T>;\r\n  /**\r\n   * Function to be called when the form is submitted and has errors.\r\n   * @param errors\r\n   */\r\n  onInvalid: SubmitErrorHandler<T>;\r\n}\r\n\r\n/**\r\n * Custom hook that returns the `onValid` and `onInvalid` functions to be called when the form is submitted.\r\n * @param onSubmit - The function to be called when the form is submitted.\r\n * @returns\r\n */\r\nexport default function useFormHandlers<T extends FieldValues>({\r\n  onSubmit,\r\n}: UserFormHandlerParams<T>): UseFormHandlersReturn<T> {\r\n  const onValid: SubmitHandler<T> = (data: T) => {\r\n    onSubmit(data, false);\r\n  };\r\n\r\n  const onInvalid: SubmitErrorHandler<T> = (errors: FieldErrors<T>) => {\r\n    onSubmit(false, errors);\r\n  };\r\n\r\n  return { onValid, onInvalid };\r\n}\r\n",
  "/ReactFormMaker/hooks/useReactFormMaker.hook.ts": "'use client';\r\n\r\nimport { zodResolver } from '@hookform/resolvers/zod';\r\nimport {\r\n  DefaultValues,\r\n  FieldValues,\r\n  useForm,\r\n  UseFormReturn,\r\n} from 'react-hook-form';\r\nimport { z, ZodType, ZodObject, any } from 'zod';\r\nimport React from 'react';\r\nimport { CompositeField } from '../interfaces/FieldInterfaces';\r\nimport {\r\n  isDividerReactFormMaker,\r\n  isFieldReactFormMaker,\r\n  isReactFormMakerFieldset,\r\n} from '../utils/typeGuards/compositeField.TypeGuards';\r\n\r\ninterface UseFormGenReturn<T extends FieldValues> {\r\n  form: UseFormReturn<T>;\r\n  formSchema: ZodObject<{ [key in keyof T]: ZodType<T[key]> }>;\r\n  dataFieldsDefaultValues: { [key in keyof T]?: T[key] };\r\n  zObject: { [key in keyof T]: ZodType<T[key]> };\r\n  hasSubmitButton: (children: React.ReactNode) => boolean;\r\n}\r\n\r\nexport function useReactFormMaker<T extends FieldValues>(\r\n  formfieldsAttributes: CompositeField[],\r\n): UseFormGenReturn<T> {\r\n  const zObject: { [key in keyof T]: ZodType<T[key]> } = {} as {\r\n    [key in keyof T]: ZodType<T[key]>;\r\n  };\r\n  const dataFieldsDefaultValues: { [key in keyof T]?: T[key] } = {};\r\n\r\n  /**\r\n   * Recursively processes a field element and its nested fields, if any.\r\n   *\r\n   * @template T - The type of the form data.\r\n   * @param {FieldReactFormMaker} element - The field element to process.\r\n   *\r\n   * The function performs the following actions:\r\n   * - If the element contains nested fields, it iterates over each field.\r\n   * - For each nested field:\r\n   *   - If the field is a container (e.g., a div), it recursively calls `createField` on the field.\r\n   *   - If the field is not a container:\r\n   *     - If the field has a Zod schema object (`zodObject`), it adds it to the `zObject` map.\r\n   *     - If the field has default values (`defaultValues`), it adds them to the `dataFieldsDefaultValues` map.\r\n   */\r\n  function createField(element: CompositeField): void {\r\n    if (element.fields) {\r\n      const dataFields = element.fields;\r\n      if (dataFields && dataFields.length > 0) {\r\n        dataFields.forEach((field) => {\r\n          if (\r\n            isDividerReactFormMaker(field) ||\r\n            isReactFormMakerFieldset(field)\r\n          ) {\r\n            createField(field);\r\n          } else if (isFieldReactFormMaker(field)) {\r\n            if (field.zodObject !== undefined) {\r\n              zObject[field.inputName as keyof T] = field.zodObject as ZodType<\r\n                T[keyof T]\r\n              >;\r\n            }\r\n            if (field.defaultValues !== undefined) {\r\n              dataFieldsDefaultValues[field.inputName as keyof T] =\r\n                field.defaultValues as T[keyof T];\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  formfieldsAttributes.forEach((element: any) => {\r\n    createField(element);\r\n  });\r\n\r\n  let zodEffect: any = undefined;\r\n  let formSchema = z.object(zObject);\r\n\r\n  if ('confirmPassword' in zObject && 'password' in zObject) {\r\n    zodEffect = formSchema\r\n      .refine((data) => data.password === data.confirmPassword, {\r\n        message: 'Les mots de passe ne correspondent pas',\r\n        path: ['confirmPassword'],\r\n      })\r\n      .transform(({ confirmPassword, ...rest }) => rest);\r\n  }\r\n\r\n  const form = useForm<T>({\r\n    resolver: zodResolver(zodEffect || formSchema),\r\n    defaultValues: dataFieldsDefaultValues as DefaultValues<T>,\r\n    mode: 'all',\r\n  });\r\n\r\n  function hasSubmitButton(children: React.ReactNode): boolean {\r\n    return React.Children.toArray(children).some((child) => {\r\n      if (React.isValidElement(child)) {\r\n        if (child.props.type === 'submit') {\r\n          return true;\r\n        }\r\n        if (child.props.children) {\r\n          return hasSubmitButton(child.props.children);\r\n        }\r\n      }\r\n      return false;\r\n    });\r\n  }\r\n\r\n  return {\r\n    form,\r\n    formSchema,\r\n    dataFieldsDefaultValues,\r\n    zObject,\r\n    hasSubmitButton,\r\n  };\r\n}\r\n",
  "/ReactFormMaker/inputs/CheckboxInput.tsx": "import React from 'react';\r\nimport CheckboxWithText from '../enhancements/CheckboxWithText';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction CheckboxInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <CheckboxWithText\r\n      zFields={zFields}\r\n      fieldProps={fieldProps}\r\n      indexField={indexField}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(CheckboxInput);\r\n",
  "/ReactFormMaker/inputs/DateInput.tsx": "import React from 'react';\r\nimport DatePickerSimple from '../enhancements/DatePickerSimple';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction DateInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <DatePickerSimple\r\n      zFields={zFields}\r\n      fieldProps={fieldProps}\r\n      indexField={indexField}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(DateInput);\r\n",
  "/ReactFormMaker/inputs/DateRangeInput.tsx": "import React from 'react';\r\nimport { DateRangePicker } from '../enhancements/DateRangePicker';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction DateRangeInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <DateRangePicker\r\n      zFields={zFields}\r\n      fieldProps={fieldProps}\r\n      indexField={indexField}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(DateRangeInput);\r\n",
  "/ReactFormMaker/inputs/FileInput.tsx": "import React from 'react';\r\nimport { Input } from '@/components/ui/input';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction FileInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n  return (\r\n    <Input\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      type=\"file\"\r\n      placeholder={fieldProps.placeholder}\r\n      {...restZfields}\r\n      accept=\"image/*, application/pdf\"\r\n      onChange={(event) =>\r\n        onChange(event.target.files && event.target.files[0])\r\n      }\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(FileInput);\r\n",
  "/ReactFormMaker/inputs/FileUploaderInput.tsx": "import React from 'react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport DefaultFileUploader from '../enhancements/FileUploader/variants/DefaultFileUploader';\r\nimport { DropzoneOptions } from 'react-dropzone';\r\nimport { z } from 'zod';\r\n\r\nfunction isFile(obj: any): boolean {\r\n  return (\r\n    obj instanceof File ||\r\n    Object.prototype.toString.call(obj) === '[object File]'\r\n  );\r\n}\r\n\r\nfunction FileDropZone({ zFields, fieldProps, indexField }: FieldParams) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n\r\n  const exempleInstanceOfFileExemple = new File([], 'exemple.txt', {\r\n    type: 'text/plain',\r\n  });\r\n\r\n  const dropzoneOptions: DropzoneOptions = {\r\n    disabled: fieldProps.disabled,\r\n  };\r\n\r\n  // Filtrer les propriétés inexistantes\r\n  const filteredFieldProps = Object.fromEntries(\r\n    Object.entries(fieldProps).filter(([_, v]) => v !== undefined),\r\n  );\r\n\r\n  return (\r\n    <DefaultFileUploader\r\n      value={value}\r\n      onValueChange={onChange}\r\n      {...restZfields}\r\n      {...filteredFieldProps}\r\n      className={fieldProps.className}\r\n      dropzoneOptions={dropzoneOptions}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(FileDropZone);\r\n",
  "/ReactFormMaker/inputs/MultiSelectInput.tsx": "import React from 'react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\r\nimport {\r\n  MultiSelect,\r\n  MultiSelectParams,\r\n} from '../enhancements/MultiSelect/MultiSelect';\r\n\r\ninterface MultiSelectInputProps\r\n  extends FieldParams,\r\n    Partial<MultiSelectParams> {}\r\n\r\nfunction MultiSelectInput({ zFields, fieldProps }: MultiSelectInputProps) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n\r\n  if (!fieldProps.options) {\r\n    return null;\r\n  }\r\n\r\n  const serializedOptions = fieldProps.options.map((option) => {\r\n    if (isOption(option)) {\r\n      return option;\r\n    }\r\n    return { value: option, label: option };\r\n  });\r\n\r\n  return (\r\n    <MultiSelect\r\n      id={fieldProps.inputName}\r\n      onChange={onChange}\r\n      {...restZfields}\r\n      defaultValues={value ? value : fieldProps.defaultValues}\r\n      options={serializedOptions}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(MultiSelectInput);\r\n",
  "/ReactFormMaker/inputs/NumberInput.tsx": "import React from 'react';\r\nimport { Input } from '@/components/ui/input';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction NumberInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <Input\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      type=\"number\"\r\n      placeholder={fieldProps.placeholder}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(NumberInput);\r\n",
  "/ReactFormMaker/inputs/PasswordInput.tsx": "import React from 'react';\r\nimport InputPasswordVisibility from '../enhancements/InputPasswordVisibility';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction PasswordInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <InputPasswordVisibility\r\n      key={indexField}\r\n      zFields={zFields}\r\n      fieldProps={fieldProps}\r\n      indexField={indexField}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(PasswordInput);\r\n",
  "/ReactFormMaker/inputs/PhoneNumberInput.tsx": "import React from 'react';\r\nimport PhoneInput from '../enhancements/PhoneInput';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction PhoneNumberInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <PhoneInput\r\n      id={fieldProps.inputName}\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      placeholder={fieldProps.placeholder}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(PhoneNumberInput);\r\n",
  "/ReactFormMaker/inputs/RadioInput.tsx": "import React from 'react';\r\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\r\nimport { Label } from '@/components/ui/label';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport {\r\n  isOption,\r\n  Option,\r\n  useValueOption,\r\n} from '../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\nfunction RadioInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <RadioGroup\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      {...zFields}\r\n      onValueChange={zFields.onChange}\r\n    >\r\n      {fieldProps.options?.map((option: string | Option, index: number) => (\r\n        <div className=\"flex items-center space-x-2\" key={index}>\r\n          <RadioGroupItem\r\n            key={useValueOption(option)}\r\n            value={isOption(option) ? option.label : option}\r\n            id={isOption(option) ? option.label : option}\r\n          />\r\n          <Label htmlFor={isOption(option) ? option.label : option}>\r\n            {isOption(option) ? option.label : option}\r\n          </Label>\r\n        </div>\r\n      ))}\r\n    </RadioGroup>\r\n  );\r\n}\r\n\r\nexport default React.memo(RadioInput);\r\n",
  "/ReactFormMaker/inputs/SelectAutocompleteInput.tsx": "import React from 'react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { SelectAutocomplete } from '../enhancements/SelectAutocomplete';\r\nimport {\r\n  isOption,\r\n  mustBeArrayOfOptions,\r\n} from '../utils/typeGuards/optionsFields.TypeGuards';\r\n\r\nfunction SelectAutocompleteInput({\r\n  zFields,\r\n  fieldProps,\r\n  indexField,\r\n}: FieldParams) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n  const options = fieldProps.options;\r\n  if (!options) {\r\n    throw new Error(\r\n      `SelectAutocompleteInput: options must be an array of Option objects, received ${JSON.stringify(options)}`,\r\n    );\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <SelectAutocomplete\r\n      id={fieldProps.inputName}\r\n      defaultValue={fieldProps.defaultValues}\r\n      options={options}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(SelectAutocompleteInput);\r\n",
  "/ReactFormMaker/inputs/SelectInput.tsx": "import React from 'react';\r\nimport SelectSimple from '../enhancements/SelectSimple';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { FieldValues } from 'react-hook-form';\r\n\r\nfunction SelectInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <SelectSimple\r\n      zFields={zFields}\r\n      fieldProps={fieldProps}\r\n      indexField={indexField}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(SelectInput);\r\n",
  "/ReactFormMaker/inputs/SwitchInput.tsx": "import React from 'react';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { cn } from '../../../lib/utils';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction SwitchInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <Switch\r\n      key={indexField}\r\n      disabled={fieldProps.disabled}\r\n      className={cn(fieldProps.className)}\r\n      {...zFields}\r\n      checked={zFields.value}\r\n      onCheckedChange={(checked: boolean) => {\r\n        zFields.onChange(checked);\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(SwitchInput);\r\n",
  "/ReactFormMaker/inputs/TextareaInput.tsx": "import React from 'react';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction TextareaInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  return (\r\n    <Textarea\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      placeholder={fieldProps.placeholder}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(TextareaInput);\r\n",
  "/ReactFormMaker/inputs/TextInput.tsx": "import React from 'react';\r\nimport { Input } from '@/components/ui/input';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\n\r\nfunction TextInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n  if (value === undefined || value === null) {\r\n    zFields.value = '';\r\n  }\r\n  return (\r\n    <Input\r\n      id={fieldProps.inputName}\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      placeholder={fieldProps.placeholder}\r\n      {...zFields}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(TextInput);\r\n",
  "/ReactFormMaker/inputs/TileMultiselectorInput.tsx": "import React, { useEffect } from 'react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\r\nimport { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\r\nimport { z } from 'zod';\r\nimport TileMultiSelector, {\r\n  TileMultiSelectorProps,\r\n} from '../enhancements/TileSelector/TileMultiSelector';\r\n\r\ninterface TileMultiSelectorInputProps\r\n  extends FieldParams,\r\n    Partial<TileMultiSelectorProps> {}\r\n\r\nfunction TileMultiSelectorInput({\r\n  zFields,\r\n  fieldProps,\r\n  indexField,\r\n  ...restProps\r\n}: TileMultiSelectorInputProps) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n\r\n  if (!fieldProps.options) {\r\n    return null;\r\n  }\r\n  function valueExcludes(fieldProps: FieldReactFormMaker): string[] {\r\n    if (!fieldProps.options || !fieldProps.zodObject) {\r\n      return [];\r\n    }\r\n\r\n    const schema = fieldProps.zodObject;\r\n    let schemaValues: (string | number)[] = [];\r\n\r\n    if (schema instanceof z.ZodEnum) {\r\n      schemaValues = schema._def.values;\r\n    } else if (schema instanceof z.ZodUnion) {\r\n      schemaValues = schema._def.options.flatMap((option: any) =>\r\n        option instanceof z.ZodEnum ? option._def.values : [],\r\n      );\r\n    }\r\n\r\n    if (!schemaValues.length) {\r\n      return [];\r\n    }\r\n\r\n    return fieldProps.options.reduce<string[]>((acc, option) => {\r\n      const optionValue = isOption(option) ? option.label : option;\r\n      if (!schemaValues.includes(optionValue)) {\r\n        acc.push(optionValue);\r\n      }\r\n      return acc;\r\n    }, []);\r\n  }\r\n\r\n  return (\r\n    <TileMultiSelector\r\n      id={fieldProps.inputName}\r\n      onSelect={onChange}\r\n      onChange={onChange}\r\n      {...restZfields}\r\n      value={value}\r\n      defaultValue={fieldProps.defaultValues}\r\n      options={fieldProps.options}\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      legend={fieldProps.legend}\r\n      excludes={valueExcludes(fieldProps)}\r\n      {...restProps}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(TileMultiSelectorInput);\r\n",
  "/ReactFormMaker/inputs/TileSelectorInput.tsx": "import React from 'react';\r\nimport { FieldParams } from '../interfaces/FieldParams';\r\nimport TileSelector from '../enhancements/TileSelector/TileSelector';\r\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\r\nimport { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\r\nimport { z } from 'zod';\r\n\r\nfunction TileSelectorInput({ zFields, fieldProps, indexField }: FieldParams) {\r\n  const { value, onChange, ...restZfields } = zFields;\r\n\r\n  function testhandlerOnChange(value: string | number) {\r\n    onChange(value);\r\n  }\r\n  if (!fieldProps.options) {\r\n    return null;\r\n  }\r\n  function valueExcludes(fieldProps: FieldReactFormMaker): string[] {\r\n    if (!fieldProps.options || !fieldProps.zodObject) {\r\n      return [];\r\n    }\r\n\r\n    const schema = fieldProps.zodObject;\r\n    let schemaValues: string[] = [];\r\n\r\n    if (schema instanceof z.ZodEnum) {\r\n      schemaValues = schema._def.values;\r\n    } else if (schema instanceof z.ZodUnion) {\r\n      schemaValues = schema._def.options.flatMap((option: any) =>\r\n        option instanceof z.ZodEnum ? option._def.values : [],\r\n      );\r\n    }\r\n\r\n    if (!schemaValues.length) {\r\n      return [];\r\n    }\r\n\r\n    return fieldProps.options.reduce<string[]>((acc, option) => {\r\n      const optionValue = isOption(option) ? option.label : option;\r\n      if (\r\n        !schemaValues.includes(\r\n          isOption(optionValue) ? optionValue.label : optionValue,\r\n        )\r\n      ) {\r\n        acc.push(isOption(optionValue) ? optionValue.label : optionValue);\r\n      }\r\n      return acc;\r\n    }, []);\r\n  }\r\n\r\n  return (\r\n    <TileSelector\r\n      id={fieldProps.inputName}\r\n      onClick={testhandlerOnChange}\r\n      {...restZfields}\r\n      value={value}\r\n      defaultValue={fieldProps.defaultValues}\r\n      options={fieldProps.options}\r\n      className={fieldProps.className}\r\n      disabled={fieldProps.disabled}\r\n      key={indexField}\r\n      legend={fieldProps.legend}\r\n      excludes={valueExcludes(fieldProps)}\r\n    />\r\n  );\r\n}\r\n\r\nexport default React.memo(TileSelectorInput);\r\n",
  "/ReactFormMaker/interfaces/CustomInputFieldElementParams.ts": "import { ControllerRenderProps, FieldValues, Path } from 'react-hook-form';\r\nimport { FieldReactFormMaker } from './FieldInterfaces';\r\n\r\nexport interface CustomInputFieldElementParams<T extends FieldValues> {\r\n  zFields?: ControllerRenderProps<T, Path<T>>;\r\n  fieldProps?: FieldReactFormMaker;\r\n  index?: string;\r\n  props?: T;\r\n}\r\n",
  "/ReactFormMaker/interfaces/ElementField.ts": "import { FieldReactFormMaker } from './FieldInterfaces';\r\nimport { FormFieldEvent } from './FormFieldEvent';\r\n\r\nexport interface ElementField extends FieldReactFormMaker {\r\n  fields?: any;\r\n  field?: any;\r\n  isDiv?: boolean;\r\n  isHide?: boolean;\r\n  className?: string;\r\n  children?: React.ReactNode;\r\n  props?: Record<string, any>;\r\n  onBlur?: (event: FormFieldEvent) => void;\r\n  onFocus?: (event: FormFieldEvent) => void;\r\n  onChange?: (event: FormFieldEvent) => void;\r\n  onSelect?: (event: FormFieldEvent) => void;\r\n}\r\n",
  "/ReactFormMaker/interfaces/FieldInterfaces.ts": "import { ZodType } from 'zod';\r\nimport { UseFormReturn } from 'react-hook-form';\r\nimport { FormFieldEvent } from './FormFieldEvent';\r\nimport type { StepFormState } from '../formElements/Stepper/SteppersElements/StepperContext.interface';\r\n\r\nexport type InputType =\r\n  | 'text'\r\n  | 'password'\r\n  | 'select'\r\n  | 'selectAutocomplete'\r\n  | 'multiSelect'\r\n  | 'textarea'\r\n  | 'date'\r\n  | 'dateRange'\r\n  | 'radio'\r\n  | 'checkbox'\r\n  | 'switch'\r\n  | 'file'\r\n  | 'fileDropZone'\r\n  | 'number'\r\n  | 'custom'\r\n  | 'tileSelector'\r\n  | 'tileMultiSelector'\r\n  | 'phoneNumber';\r\n\r\n/**\r\n * @description **This is the interface for the ReactFormMaker component.**\r\n * _CompositeField is the main state of a type on which all object-specific interfaces whose purpose is to contain specific fields._\r\n *\r\n * _The use of this state implies that the functionality used to route the rendering of form fields probably involves a recursive approach._\r\n *\r\n * ---\r\n *\r\n * @param {string} classname The className for styling the field. We use Tailwind CSS to style the field. This is optional.\r\n * @param { FieldReactFormMake[] | DividerReactFormMaker [] | ReactFormMakerFieldset[]} fields The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional, but recommended for the fieldset.\r\n * @param {boolean} isHide Hide the composite field. If isHide is true, the composite field will be hidden. You can use it to hide the composite field for security purposes and use it with hook to show it.\r\n */\r\nexport interface CompositeField {\r\n  /**\r\n   * @description\r\n   * The className for styling the field.\r\n   * We use Tailwind CSS to style the field.\r\n   * This is optional.\r\n   */\r\n  classname?: string;\r\n  /**\r\n   * @description\r\n   * The children of the input field.\r\n   * This is the children of the input field that will be displayed.\r\n   * You can use it to display the children components inside the input field.\r\n   * This is optional, but recommended for the fieldset.\r\n   */\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  /**\r\n   * @description\r\n   * Hide the composite field. If isHide is true, the composite field will be hidden.\r\n   * You can use it to hide the composite field for security purposes and use it with hook to show it.\r\n   */\r\n  isHide?: boolean;\r\n}\r\n\r\n/**\r\n * @description\r\n * **This is an interface used in the ReactFormMaker component. **\r\n * _FieldReactFormMaker is the interface for form fields._\r\n *\r\n * ---\r\n *\r\n * ### Properties\r\n\r\n| Attribute                       | Type             | Required    | Description                                                                                                                                                  |\r\n|---------------------------------|------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `inputName`                     | `string`                                                                                 | Required    | *The name of the input field. This is the key of the object returned when the form is submitted.*                                                            |\r\n| `label`                         | `string`                                                                                 | Optional    | *The label of the input field, displayed above the input field for accessibility purposes.*                                                                  |\r\n| `placeholder`                   | `string`                                                                                 | Optional    | *The placeholder text displayed inside the input field when empty. Relevant for input types like text, password, textarea, date, and number.*                |\r\n| `inputType`                     | `string`                                                                                 | Required    | *The type of the input field to display.*                                                                                                                    |\r\n| `zodObject`                     | `ZodType<any>`                                                                           | Optional    | *The Zod object used to validate the input field. Recommended for type-safe validation. [More info](https://zod.dev/?id=primitives).*                        |\r\n| `defaultValues`                 | `any`                                                                                    | Optional    | *The default values displayed in the input field.*                                                                                                           |\r\n| `options`                       | `string[]` or `{ value: string; label: string }[]`                                       | Optional    | *Options for `select`, `radio`, or `checkbox` input types. Required if the input type is one of these.*                                                      |\r\n| `className`                     | `string`                                                                                 | Optional    | *The className for styling the input field using Tailwind CSS. [More info](https://tailwindcss.com/).*                                                        |\r\n| `disabled`                      | `boolean`                                                                                | Optional    | *Disables the input field when true.*                                                                                                                        |\r\n| `fields`                        | `(extended CompositeField)[]`              | Optional    | *Child components displayed within the input field.*                                                                                                         |\r\n| `isDiv`                         | `boolean`                                                                                | Optional    | *If true, renders the fieldset as a `<div>` instead of a semantic `<fieldset>`.*                                                                             |\r\n| `legend`                        | `string`                                                                                 | Optional    | *The legend of the input field displayed as the title of the fieldset.*                                                                                      |\r\n| `legendClassName`               | `string`                                                                                 | Optional    | *The className for styling the legend using Tailwind CSS.*                                                                                                   |\r\n| `description`                   | `string`                                                                                 | Optional    | *The description text displayed with the input field.*                                                                                                       |\r\n| `isSecure`                      | `boolean`                                                                                | Optional    | *Hides the input field for security purposes when true.*                                                                                                     |\r\n\r\n---\r\n\r\n### Events\r\n\r\n| Event               | Type                | Required    | Description                                                                                                                                                  |\r\n|---------------------|---------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `onBlur`            | `FormFieldEvent`   | Optional    | *Triggered on blur of the input field. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                     |\r\n| `onSelect`          | `FormFieldEvent`   | Optional    | *Triggered on focus of the input field. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                    |\r\n| `onChange`          | `FormFieldEvent`   | Optional    | *Triggered on input value change. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                         |\r\n\r\n\r\n---\r\n\r\n### JSX Elements\r\n\r\n| Attribute                    | Type                | Required    | Description                                                                                                                                                  |\r\n|------------------------------|---------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `children`                   | `React.ReactNode`  | Optional    | *Child components displayed within the input field.*                                                                                                         |\r\n| `customInputFieldElement`    | `React.ReactNode`  | Optional    | *Custom ReactNode used to render the input field. Must be a valid input field element for use with the `ReactFormMaker` component.*                          |\r\n\r\n---\r\n\r\n### Other Props\r\n\r\n| Attribute      | Type                  | Required    | Description                                                                                                                                                  |\r\n|----------------|-----------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `props`        | `Record<string, any>`| Optional    | *Additional props passed to the input field.*                                                                                                               |\r\n\r\n * ---\r\n * @extends CompositeField\r\n * @see {@link CompositeField}\r\n */\r\nexport interface FieldReactFormMaker extends CompositeField {\r\n  /**\r\n   * @description\r\n   * The name of the input field, is required.\r\n   * This is the key of the object that will be returned when the form is submitted.\r\n   */\r\n  inputName: string;\r\n  /**\r\n   * @description\r\n   * The label of the input field.\r\n   * This is the text that will be displayed above the input field.\r\n   * It is directly related to the inputName and inputType for the accessibility of the form.\r\n   * This is optional.\r\n   */\r\n  label?: string;\r\n  /**\r\n   * @description\r\n   * The placeholder of the input field.\r\n   * This is the text that will be displayed inside the input field when it is empty.\r\n   * Kinds of inputType: text, password, textarea, date, number can have a placeholder.\r\n   * This is optional.\r\n   */\r\n  placeholder?: string;\r\n  /**\r\n   * @description\r\n   * The type of the input field.\r\n   * This is the type of the input field that will be displayed.\r\n   * This is required.\r\n   */\r\n  inputType: InputType;\r\n  /**\r\n   * @description\r\n   * The Zod object of the input field.\r\n   * This is the Zod object that will be used to validate the input field.\r\n   * This is optional but recommended.\r\n   * You can read more about Zod here: https://zod.dev/?id=primitives\r\n   * We use the Zod object to validate the input field and to return the object with the correct types.\r\n   * If you don't provide a Zod object, the input field will be validated with the default values.\r\n   */\r\n  zodObject?: ZodType;\r\n  /**\r\n   * @description\r\n   * The default values of the input field.\r\n   * This is the default value that will be displayed in the input field.\r\n   * This is optional.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  defaultValues?: any;\r\n  /**\r\n   * @description\r\n   * The options of the input field for the select, radio, and checkbox input types.\r\n   * If the inputType is select, radio, or checkbox, you need to provide the options.\r\n   * Will Be changed to options: string[] | { value: string; label: string }[]; in the future.\r\n   */\r\n  options?: string[] | { value: string | number; label: string }[];\r\n  /**\r\n   * @description\r\n   * The className of the input field.\r\n   * This is the className of the input field that will be displayed.\r\n   * We use Tailwind CSS to style the input field.\r\n   * If you want read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  className?: string;\r\n  /**\r\n   * @description\r\n   * **Disabled the input field.**\r\n   *\r\n   * This is the boolean that will be used to disable the input field.\r\n   *\r\n   * _This is optional._\r\n   */\r\n  disabled?: boolean;\r\n  /**\r\n   * @description\r\n   * The children of the input field.\r\n   * This is the children of the input field that will be displayed.\r\n   * You can use it to display the children components inside the input field.\r\n   * This is optional.\r\n   */\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  /**\r\n   * @description\r\n   * This bollean is used to declare this fieldset as a div.\r\n   * If isDiv is true, the fieldset will be a div and have no semantic meaning.\r\n   * You can use it to group the fields in a div for styling purposes.\r\n   * This is optional.\r\n   */\r\n  isDiv?: boolean;\r\n  /**\r\n   * @description\r\n   * The legend of the input field.\r\n   * This is the legend of the fieldset that will be displayed.\r\n   * This is optional.\r\n   */\r\n  legend?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the fieldset.\r\n   * We use Tailwind CSS to style the fieldset.\r\n   * This is optional.\r\n   */\r\n  legendClassName?: string;\r\n  /**\r\n   * @description\r\n   * The description of the input field.\r\n   * This is the description of the input field that will be displayed.\r\n   * This is optional.\r\n   */\r\n  description?: string;\r\n  /**\r\n   * @description\r\n   * IsSecure is used to hide the input field.\r\n   * If isSecure is true, the input field will be hidden.\r\n   * You can use it to hide the input field for security purposes.\r\n   * This is optional.\r\n   */\r\n  isSecure?: boolean;\r\n  /**\r\n   * @description\r\n   * The onBlur event of the input field.\r\n   * This is the onBlur event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * This is optional.\r\n   */\r\n  onBlur?: (event: FormFieldEvent) => void;\r\n  /**\r\n   * @description\r\n   * The onFocus event of the input field.\r\n   * This is the onFocus event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * This is optional.\r\n   */\r\n  onSelect?: (event: FormFieldEvent) => void;\r\n  /**\r\n   * @description\r\n   * The onChange event of the input field.\r\n   * This is the onChange event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * This is optional.\r\n   * You can use it to trigger the onChange event of the input field.\r\n   */\r\n  onChange?: (event: FormFieldEvent) => void;\r\n\r\n  /**\r\n   * @description\r\n   *\r\n   * The onClick event of the input field.\r\n   * This is the onClick event of the input field that will be triggered.\r\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\r\n   * This is optional.\r\n   * You can use it to trigger the onClick event of the input field.\r\n   * @param event\r\n   * @returns\r\n   */\r\n  onClick?: (event: FormFieldEvent) => void;\r\n  /**\r\n   * @description\r\n   * This is way to add a custom component or Element to the field.\r\n   * If you want to add a custom component or Element to the field, you can use this prop.\r\n   * The Children will be displayed under the input field.\r\n   * This is optional.\r\n   */\r\n  children?: React.ReactNode;\r\n  /**\r\n   * @description\r\n   * The customInputFieldElement of the input field.\r\n   * This is the customInputFieldElement is a ReactNode that will be displayed.\r\n   * The difference between children and customInputFieldElement is that customInputFieldElement will be used by the ReactFormMaker component to display the input field.\r\n   * This Element must be a valid input field element for the ReactFormMaker component.\r\n   * This is optional.\r\n   */\r\n  customInputFieldElement?: React.ReactNode;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  props?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * @description\r\n * **This is the interface for the ReactFormMaker component.**\r\n * _DividerReactFormMaker is the interface for the divider in the form._\r\n *\r\n * ### Usage\r\n *\r\n * You can use this interface on an object that is part of your form's reading continuation. Its declaration allows the program to continue assigning zodObjects to the form. It also allows you to declare useful separations, so you can take control of the user interface and compose your form more freely.\r\n *\r\n * ### Properties\r\n *\r\n * @param {boolean} isDiv This bollean is used to declare this fieldset as a div. If isDiv is true, the fieldset will be a div and have no semantic meaning. You can use it to group the fields in a div for styling purposes. This is optional.\r\n * @param {string} className The className for styling the fieldset. We use Tailwind CSS to style the fieldset. This is optional.\r\n * @param {boolean} isHide Hide the fieldset. If isHide is true, the fieldset will be hidden. You can use it to hide the fieldset for security purposes and use it with hook to show it. This is optional.\r\n * @param {FieldReactFormMaker[] | DividerReactFormMaker[] | ReactFormMakerFieldset[]} fields The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional.\r\n *\r\n * ### JSX Elements\r\n *\r\n * @param {JSX.Element} children The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field.\r\n *  _This is optional._\r\n *\r\n * ---\r\n *\r\n * @extends CompositeField\r\n * @see {@link CompositeField}\r\n */\r\nexport interface DividerReactFormMaker extends CompositeField {\r\n  /**\r\n   * @description\r\n   * This bollean is used to declare this fieldset as a div.\r\n   * If isDiv is true, the fieldset will be a div and have no semantic meaning.\r\n   * You can use it to group the fields in a div for styling purposes.\r\n   */\r\n  isDiv: boolean;\r\n  /**\r\n   * @description\r\n   * The className for styling the fieldset.\r\n   * We use Tailwind CSS to style the fieldset.\r\n   * This is optional.\r\n   */\r\n  className?: string;\r\n  /**\r\n   * @description\r\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\r\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\r\n   * This is optional.\r\n   */\r\n  isHide?: boolean;\r\n  /**\r\n   * @description\r\n   * The legend of the input field.\r\n   * This is the legend of the fieldset that will be displayed.\r\n   * This is optional.\r\n   */\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  /**\r\n   * @description\r\n   * The legend of the input field.\r\n   * This is the legend of the fieldset that will be displayed.\r\n   * This is optional.\r\n   */\r\n  children?: JSX.Element;\r\n}\r\n\r\n/**\r\n * @description\r\n * This is the interface for the ReactFormMaker component.\r\n * ReactFormMakerFieldset is the interface for the fieldset in the form.\r\n * We need to use it in the ReactFormMakerParams interface to define the fieldset of the form.\r\n * The ReactFormMakerParams interface is used to define the props of the ReactFormMaker component.\r\n * Is a recursive interface that can have children fields.\r\n *\r\n * ---\r\n *\r\n * ## Properties\r\n *\r\n * ### Usage\r\n * \r\n * | Attribute           | Type                                                                                                                                         | Required    | Description                                                                                                   |\r\n|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------|-------------|---------------------------------------------------------------------------------------------------------------|\r\n| `fieldset`          | `string`                                                                                                                                     | Required    | *The fieldset of the form. This is the fieldset of the form that will be displayed.*                          |\r\n| `legend`            | `string`                                                                                                                                     | Optional    | *The legend of the input field. This is the title of the fieldset that will be displayed.*                    |\r\n| `legendClassName`   | `string`                                                                                                                                     | Optional    | *The className for styling the legend, using Tailwind CSS. [More info](https://tailwindcss.com/).*            |\r\n| `className`         | `string`                                                                                                                                     | Optional    | *The className for styling the fieldset, using Tailwind CSS. [More info](https://tailwindcss.com/).*          |\r\n| `description`       | `string`                                                                                                                                     | Optional    | *The description of the input field that will be displayed.*                                                 |\r\n| `fields`            | (`FieldReactFormMaker` or `DividerReactFormMaker` or `ReactFormMakerFieldset`)[]                                                                 | Optional    | *The fields of the form that will be displayed.*                                                             |\r\n| `isHide`            | `boolean`                                                                                                                                    | Optional    | *Hides the fieldset. If true, the fieldset will be hidden, useful for security purposes when combined with hooks.* |\r\n * \r\n * ---\r\n * \r\n * @extends CompositeField\r\n * @see {@link CompositeField} For more information about the CompositeField interface.\r\n * \r\n * ---\r\n * \r\n * @see {@link FieldReactFormMaker} \r\n * @see {@link DividerReactFormMaker}\r\n * @see {@link ReactFormMakerStep}\r\n */\r\nexport interface ReactFormMakerFieldset extends CompositeField {\r\n  /**\r\n   * @description\r\n   * The fieldset of the form.\r\n   * This is the fieldset of the form that will be displayed.\r\n   * This is required.\r\n   */\r\n  fieldset: string;\r\n  /**\r\n   * @description\r\n   * The legend of the input field.\r\n   * This is the legend of the fieldset that will be displayed.\r\n   * This is optional.\r\n   * You can use it to display the legend of the fieldset.\r\n   * The legend is the title of the fieldset.\r\n   */\r\n  legend?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the legend.\r\n   * We use Tailwind CSS to style the legend.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  legendClassName?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the fieldset.\r\n   * We use Tailwind CSS to style the fieldset.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  className?: string;\r\n  /**\r\n   * @description\r\n   * The description of the input field.\r\n   * This is the description of the input field that will be displayed.\r\n   * This is optional.\r\n   */\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  /**\r\n   * @description\r\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\r\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\r\n   * This is optional.\r\n   */\r\n  isHide?: boolean;\r\n}\r\n\r\n/**\r\n * @description **This is the interface for the ReactFormMaker component.**\r\n * ReactFormMakerStep is the interface for the steps in the form. We need to use it in the ReactFormMakerParams interface to define the steps of the form.\r\n *\r\n * ---\r\n *\r\n * ### Properties\r\n *\r\n * @param {string} stepName The stepName of the form. This is the stepName of the form that will be displayed. This is required.\r\n * @param {boolean} isStep Define the fieldset as a step of Stepper. If isStep is true, the fieldset will be a step of Stepper.\r\n * @param {string} legend The legend of the input field. This is the legend of the fieldset that will be displayed. This is optional. You can use it to display the legend of the fieldset. The legend is the title of the fieldset.\r\n * @param {string} legendClassName The className for styling the legend. We use Tailwind CSS to style the legend. If you want to read more about Tailwind CSS here: https://tailwindcss.com/ This is optional.\r\n * @param {string} className The className for styling the fieldset. We use Tailwind CSS to style the fieldset. If you want to read more about Tailwind CSS here: https://tailwindcss.com/ This is optional.\r\n * @param {string} description The description of the input field. This is the description of the input field that will be displayed. This is optional.\r\n * @param {FieldReactFormMaker[]} fields The fields of the form. This is the fields of the form that will be displayed. This is optional. You can use it to display the fields of the form.\r\n * @param {boolean} isHide Hide the fieldset. If isHide is true, the fieldset will be hidden. You can use it to hide the fieldset for security purposes and use it with hook to show it. This is optional.\r\n * @param {boolean} disabledBefore disabledBefore is used to define if button before the current step is disabled. If disabledBefore is true, the button before the current step is disabled and cannot be clicked. disabledBefore disabled possibility to go back to any previous step in the stepper header and the stepper footer. False by default. This is optional.\r\n * @param {boolean} isStrict IsStrict is used to define if the step is strict. If isStrict is true, the step will be strict and the user cannot go to the next step without filling the current step. If any validation of zod is invalid, the user cannot go to the next step. False by default. This is optional.\r\n *\r\n * ### Events\r\n *\r\n * ### JSX Elements\r\n *\r\n * @param {React.ReactNode} children The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional.\r\n *\r\n * ---\r\n *\r\n * @extends CompositeField\r\n * @see {@link CompositeField}\r\n */\r\nexport interface ReactFormMakerStep extends CompositeField {\r\n  /**\r\n   * @description\r\n   * The stepName of the form.\r\n   * This is the stepName of the form that will be displayed.\r\n   * This is required.\r\n   */\r\n  stepName: string;\r\n  /**\r\n   * @description\r\n   * isStep Define the fieldset as a step of Stepper.\r\n   * If isStep is true, the fieldset will be a step of Stepper.\r\n   */\r\n  isStep?: boolean;\r\n  /**\r\n   * @description\r\n   * The legend of the input field.\r\n   * This is the legend of the fieldset that will be displayed.\r\n   * This is optional.\r\n   * You can use it to display the legend of the fieldset.\r\n   * The legend is the title of the fieldset.\r\n   */\r\n  legend?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the legend.\r\n   * We use Tailwind CSS to style the legend.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  legendClassName?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the fieldset.\r\n   * We use Tailwind CSS to style the fieldset.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  className?: string;\r\n  /**\r\n   * @description\r\n   * The description of the input field.\r\n   * This is the description of the input field that will be displayed.\r\n   * This is optional.\r\n   */\r\n  fields?: (\r\n    | FieldReactFormMaker\r\n    | DividerReactFormMaker\r\n    | ReactFormMakerFieldset\r\n  )[];\r\n  /**\r\n   * @description\r\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\r\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\r\n   * This is optional.\r\n   */\r\n  isHide?: boolean;\r\n\r\n  /**\r\n   * @description\r\n   * The children of the input field.\r\n   * This is the children of the input field that will be displayed.\r\n   * You can use it to display the children components inside the input field.\r\n   * This is optional.\r\n   */\r\n  children?: React.ReactNode;\r\n\r\n  /**\r\n   * @description\r\n   * disabledBefore is used to define if button before the current step is disabled.\r\n   * If disabledBefore is true, the button before the current step is disabled and cannot be clicked.\r\n   * disabledBefore disabled possibility to go back to any previous step in the stepper header and the stepper footer.\r\n   * False by default.\r\n   */\r\n  disabledBefore?: boolean;\r\n\r\n  /**\r\n   * @description\r\n   * IsStrict is used to define if the step is strict.\r\n   * If isStrict is true, the step will be strict and the user cannot go to the next step without filling the current step.\r\n   * If any validation of zod is invalid, the user cannot go to the next step.\r\n   * False by default.\r\n   * This is optional.\r\n   */\r\n  isStrict?: boolean;\r\n\r\n  /**\r\n   * @description\r\n   * onBeforeNextStep is used to define a function that will be executed before switching to the next step.\r\n   * This is optional.\r\n   * This function will be executed before switching to the next step and after the triggering of validation form when step is the current step.\r\n   *\r\n   * @param data The data of the form.\r\n   * @returns Promise<boolean> if true, the user can switch to the next step, if false, the user cannot switch to the next step.\r\n   */\r\n  onBeforeNextStep?: (data: {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    submissionState: StepFormState<any>;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    form: UseFormReturn<any>;\r\n  }) => Promise<boolean>;\r\n\r\n  /**\r\n   * @description\r\n   * **Componenent for Icon of the step.**\r\n   *\r\n   * If IconStep is not provided, the step will have defaults icons depending on the step status.\r\n   * This is optional.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  IconStep?: React.ComponentType<any>;\r\n\r\n  /**\r\n   * @description\r\n   * change name of the button next\r\n   * this is optional\r\n   */\r\n  buttonNextContent?: string;\r\n\r\n  /**\r\n   * @description\r\n   * change name of the button previous\r\n   * tjhis is optional\r\n   */\r\n  buttonPreviousContent?: string;\r\n\r\n  /**\r\n   * @description\r\n   * **Add additional buttons to the step.**\r\n   * This is optional.\r\n   *\r\n   * This element jsx erith the context of the step.\r\n   * We can use it to add additional buttons to the step.\r\n   * This button will be displayed in the footer of the step after the button next and the button previous.\r\n   *\r\n   */\r\n  additionalButtons?: React.ReactNode;\r\n\r\n  /**\r\n   * @description\r\n   * **Add additionclassname stepper footer.**\r\n   * This is optional.\r\n   */\r\n  footerClassName?: string | string[];\r\n}\r\n",
  "/ReactFormMaker/interfaces/FieldParams.ts": "import { ClassValue } from 'clsx';\r\nimport { ControllerRenderProps, FieldValues, Path } from 'react-hook-form';\r\nimport { FieldReactFormMaker } from './FieldInterfaces';\r\n\r\n/**\r\n * @description\r\n * This is the interface for the ReactFormMaker component.\r\n * FieldParams is the interface for the props of the Field component.\r\n * We need to use it in the Field component to define the props of the Field component under the ReactFormMaker component.\r\n *\r\n * ### Attributes\r\n *\r\n * | Name     | isRequired | Type | Description |\r\n * |----------|------------|------|-------------|\r\n * | zFields  | true       | ControllerRenderProps<any, Path<any>> | The register of the input field. |\r\n * | fieldProps | true     | FieldReactFormMaker | The fieldProps of the input field. |\r\n * | indexField | true     | string | The indexField of the input field. |\r\n * | id | false          | string | id of the input field. |\r\n * | className | false    | ClassValue[] \\| string \\| undefined | This is the custom className of the input field that will be displayed. |\r\n *\r\n * ---\r\n *\r\n * #### Info about the attributes\r\n *\r\n * @see {@link ControllerRenderProps} for more details.\r\n * @see {@link FieldReactFormMaker} for more details.\r\n *\r\n * ##### ControllerRenderProps\r\n *\r\n * | Name     | isRequired | Type | Description |\r\n * |----------|------------|------|-------------|\r\n * | onChange | true       | (...event: any[]) => void | The onChange event of the input field. |\r\n * | onBlur   | true       | Noop | The onBlur event of the input field. |\r\n * | value    | true       | FieldPathValue<TFieldValues, TName> | The value of the input field. |\r\n * | disabled | false      | boolean | The disabled attribute of the input field. |\r\n * | name     | true       | TName | The name of the input field. |\r\n * | ref      | true       | RefCallBack | The ref of the input field. |\r\n *\r\n */\r\nexport interface FieldParams<T extends FieldValues> {\r\n  /**\r\n   * @description\r\n   * The register of the input field.\r\n   * This is the register of the input field that will be displayed.\r\n   * Is a representation of the input field in the form and interprets the input field of zodObject.\r\n   */\r\n  zFields: ControllerRenderProps<T, Path<T>>;\r\n  /**\r\n   * @description\r\n   * The fieldProps of the input field.\r\n   * This is the fieldProps of the field, which is the FieldReactFormMaker interface.\r\n   * We need to use it in the Field component to define the props of the Field component under the ReactFormMaker component.\r\n   * This is required.\r\n   */\r\n  fieldProps: FieldReactFormMaker;\r\n  /**\r\n   * @description\r\n   * The indexField of the input field.\r\n   * This is the indexField of the input field that will be displayed.\r\n   * This is required.\r\n   */\r\n  indexField: string;\r\n  /**\r\n   * @description\r\n   * id of the input field.\r\n   * Can be used to identify the input field. If not provided, the id will be generated automatically by the system.\r\n   */\r\n  id?: string;\r\n  /**\r\n   * @description\r\n   * This is the custom className of the input field that will be displayed.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  className?: ClassValue[] | string | undefined;\r\n}\r\n",
  "/ReactFormMaker/interfaces/FormFieldEvent.ts": "import {\r\n  ControllerRenderProps,\r\n  FieldValues,\r\n  Path,\r\n  UseFormReturn,\r\n} from 'react-hook-form';\r\n\r\n/**\r\n * @description\r\n * This is the interface for the ReactFormMaker component.\r\n * FormFieldEvent is the interface for the custom event of the input field.\r\n * FormFieldEnvent add the controlField and form attributes to the React.FocusEvent<HTMLInputElement> interface.\r\n * Also, we add form attribute to the React.FocusEvent<HTMLInputElement> interface to control the form directly from the event.\r\n */\r\nexport interface FormFieldEvent<T extends FieldValues = FieldValues>\r\n  extends React.FocusEvent<HTMLInputElement> {\r\n  controlField?: ControllerRenderProps<T, Path<T>>;\r\n  form?: UseFormReturn<T>;\r\n}\r\n",
  "/ReactFormMaker/interfaces/FormParams.ts": "import { FieldErrors, FieldValues } from 'react-hook-form';\r\nimport { CompositeField } from './FieldInterfaces';\r\n\r\n/**\r\n * @description\r\n * This is the interface for the ReactFormMaker component.\r\n * ReactFormMakerParams is the interface for the props of the ReactFormMaker component.\r\n */\r\nexport interface ReactFormMakerParams<T extends FieldValues> {\r\n  /**\r\n   * @description\r\n   * The fieldset of the form.\r\n   * This is the fieldset of the form that will be displayed.\r\n   * This is required.\r\n   */\r\n  formfields: CompositeField[];\r\n  /**\r\n   * @description\r\n   * The className for styling the form.\r\n   * We use Tailwind CSS to style the form.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  className?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the footer.\r\n   * We use Tailwind CSS to style the footer.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  footerClassName?: string;\r\n  /**\r\n   * @description\r\n   * The text of the submit button.\r\n   * This is the text of the submit button that will be displayed.\r\n   * This is optional.\r\n   */\r\n  btnTextSubmit?: string;\r\n  /**\r\n   * @description\r\n   * The className for styling the submit button.\r\n   * We use Tailwind CSS to style the submit button.\r\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\r\n   * This is optional.\r\n   */\r\n  btnSubmitClassName?: string;\r\n\r\n  /**\r\n   * @description\r\n   * The onSubmit event of the form.\r\n   * This is the onSubmit event of the form that will be triggered.\r\n   * We add the attribute data of type FormEvent<HTMLFormElement> to the event for controlling the form directly from the event.\r\n   * This is required.\r\n   * @param data\r\n   * @returns void\r\n   */\r\n  onSubmit: (data: T | false, errors: FieldErrors<T> | false) => void;\r\n\r\n  /**\r\n   * @description\r\n   * The children of the form.\r\n   * This is the children of the form that will be displayed.\r\n   * You can use it to display the children components inside the form.\r\n   * This is optional.\r\n   */\r\n  children?: React.ReactNode;\r\n  /**\r\n   * @description\r\n   * The setZodObject event of the form.\r\n   * This is the setZodObject event of the form that will be triggered.\r\n   * We add the attribute zObject of type { [key: string]: ZodType<any> } to the event for controlling the form directly from the event.\r\n   * You can just use Hook like useState<{ [key: string]: ZodType<unknown> }>({}); to get the Zod object. The System will set the Zod object to the state automatically.\r\n   * This is optional.\r\n   * @param zObject\r\n   * @returns void\r\n   * deprecated\r\n   */\r\n  // setZodObject?: (zObject: { [key in keyof T]: ZodType<T[key]> }) => void;\r\n\r\n  /**\r\n   * @description\r\n   * Stepper boolean value determines if the form will be displayed as a stepper.\r\n   * By default, the stepper is set to false.\r\n   * This is optional.\r\n   */\r\n  stepper?: boolean;\r\n\r\n  /**\r\n   * @description\r\n   * The orientation of the form, used when the stepper is set to true.\r\n   * This is the orientation of the form that will be displayed.\r\n   * This is optional.\r\n   */\r\n  orientation?: 'vertical' | 'horizontal';\r\n}\r\n",
  "/ReactFormMaker/ReactFormMaker.tsx": "'use client';\r\n\r\nimport { Button } from '@/components/ui/button';\r\nimport { Form } from '@/components/ui/form';\r\nimport { Slottable } from '@radix-ui/react-slot';\r\nimport React, { useCallback } from 'react';\r\nimport { FieldValues } from 'react-hook-form';\r\nimport { cn } from '@/lib/utils';\r\nimport { ReactFormMakerParams } from './interfaces/FormParams';\r\nimport mapChildrenWithForm from './formElements/mapChildrenWithForm';\r\nimport validateStepperFormFields from './utils/validators/formValidators';\r\nimport useFormHandlers from './hooks/useFormHandlers.hook';\r\nimport { useReactFormMaker } from './hooks/useReactFormMaker.hook';\r\nimport { useFormFieldsMap } from './hooks/useFormFieldsMap';\r\nimport StepperForm from './formElements/Stepper/StepperForm.componenent';\r\n\r\n/**\r\n * A React component for dynamically generating forms using a set of field definitions.\r\n * Supports both standard and stepper-based forms with customizable layouts and behaviors.\r\n *\r\n * @template T - A generic type extending `FieldValues` from React Hook Form.\r\n *\r\n * @param {ReactFormMakerParams<T>} props - The props for the ReactFormMaker component.\r\n * @param {FormField<T>[]} props.formfields - An array of form field definitions used to generate the form.\r\n * @param {string} [props.className] - Optional CSS class for the form container.\r\n * @param {string} [props.footerClassName='flex justify-end gap-4'] - Optional CSS class for the footer section.\r\n * @param {(data: T) => void} props.onSubmit - Callback function triggered on form submission with valid data.\r\n * @param {React.ReactNode} [props.children] - Optional children to be rendered inside the form.\r\n * @param {string} [props.btnTextSubmit='Submit'] - Text for the submit button.\r\n * @param {string} [props.btnSubmitClassName] - Optional CSS class for the submit button.\r\n * @param {boolean} [props.stepper=false] - Whether to render the form as a stepper.\r\n * @param {'horizontal' | 'vertical'} [props.orientation='horizontal'] - Orientation of the stepper form. Used only if `stepper` is true.\r\n *\r\n * @returns {JSX.Element} The rendered form component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const formfields = [\r\n *   { name: 'username', type: 'text', label: 'Username', validation: { required: true } },\r\n *   { name: 'password', type: 'password', label: 'Password', validation: { required: true } },\r\n * ];\r\n *\r\n * function handleSubmit(data: FieldValues) {\r\n *   console.log(data);\r\n * }\r\n *\r\n * <ReactFormMaker\r\n *   formfields={formfields}\r\n *   onSubmit={handleSubmit}\r\n *   className=\"custom-form\"\r\n *   btnTextSubmit=\"Login\"\r\n * />\r\n * ```\r\n */\r\nexport default function ReactFormMaker<T extends FieldValues>({\r\n  formfields,\r\n  className,\r\n  footerClassName = 'flex justify-end gap-4',\r\n  onSubmit,\r\n  // setZodObject, deprecated\r\n  children,\r\n  btnTextSubmit = 'Submit',\r\n  btnSubmitClassName,\r\n  stepper = false,\r\n  orientation = 'horizontal',\r\n}: ReactFormMakerParams<T>) {\r\n  const { form, zObject, hasSubmitButton } = useReactFormMaker<T>(formfields);\r\n  const { onValid, onInvalid } = useFormHandlers<T>({ onSubmit });\r\n  const { FormFieldsMap, FieldsetMap } = useFormFieldsMap<T>(form);\r\n  const mappedChildren = useCallback(\r\n    () => mapChildrenWithForm(children, form),\r\n    [children, form],\r\n  );\r\n  /** STEPPER FORM */\r\n  if (stepper) {\r\n    validateStepperFormFields(formfields, stepper);\r\n\r\n    return (\r\n      <Form {...form}>\r\n        <form\r\n          onSubmit={form.handleSubmit(onValid, onInvalid)}\r\n          className={cn(\r\n            ' flex flex-col gap-4 p-4 rounded-lg shadow-lg mx-auto mt-4 bg-white w-5/6 h-full min-h-80 overflow-hidden',\r\n            className,\r\n          )}\r\n        >\r\n          <StepperForm<T>\r\n            form={form}\r\n            formfields={formfields}\r\n            zObject={zObject}\r\n            orientation={orientation}\r\n            formFieldsMap={FormFieldsMap}\r\n          />\r\n        </form>\r\n      </Form>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Form {...form}>\r\n      <form\r\n        onSubmit={form.handleSubmit(onValid, onInvalid)}\r\n        className={className}\r\n      >\r\n        {FieldsetMap(formfields)}\r\n\r\n        <footer className={footerClassName}>\r\n          <Slottable>{mappedChildren()}</Slottable>\r\n          {!hasSubmitButton(children) && (\r\n            <Button type=\"submit\" className={btnSubmitClassName}>\r\n              {btnTextSubmit}\r\n            </Button>\r\n          )}\r\n        </footer>\r\n      </form>\r\n    </Form>\r\n  );\r\n}\r\n",
  "/ReactFormMaker/utils/typeGuards/compositeField.TypeGuards.ts": "import {\r\n  CompositeField,\r\n  DividerReactFormMaker,\r\n  FieldReactFormMaker,\r\n  ReactFormMakerFieldset,\r\n  ReactFormMakerStep,\r\n} from '../../interfaces/FieldInterfaces';\r\n\r\nexport function isCompositeField(element: unknown): element is CompositeField {\r\n  return (element as CompositeField).fields !== undefined;\r\n}\r\n\r\n/**\r\n * **Type guard function to check if a given element is of type `FieldReactFormMaker`.**\r\n * - - -\r\n * @param element - The element to check.\r\n * @returns {boolean} A boolean indicating whether the element is a `FieldReactFormMaker`.\r\n * is defined by the presence of the `inputName` property.\r\n */\r\nexport function isFieldReactFormMaker(\r\n  element: CompositeField,\r\n): element is FieldReactFormMaker {\r\n  return (element as FieldReactFormMaker).inputName !== undefined;\r\n}\r\n\r\n/**\r\n *  **Type guard function to check if a given element is of type `DividerReactFormMaker`.**\r\n * is defined by the presence of the `isDiv` property.\r\n * - - -\r\n * @param element - The element to check.\r\n * @returns {boolean} A boolean indicating whether the element is a `DividerReactFormMaker`.\r\n *\r\n */\r\nexport function isDividerReactFormMaker(\r\n  element: CompositeField,\r\n): element is DividerReactFormMaker {\r\n  return (element as DividerReactFormMaker).isDiv !== undefined;\r\n}\r\n\r\n/**\r\n *  **Type guard function to check if a given element is of type `ReactFormMakerFieldset`.**\r\n *  Is defined by the presence of the `fieldset` property.\r\n * - - -\r\n * @param element  - The element to check.\r\n * @returns {boolean} A boolean indicating whether the element is a `ReactFormMakerFieldset`.\r\n */\r\nexport function isReactFormMakerFieldset(\r\n  element: CompositeField,\r\n): element is ReactFormMakerFieldset {\r\n  return (element as ReactFormMakerFieldset).fieldset !== undefined;\r\n}\r\n\r\n/**\r\n *  ** Type guard function to check if a given element is of type `ReactFormMakerStep`.**\r\n *  Is defined by the presence of the `isStep` or `stepName` property.\r\n * - - -\r\n * @param element - The element to check.\r\n * @returns {boolean} A boolean indicating whether the element is a `ReactFormMakerStep`.\r\n */\r\nexport function isStepReactFormMaker(\r\n  element: CompositeField,\r\n): element is ReactFormMakerStep {\r\n  return (\r\n    (element as ReactFormMakerStep).isStep !== undefined ||\r\n    (element as ReactFormMakerStep).stepName !== undefined\r\n  );\r\n}\r\n",
  "/ReactFormMaker/utils/typeGuards/optionsFields.TypeGuards.ts": "export interface Option {\r\n  value: string | number;\r\n  label: string;\r\n}\r\n\r\n/**\r\n * **Type guard function to check if one option are of type `Option` or `string`.**\r\n * - - -\r\n * @param element - The element to check.\r\n * @returns {boolean} A boolean indicating whether the element is a `Option` type.\r\n * _is defined by the presence of the `value` property._\r\n */\r\nexport function isOption(element: string | Option): element is Option {\r\n  return (element as Option).value !== undefined;\r\n}\r\n\r\n/**\r\n * **Function to extract the value from an option.**\r\n * - - -\r\n * @param option - The option to extract the value from.\r\n * @returns {string | number} The value of the option.\r\n * _If the option is a string, it returns the string itself._\r\n */\r\nexport function useValueOption(option: string | Option) {\r\n  return isOption(option) ? option.value : option;\r\n}\r\n\r\nexport function isOptionsArray(\r\n  options: (string | Option)[] | undefined,\r\n): options is Option[] {\r\n  return Array.isArray(options) && options.every((option) => isOption(option));\r\n}\r\n\r\n/**\r\n * **Type guard function to check if all options are of type `Option` and not `string`.**\r\n * - - -\r\n * _This function is used when componenent needs to ensure that all options are of type `Option`._\r\n * @param options\r\n * @returns {Option[]} An array of options.\r\n */\r\nexport function mustBeArrayOfOptions(\r\n  options: (string | Option)[] | undefined,\r\n): Option[] {\r\n  if (!options) {\r\n    return [];\r\n  }\r\n  return options.filter(isOption);\r\n}\r\n",
  "/ReactFormMaker/utils/validators/dateValidators.ts": "export interface SimpleDurationValues {\r\n  days?: number;\r\n  weeks?: number;\r\n  months?: number;\r\n  years?: number;\r\n}\r\n\r\n/**\r\n * **isOlderThan**\r\n * Vérifie si la date de naissance est antérieure à une date calculée en soustrayant un certain nombre d'années, de mois et de jours de la date actuelle.\r\n *\r\n * @param {Date} birthDate - La date de naissance sous forme d'objet Date.\r\n * @param {SimpleDurationValues} comparisonDate - La différence en années, mois et jours.\r\n * @returns {boolean} `true` si la date de naissance est antérieure à la date calculée, `false` sinon.\r\n *\r\n * ---\r\n *\r\n * #### Exemple\r\n *\r\n * ##### Utilisation simple\r\n *\r\n * ```typescript\r\n * const birthDate = new Date('1990-01-01');\r\n * const comparisonDate = { years: 18 };\r\n * const isAdult = isOlderThan(birthDate, comparisonDate);\r\n * console.log(isAdult); // retourn true\r\n * ```\r\n *\r\n * ##### Autre Exemple d'utilisation\r\n *\r\n * ```typescript\r\n * // On verfie si la date est supérieure à 1 an et 6 mois\r\n * const birthDate = new Date('2024-01-01');\r\n * const comparisonDate = { years: 1, months: 6 };\r\n * const isOlder = isOlderThan(birthDate, comparisonDate);\r\n * console.log(isOlder); // retourne true\r\n *\r\n * // ou aussi\r\n * const secondComparisonDate = { months: 18 };\r\n * const isOlder = isOlderThan(birthDate, secondComparisonDate);\r\n * console.log(isOlder); // retourne true\r\n * ```\r\n */\r\nconst isOlderThan = (\r\n  birthDate: Date,\r\n  comparisonDate: SimpleDurationValues,\r\n): boolean => {\r\n  const now = new Date();\r\n  const comparison = new Date(\r\n    now.getFullYear() - (comparisonDate.years || 0),\r\n    now.getMonth() - (comparisonDate.months || 0),\r\n    now.getDate() - (comparisonDate.days || 0),\r\n  );\r\n  if (comparisonDate.weeks) {\r\n    comparison.setDate(comparison.getDate() - comparisonDate.weeks * 7);\r\n  }\r\n  return birthDate.getTime() < comparison.getTime();\r\n};\r\n\r\nconst islaterThan = (\r\n  birthDate: Date,\r\n  comparisonDate: SimpleDurationValues,\r\n): boolean => {\r\n  const now = new Date();\r\n  const comparison = new Date(\r\n    now.getFullYear() + (comparisonDate.years || 0),\r\n    now.getMonth() + (comparisonDate.months || 0),\r\n    now.getDate() + (comparisonDate.days || 0),\r\n  );\r\n  if (comparisonDate.weeks) {\r\n    comparison.setDate(comparison.getDate() + comparisonDate.weeks * 7);\r\n  }\r\n  return birthDate.getTime() > comparison.getTime();\r\n};\r\n\r\nconst isBetween = (\r\n  from: Date,\r\n  to: Date,\r\n  comparisonDate: SimpleDurationValues,\r\n): boolean => {\r\n  const comparison = new Date(\r\n    from.getFullYear() + (comparisonDate.years || 0),\r\n    from.getMonth() + (comparisonDate.months || 0),\r\n    from.getDate() + (comparisonDate.days || 0),\r\n  );\r\n  if (comparisonDate.weeks) {\r\n    comparison.setDate(comparison.getDate() + comparisonDate.weeks * 7);\r\n  }\r\n  return to.getTime() > comparison.getTime();\r\n};\r\n\r\nexport { isOlderThan, islaterThan, isBetween };\r\n",
  "/ReactFormMaker/utils/validators/formValidators.ts": "import { CompositeField } from '../../interfaces/FieldInterfaces';\r\nimport { isStepReactFormMaker } from '../typeGuards/compositeField.TypeGuards';\r\n\r\n/**\r\n * **Validate Stepper Form Fields**\r\n * Rule :\r\n *  - Warn if the form contains only one step.\r\n *  - Error if the form contains no step.\r\n * - - -\r\n * @param formfields - Les champs de formulaire à valider.\r\n * @param stepper - Le boolean indiquant si le formulaire utilise un stepper.\r\n * @returns Vrai si la validation passe, sinon une erreur ou un avertissement est lancé.\r\n */\r\nexport default function validateStepperFormFields(\r\n  formfields: CompositeField[],\r\n  stepper: boolean,\r\n): void {\r\n  if (stepper) {\r\n    const stepFields = formfields.filter(isStepReactFormMaker);\r\n    if (stepFields.length < 1) {\r\n      throw new Error(\r\n        'Le formulaire doit contenir au moins un champ de type \"ReactFormMakerStep\" lorsque le stepper est activé.',\r\n      );\r\n    } else if (stepFields.length === 1) {\r\n      console.warn(\r\n        'Le formulaire contient seulement un champ de type \"ReactFormMakerStep\". Le stepper n\\'est pas utile avec une seule étape.',\r\n      );\r\n    }\r\n  }\r\n}\r\n",
  "/ReactFormMaker/zodRFM/zodRFM.class.ts": "import { z, AnyZodObject, ZodTypeAny } from 'zod';\r\nimport { merge } from 'ts-deepmerge';\r\nimport {\r\n  CompositeField,\r\n  DividerReactFormMaker,\r\n  FieldReactFormMaker,\r\n  InputType,\r\n  ReactFormMakerFieldset,\r\n} from '../../components/ReactFormMaker/interfaces/FieldInterfaces';\r\n\r\nexport interface ReferenceObject {\r\n  $ref: string;\r\n  summary?: string;\r\n  description?: string;\r\n}\r\n\r\nexport type SchemaObjectType =\r\n  | 'integer'\r\n  | 'number'\r\n  | 'string'\r\n  | 'boolean'\r\n  | 'object'\r\n  | 'null'\r\n  | 'array';\r\n\r\nexport type SchemaObject = Partial<\r\n  {\r\n    type?: SchemaObjectType | SchemaObjectType[];\r\n    format?: string;\r\n    minLength?: number;\r\n    maxLength?: number;\r\n    pattern?: string;\r\n    maximum?: number;\r\n    exclusiveMaximum?: number;\r\n    minimum?: number;\r\n    exclusiveMinimum?: number;\r\n    multipleOf?: number;\r\n    additionalProperties?: Partial<SchemaObject> | ReferenceObject | boolean;\r\n    minItems?: number;\r\n    maxItems?: number;\r\n    oneOf?: SchemaObject[];\r\n    allOf?: SchemaObject[];\r\n    enum?: any[];\r\n    readOnly?: boolean;\r\n    description?: string;\r\n  } & (FieldReactFormMaker | DividerReactFormMaker | ReactFormMakerFieldset)\r\n>;\r\n\r\ntype RFMchemaObject = SchemaObject & { hideDefinitions?: string[] };\r\n\r\ninterface RFMZodAny extends ZodTypeAny {\r\n  metaReactFormMaker?: Partial<ReactFormMakerFieldset>;\r\n}\r\n\r\ninterface RFMAnyObject extends AnyZodObject {\r\n  metaReactFormMaker?: Partial<ReactFormMakerFieldset>;\r\n}\r\n\r\ntype RFMVersion = '1' | '1.2';\r\n\r\ninterface ParsingArgs<T> {\r\n  zodRef: T;\r\n  schemas: RFMAnyObject[];\r\n  useOutput?: boolean;\r\n  hideDefinitions?: string[];\r\n  RFMVersion: RFMVersion;\r\n}\r\n\r\nexport function extendApi<T extends RFMZodAny>(\r\n  schema: T,\r\n  schemaObject: SchemaObject = {},\r\n): T {\r\n  const This = (schema as any).constructor;\r\n  const newSchema = new This(schema._def);\r\n  newSchema.metaReactFormMaker = Object.assign(\r\n    {},\r\n    schema.metaReactFormMaker || {},\r\n    schemaObject,\r\n  );\r\n  return newSchema;\r\n}\r\n\r\nfunction iterateZodObject({\r\n  zodRef,\r\n  useOutput,\r\n  hideDefinitions,\r\n  RFMVersion,\r\n}: ParsingArgs<RFMAnyObject>) {\r\n  const reduced = Object.keys(zodRef.shape)\r\n    .filter((key) => hideDefinitions?.includes(key) === false)\r\n    .reduce(\r\n      (carry, key) => ({\r\n        ...carry,\r\n        [key]: generateSchema(zodRef.shape[key], useOutput, RFMVersion),\r\n      }),\r\n      {} as Record<string, SchemaObject>,\r\n    );\r\n\r\n  return reduced;\r\n}\r\n\r\nfunction typeFormat<const T extends SchemaObjectType>(\r\n  type: T,\r\n  openApiVersion: RFMVersion,\r\n) {\r\n  return openApiVersion === '1' ? type : [type];\r\n}\r\n\r\nfunction parseTransformation({\r\n  zodRef,\r\n  schemas,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodTransformer<never> | z.ZodEffects<never>>): SchemaObject {\r\n  const input = generateSchema(zodRef._def.schema, useOutput, RFMVersion);\r\n  let output = 'undefined';\r\n  if (useOutput && zodRef._def.effect) {\r\n    const effect =\r\n      zodRef._def.effect.type === 'transform' ? zodRef._def.effect : null;\r\n    if (effect && 'transform' in effect) {\r\n      try {\r\n        const type = Array.isArray(input.type) ? input.type[0] : input.type;\r\n        output = typeof effect.transform(\r\n          ['integer', 'number'].includes(`${type}`)\r\n            ? 0\r\n            : 'string' === type\r\n              ? ''\r\n              : 'boolean' === type\r\n                ? false\r\n                : 'object' === type\r\n                  ? {}\r\n                  : 'null' === type\r\n                    ? null\r\n                    : 'array' === type\r\n                      ? []\r\n                      : undefined,\r\n          { addIssue: () => undefined, path: [] }, // TODO: Discover if context is necessary here\r\n        );\r\n      } catch (e) {\r\n        /**/\r\n      }\r\n    }\r\n  }\r\n  const outputType = output as 'number' | 'string' | 'boolean' | 'null';\r\n  return merge(\r\n    {\r\n      ...(zodRef.description ? { description: zodRef.description } : {}),\r\n      ...input,\r\n      ...(['number', 'string', 'boolean', 'null'].includes(output)\r\n        ? {\r\n            type: typeFormat(outputType, RFMVersion),\r\n          }\r\n        : {}),\r\n    },\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseString({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodString>): SchemaObject {\r\n  const baseSchema: SchemaObject = {\r\n    type: typeFormat('string', RFMVersion),\r\n  };\r\n  const { checks = [] } = zodRef._def;\r\n  checks.forEach((item) => {\r\n    switch (item.kind) {\r\n      case 'email':\r\n        baseSchema.format = 'email';\r\n        break;\r\n      case 'uuid':\r\n        baseSchema.format = 'uuid';\r\n        break;\r\n      case 'cuid':\r\n        baseSchema.format = 'cuid';\r\n        break;\r\n      case 'url':\r\n        baseSchema.format = 'uri';\r\n        break;\r\n      case 'datetime':\r\n        baseSchema.format = 'date-time';\r\n        break;\r\n      case 'length':\r\n        baseSchema.minLength = item.value;\r\n        baseSchema.maxLength = item.value;\r\n        break;\r\n      case 'max':\r\n        baseSchema.maxLength = item.value;\r\n        break;\r\n      case 'min':\r\n        baseSchema.minLength = item.value;\r\n        break;\r\n      case 'regex':\r\n        baseSchema.pattern = item.regex.source;\r\n        break;\r\n    }\r\n  });\r\n  return merge(\r\n    baseSchema,\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseNumber({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodNumber>): SchemaObject {\r\n  const baseSchema: SchemaObject = {\r\n    type: typeFormat('number', RFMVersion),\r\n  };\r\n  const { checks = [] } = zodRef._def;\r\n  checks.forEach((item) => {\r\n    switch (item.kind) {\r\n      case 'max':\r\n        if (item.inclusive) baseSchema.maximum = item.value;\r\n        else baseSchema.exclusiveMaximum = item.value;\r\n        break;\r\n      case 'min':\r\n        if (item.inclusive) baseSchema.minimum = item.value;\r\n        else baseSchema.exclusiveMinimum = item.value;\r\n        break;\r\n      case 'int':\r\n        baseSchema.type = typeFormat('integer', RFMVersion);\r\n        break;\r\n      case 'multipleOf':\r\n        baseSchema.multipleOf = item.value;\r\n        break;\r\n    }\r\n  });\r\n  return merge(\r\n    baseSchema,\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction getExcludedDefinitionsFromSchema(schemas: any): string[] {\r\n  const excludedDefinitions = [];\r\n  for (const schema of schemas) {\r\n    if (Array.isArray(schema.hideDefinitions)) {\r\n      excludedDefinitions.push(...schema.hideDefinitions);\r\n    }\r\n  }\r\n\r\n  return excludedDefinitions;\r\n}\r\n\r\nfunction parseObject({\r\n  zodRef,\r\n  schemas,\r\n  useOutput,\r\n  hideDefinitions,\r\n  RFMVersion,\r\n}: ParsingArgs<\r\n  z.ZodObject<never, 'passthrough' | 'strict' | 'strip'>\r\n>): SchemaObject {\r\n  let additionalProperties: SchemaObject['additionalProperties'];\r\n\r\n  // `catchall` obviates `strict`, `strip`, and `passthrough`\r\n  if (\r\n    !(\r\n      zodRef._def.catchall instanceof z.ZodNever ||\r\n      zodRef._def.catchall?._def.typeName === 'ZodNever'\r\n    )\r\n  ) {\r\n    additionalProperties = generateSchema(\r\n      zodRef._def.catchall,\r\n      useOutput,\r\n      RFMVersion,\r\n    );\r\n  } else if (zodRef._def.unknownKeys === 'passthrough') {\r\n    additionalProperties = true;\r\n  } else if (zodRef._def.unknownKeys === 'strict') {\r\n    additionalProperties = false;\r\n  }\r\n\r\n  // So that `undefined` values don't end up in the schema and be weird\r\n  additionalProperties =\r\n    additionalProperties != null ? additionalProperties : {};\r\n\r\n  const requiredProperties = Object.keys(\r\n    (zodRef as z.AnyZodObject).shape,\r\n  ).filter((key) => {\r\n    const item = (zodRef as z.AnyZodObject).shape[key];\r\n    return (\r\n      !(\r\n        item.isOptional() ||\r\n        item instanceof z.ZodDefault ||\r\n        item._def.typeName === 'ZodDefault'\r\n      ) && !(item instanceof z.ZodNever || item._def.typeName === 'ZodDefault')\r\n    );\r\n  });\r\n\r\n  const required =\r\n    requiredProperties.length > 0 ? { required: requiredProperties } : {};\r\n\r\n  return merge(\r\n    {\r\n      type: typeFormat('object', RFMVersion),\r\n      properties: iterateZodObject({\r\n        zodRef: zodRef as RFMAnyObject,\r\n        schemas,\r\n        useOutput,\r\n        hideDefinitions: getExcludedDefinitionsFromSchema(schemas),\r\n        RFMVersion,\r\n      }),\r\n      ...required,\r\n      additionalProperties,\r\n      ...hideDefinitions,\r\n    },\r\n    zodRef.description\r\n      ? { description: zodRef.description, hideDefinitions }\r\n      : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseRecord({\r\n  zodRef,\r\n  schemas,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodRecord>): SchemaObject {\r\n  return merge(\r\n    {\r\n      type: typeFormat('object', RFMVersion),\r\n      additionalProperties:\r\n        zodRef._def.valueType instanceof z.ZodUnknown\r\n          ? true\r\n          : generateSchema(zodRef._def.valueType, useOutput, RFMVersion),\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseBigInt({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodBigInt>): SchemaObject {\r\n  return merge(\r\n    {\r\n      type: typeFormat('integer', RFMVersion),\r\n      format: 'int64',\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseBoolean({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodBoolean>): SchemaObject {\r\n  return merge(\r\n    { type: typeFormat('boolean', RFMVersion) },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseDate({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodDate>): SchemaObject {\r\n  return merge(\r\n    {\r\n      type: typeFormat('string', RFMVersion),\r\n      format: 'date-time',\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseNull({\r\n  zodRef,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodNull>): SchemaObject {\r\n  return merge(\r\n    RFMVersion === '1'\r\n      ? { type: 'null' as SchemaObjectType }\r\n      : {\r\n          type: ['string', 'null'] as SchemaObjectType[],\r\n          enum: ['null'],\r\n        },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseOptional({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodOptional<RFMZodAny>>): SchemaObject {\r\n  return merge(\r\n    generateSchema(zodRef.unwrap(), useOutput, RFMVersion),\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseNullable({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodNullable<RFMZodAny>>): SchemaObject {\r\n  const schema = generateSchema(zodRef.unwrap(), useOutput, RFMVersion);\r\n  return merge(\r\n    schema,\r\n    { type: typeFormat('null', RFMVersion) },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseDefault({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodDefault<RFMZodAny>>): SchemaObject {\r\n  return merge(\r\n    {\r\n      default: zodRef._def.defaultValue(),\r\n      ...generateSchema(zodRef._def.innerType, useOutput, RFMVersion),\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseArray({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodArray<RFMZodAny>>): SchemaObject {\r\n  const constraints: Partial<SchemaObject> = {};\r\n  if (zodRef._def.exactLength != null) {\r\n    constraints.minItems = zodRef._def.exactLength.value;\r\n    constraints.maxItems = zodRef._def.exactLength.value;\r\n  }\r\n\r\n  if (zodRef._def.minLength != null)\r\n    constraints.minItems = zodRef._def.minLength.value;\r\n  if (zodRef._def.maxLength != null)\r\n    constraints.maxItems = zodRef._def.maxLength.value;\r\n\r\n  return merge(\r\n    {\r\n      type: typeFormat('array', RFMVersion),\r\n      items: generateSchema(zodRef.element, useOutput, RFMVersion),\r\n      ...constraints,\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseLiteral({\r\n  schemas,\r\n  zodRef,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodLiteral<RFMZodAny>>): SchemaObject {\r\n  const type = typeof zodRef._def.value as 'string' | 'number' | 'boolean';\r\n  return merge(\r\n    {\r\n      type: typeFormat(type, RFMVersion),\r\n      enum: [zodRef._def.value],\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseEnum({\r\n  schemas,\r\n  zodRef,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodEnum<never> | z.ZodNativeEnum<never>>): SchemaObject {\r\n  const type = typeof Object.values(zodRef._def.values)[0] as\r\n    | 'string'\r\n    | 'number';\r\n  return merge(\r\n    {\r\n      type: typeFormat(type, RFMVersion),\r\n      enum: Object.values(zodRef._def.values),\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseIntersection({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodIntersection<z.ZodTypeAny, z.ZodTypeAny>>): SchemaObject {\r\n  return merge(\r\n    {\r\n      type: typeFormat('object', RFMVersion),\r\n      allOf: [\r\n        generateSchema(zodRef._def.left, useOutput, RFMVersion),\r\n        generateSchema(zodRef._def.right, useOutput, RFMVersion),\r\n      ],\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseUnion({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodUnion<[z.ZodTypeAny, ...z.ZodTypeAny[]]>>): SchemaObject {\r\n  const contents = zodRef._def.options;\r\n  if (\r\n    contents.reduce(\r\n      (prev, content) => prev && content._def.typeName === 'ZodLiteral',\r\n      true,\r\n    )\r\n  ) {\r\n    // special case to transform unions of literals into enums\r\n    const literals = contents as unknown as z.ZodLiteral<RFMZodAny>[];\r\n    const type = literals.reduce(\r\n      (prev, content) =>\r\n        !prev || prev === typeof content._def.value\r\n          ? typeof content._def.value\r\n          : null,\r\n      null as null | string,\r\n    );\r\n\r\n    if (type) {\r\n      const baseSchema: SchemaObject = {\r\n        type: typeFormat(type as SchemaObjectType, RFMVersion),\r\n        enum: literals.map((literal) => literal._def.value),\r\n      };\r\n\r\n      const descriptionSchema = zodRef.description\r\n        ? { description: zodRef.description }\r\n        : {};\r\n\r\n      return merge(baseSchema, descriptionSchema, ...schemas);\r\n    }\r\n  }\r\n\r\n  const baseSchema: SchemaObject = {\r\n    oneOf: contents.map((schema) =>\r\n      generateSchema(schema, useOutput, RFMVersion),\r\n    ),\r\n  };\r\n\r\n  const descriptionSchema = zodRef.description\r\n    ? { description: zodRef.description }\r\n    : {};\r\n\r\n  return merge(baseSchema, descriptionSchema, ...schemas);\r\n}\r\n\r\nfunction parseDiscriminatedUnion({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<\r\n  z.ZodDiscriminatedUnion<string, z.ZodDiscriminatedUnionOption<string>[]>\r\n>): SchemaObject {\r\n  return merge(\r\n    {\r\n      discriminator: {\r\n        propertyName: (\r\n          zodRef as z.ZodDiscriminatedUnion<\r\n            string,\r\n            z.ZodDiscriminatedUnionOption<string>[]\r\n          >\r\n        )._def.discriminator,\r\n      },\r\n      oneOf: Array.from(\r\n        (\r\n          zodRef as z.ZodDiscriminatedUnion<\r\n            string,\r\n            z.ZodDiscriminatedUnionOption<string>[]\r\n          >\r\n        )._def.options.values(),\r\n      ).map((schema) => generateSchema(schema, useOutput, RFMVersion)),\r\n    },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseNever({\r\n  zodRef,\r\n  schemas,\r\n}: ParsingArgs<z.ZodNever>): SchemaObject {\r\n  return merge(\r\n    { readOnly: true },\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseBranded({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodBranded<z.ZodAny, string>>): SchemaObject {\r\n  return merge(\r\n    generateSchema(zodRef._def.type, useOutput, RFMVersion),\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parsePipeline({\r\n  schemas,\r\n  zodRef,\r\n  useOutput,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodPipeline<never, never>>): SchemaObject {\r\n  return merge(\r\n    generateSchema(\r\n      useOutput ? zodRef._def.out : zodRef._def.in,\r\n      useOutput,\r\n      RFMVersion,\r\n    ),\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction parseReadonly({\r\n  zodRef,\r\n  useOutput,\r\n  schemas,\r\n  RFMVersion,\r\n}: ParsingArgs<z.ZodReadonly<z.ZodAny>>): SchemaObject {\r\n  return merge(\r\n    generateSchema(zodRef._def.innerType, useOutput, RFMVersion),\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nfunction catchAllParser({\r\n  zodRef,\r\n  schemas,\r\n}: ParsingArgs<ZodTypeAny>): SchemaObject {\r\n  return merge(\r\n    zodRef.description ? { description: zodRef.description } : {},\r\n    ...schemas,\r\n  );\r\n}\r\n\r\nconst workerMap = {\r\n  ZodObject: parseObject,\r\n  ZodRecord: parseRecord,\r\n  ZodString: parseString,\r\n  ZodNumber: parseNumber,\r\n  ZodBigInt: parseBigInt,\r\n  ZodBoolean: parseBoolean,\r\n  ZodDate: parseDate,\r\n  ZodNull: parseNull,\r\n  ZodOptional: parseOptional,\r\n  ZodNullable: parseNullable,\r\n  ZodDefault: parseDefault,\r\n  ZodArray: parseArray,\r\n  ZodLiteral: parseLiteral,\r\n  ZodEnum: parseEnum,\r\n  ZodNativeEnum: parseEnum,\r\n  ZodTransformer: parseTransformation,\r\n  ZodEffects: parseTransformation,\r\n  ZodIntersection: parseIntersection,\r\n  ZodUnion: parseUnion,\r\n  ZodDiscriminatedUnion: parseDiscriminatedUnion,\r\n  ZodNever: parseNever,\r\n  ZodBranded: parseBranded,\r\n  // TODO Transform the rest to schemas\r\n  ZodUndefined: catchAllParser,\r\n  // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples\r\n  ZodTuple: catchAllParser,\r\n  ZodMap: catchAllParser,\r\n  ZodFunction: catchAllParser,\r\n  ZodLazy: catchAllParser,\r\n  ZodPromise: catchAllParser,\r\n  ZodAny: catchAllParser,\r\n  ZodUnknown: catchAllParser,\r\n  ZodVoid: catchAllParser,\r\n  ZodPipeline: parsePipeline,\r\n  ZodReadonly: parseReadonly,\r\n};\r\ntype WorkerKeys = keyof typeof workerMap;\r\n\r\nexport function generateSchema(\r\n  zodRef: RFMZodAny,\r\n  useOutput = false,\r\n  RFMVersion: RFMVersion = '1',\r\n): SchemaObject {\r\n  const { metaReactFormMaker = {} } = zodRef;\r\n  const schemas = [\r\n    ...(Array.isArray(metaReactFormMaker)\r\n      ? metaReactFormMaker\r\n      : [metaReactFormMaker]),\r\n  ];\r\n  try {\r\n    const typeName = zodRef._def.typeName as WorkerKeys;\r\n    if (typeName in workerMap) {\r\n      return workerMap[typeName]({\r\n        zodRef: zodRef as never,\r\n        schemas,\r\n        useOutput,\r\n        RFMVersion,\r\n      });\r\n    }\r\n\r\n    return catchAllParser({ zodRef, schemas, RFMVersion });\r\n  } catch (err) {\r\n    console.error(err);\r\n    return catchAllParser({ zodRef, schemas, RFMVersion });\r\n  }\r\n}\r\n",
  "/lib/commandManager.interface.ts": "/**\r\n * **Gestionnaire de commandes**\r\n *\r\n * ---\r\n *\r\n * Un gestionnaire de commandes permet d'exécuter une série de commandes de manière progressive. Les commandes sont exécutées dans\r\n * l'ordre où elles ont été ajoutées, et peuvent partager des données via un contexte global.\r\n *\r\n * ---\r\n *\r\n * #### Exemple d'utilisation\r\n * ```ts\r\n * const manager = new CommandManager();\r\n *\r\n * manager.addCommand('greet', async (context) => {\r\n *   console.log('Hello', context.user.name);\r\n *   return { success: true };\r\n * });\r\n *\r\n * manager.addCommand('farewell', async (context) => {\r\n *   console.log('Goodbye', context.user.name);\r\n *   return { success: true };\r\n * });\r\n *\r\n * manager.setContext({ user: { name: 'John Doe' } });\r\n *\r\n * const result = await manager.execute();\r\n * console.log('All commands executed successfully:', result);\r\n * ```\r\n */\r\n\r\nexport type CommandResult<T = unknown> = {\r\n  success: boolean;\r\n  data?: T;\r\n};\r\n\r\nexport type Command<TContext = Record<string, unknown>> = (\r\n  context: TContext,\r\n) => Promise<CommandResult>;\r\n\r\nexport interface NamedCommand<TContext = Record<string, unknown>> {\r\n  name: string;\r\n  command: Command<TContext>;\r\n}\r\n\r\nexport interface CommandManagerInterface<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  /**\r\n   * **Ajouter une commande**\r\n   *\r\n   * Ajoute une commande à la liste des commandes à exécuter. Une commande doit être identifiée par un nom unique.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * manager.addCommand('init', async (context) => {\r\n   *   console.log('Initialisation du contexte');\r\n   *   return { success: true };\r\n   * });\r\n   * ```\r\n   *\r\n   * @param name - Le nom unique de la commande.\r\n   * @param command - La fonction asynchrone représentant la commande.\r\n   */\r\n  addCommand(name: string, command: Command<TContext>): void;\r\n\r\n  /**\r\n   * **Ajouter plusieurs commandes**\r\n   *\r\n   * Ajoute une liste de commandes nommées.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * manager.addCommands([\r\n   *   { name: 'step1', command: async (context) => ({ success: true }) },\r\n   *   { name: 'step2', command: async (context) => ({ success: true }) },\r\n   * ]);\r\n   * ```\r\n   *\r\n   * @param commands - La liste des commandes à ajouter.\r\n   */\r\n  addCommands(commands: NamedCommand<TContext>[]): void;\r\n\r\n  /**\r\n   * **Définir ou mettre à jour le contexte**\r\n   *\r\n   * Ajoute ou met à jour les données du contexte global partagé entre les commandes.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * manager.setContext({ user: { id: 123, name: 'Jane' } });\r\n   * ```\r\n   *\r\n   * @param partialContext - Un objet contenant les données à fusionner avec le contexte actuel.\r\n   */\r\n  setContext(partialContext: Partial<TContext>): void;\r\n\r\n  /**\r\n   * **Exécuter toutes les commandes**\r\n   *\r\n   * Exécute les commandes dans l'ordre où elles ont été ajoutées. Si une commande échoue, l'exécution s'arrête.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const result = await manager.execute();\r\n   * console.log(result ? 'Success' : 'Failure');\r\n   * ```\r\n   *\r\n   * @returns `true` si toutes les commandes ont réussi, `false` sinon.\r\n   */\r\n  execute(): Promise<boolean>;\r\n\r\n  /**\r\n   * **Réinitialiser le gestionnaire**\r\n   *\r\n   * Supprime toutes les commandes et réinitialise le contexte.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * manager.reset();\r\n   * ```\r\n   */\r\n  reset(): void;\r\n\r\n  /**\r\n   * **Obtenir le contexte actuel**\r\n   *\r\n   * Retourne une copie immuable du contexte global.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const currentContext = manager.getContext();\r\n   * console.log(currentContext);\r\n   * ```\r\n   *\r\n   * @returns Une copie du contexte global actuel.\r\n   */\r\n  getContext(): Readonly<TContext>;\r\n\r\n  /**\r\n   * **Obtenir la liste des commandes**\r\n   *\r\n   * Retourne une copie immuable des commandes enregistrées.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const commands = manager.getCommands();\r\n   * console.log(commands);\r\n   * ```\r\n   *\r\n   * @returns Une liste immuable des commandes enregistrées.\r\n   */\r\n  getCommands(): Readonly<NamedCommand<TContext>[]>;\r\n\r\n  /**\r\n   * **Exécuter une commande spécifique**\r\n   *\r\n   * Exécute uniquement une commande identifiée par son nom.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const result = await manager.executeOnly('greet');\r\n   * console.log(result);\r\n   * ```\r\n   *\r\n   * @param name - Le nom de la commande à exécuter.\r\n   * @returns Le résultat de la commande, ou `null` si elle n'existe pas.\r\n   */\r\n  executeOnly(name: string): Promise<CommandResult | null>;\r\n\r\n  /**\r\n   * **Exécuter les commandes suivantes**\r\n   *\r\n   * Exécute toutes les commandes qui se trouvent après une commande donnée.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const success = await manager.executeAfter('step1');\r\n   * console.log(success);\r\n   * ```\r\n   *\r\n   * @param name - Le nom de la commande après laquelle commencer.\r\n   * @returns `true` si toutes les commandes restantes ont réussi, `false` sinon.\r\n   */\r\n  executeAfter(name: string): Promise<boolean>;\r\n\r\n  /**\r\n   * **Exécuter un sous-ensemble de commandes**\r\n   *\r\n   * Exécute une liste spécifique de commandes.\r\n   *\r\n   * #### Exemple\r\n   * ```ts\r\n   * const subset = manager.getCommands().slice(1, 3);\r\n   * const success = await manager.executeSubset(subset);\r\n   * console.log(success);\r\n   * ```\r\n   *\r\n   * @param commands - La liste des commandes à exécuter.\r\n   * @returns `true` si toutes les commandes ont réussi, `false` sinon.\r\n   */\r\n  executeSubset(commands: NamedCommand<TContext>[]): Promise<boolean>;\r\n}\r\n",
  "/lib/commandManager.ts": "import {\r\n  Command,\r\n  CommandManagerInterface,\r\n  CommandResult,\r\n  NamedCommand,\r\n} from './commandManager.interface';\r\n\r\nexport class CommandManager<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n> implements CommandManagerInterface<TContext>\r\n{\r\n  private commands: NamedCommand<TContext>[] = [];\r\n  private context: TContext;\r\n\r\n  constructor(initialContext: Partial<TContext> = {}) {\r\n    this.context = initialContext as TContext;\r\n  }\r\n\r\n  addCommand(name: string, command: Command<TContext>): void {\r\n    if (this.commands.some((c) => c.name === name)) {\r\n      throw new Error(`Une commande avec le nom \"${name}\" existe déjà.`);\r\n    }\r\n    this.commands.push({ name, command });\r\n  }\r\n\r\n  addCommands(namedCommands: NamedCommand<TContext>[]): void {\r\n    namedCommands.forEach(({ name, command }) =>\r\n      this.addCommand(name, command),\r\n    );\r\n  }\r\n\r\n  setContext(partialContext: Partial<TContext>): void {\r\n    Object.assign(this.context, partialContext);\r\n  }\r\n\r\n  async execute(): Promise<boolean> {\r\n    for (const { name, command } of this.commands) {\r\n      const result = await command(this.context);\r\n\r\n      if (!result.success) {\r\n        console.error(`Command \"${name}\" failed:`, result);\r\n        return false;\r\n      }\r\n\r\n      if (result.data) {\r\n        Object.assign(this.context, result.data);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  reset(): void {\r\n    this.commands = [];\r\n    this.context = {} as TContext;\r\n  }\r\n\r\n  getContext(): Readonly<TContext> {\r\n    return { ...this.context };\r\n  }\r\n\r\n  getCommands(): Readonly<NamedCommand<TContext>[]> {\r\n    return [...this.commands];\r\n  }\r\n\r\n  async executeOnly(name: string): Promise<CommandResult | null> {\r\n    const command = this.commands.find((c) => c.name === name);\r\n    if (!command) {\r\n      console.warn(`Aucune commande trouvée avec le nom \"${name}\".`);\r\n      return null;\r\n    }\r\n    const result = await command.command(this.context);\r\n    if (result.data) {\r\n      Object.assign(this.context, result.data);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  async executeAfter(name: string): Promise<boolean> {\r\n    const index = this.commands.findIndex((c) => c.name === name);\r\n    if (index === -1) {\r\n      console.warn(`Aucune commande trouvée avec le nom \"${name}\".`);\r\n      return false;\r\n    }\r\n    const commandsToExecute = this.commands.slice(index + 1);\r\n    return this.executeSubset(commandsToExecute);\r\n  }\r\n\r\n  async executeSubset(commands: NamedCommand<TContext>[]): Promise<boolean> {\r\n    for (const { name, command } of commands) {\r\n      const result = await command(this.context);\r\n\r\n      if (!result.success) {\r\n        console.error(`Command \"${name}\" failed:`, result);\r\n        return false;\r\n      }\r\n\r\n      if (result.data) {\r\n        Object.assign(this.context, result.data);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n",
  "/lib/useGenerateUUIDs.ts": "import { useMemo } from 'react';\r\nimport { v4 as uuidV4 } from 'uuid';\r\n\r\n/**\r\n * Custom hook pour générer des UUIDs pour chaque élément d'un tableau.\r\n * @template T Le type des éléments du tableau.\r\n * @param {T[]} array - Le tableau pour lequel générer des UUIDs.\r\n * @returns {string[]} - Un tableau d'UUIDs.\r\n */\r\n/**\r\n * Génère des clés stables pour chaque élément du tableau, en utilisant une propriété unique si possible.\r\n * Si aucune propriété unique n'est disponible, utilise le type + index comme fallback.\r\n */\r\nexport function useGenerateUUIDs<\r\n  T extends { inputName?: string; name?: string },\r\n>(array: T[]): string[] {\r\n  return array.map(\r\n    (item, idx) =>\r\n      item.inputName ||\r\n      item.name ||\r\n      `${item.constructor?.name || 'item'}-${idx}`,\r\n  );\r\n}\r\n",
  "/lib/usePromiseObserver.ts": "import { useState, useEffect, useCallback } from 'react';\r\n\r\ninterface PromiseState<T> {\r\n  loading: boolean;\r\n  data: T | null;\r\n  error: Error | null;\r\n}\r\n\r\ninterface UsePromiseObserverResult<T, R> {\r\n  states: { [key: string]: PromiseState<R> };\r\n  execute: (key: string, data: T) => void;\r\n  listener: (key: string) => 'idle' | 'loading' | 'resolved' | 'rejected';\r\n}\r\n\r\ninterface PromiseMap<T, R> {\r\n  [key: string]: (data: T) => Promise<R>;\r\n}\r\n\r\nexport function usePromiseObserver<T, R>(\r\n  promiseMap: PromiseMap<T, R>,\r\n): UsePromiseObserverResult<T, R> {\r\n  const [states, setStates] = useState<{ [key: string]: PromiseState<R> }>(() =>\r\n    Object.keys(promiseMap).reduce(\r\n      (acc, key) => {\r\n        acc[key] = { loading: false, data: null, error: null };\r\n        return acc;\r\n      },\r\n      {} as { [key: string]: PromiseState<R> },\r\n    ),\r\n  );\r\n\r\n  const execute = useCallback(\r\n    (key: string, data: T) => {\r\n      setStates((prevStates) => ({\r\n        ...prevStates,\r\n        [key]: { loading: true, data: null, error: null },\r\n      }));\r\n\r\n      promiseMap[key](data)\r\n        .then((result) => {\r\n          setStates((prevStates) => ({\r\n            ...prevStates,\r\n            [key]: { loading: false, data: result, error: null },\r\n          }));\r\n        })\r\n        .catch((err) => {\r\n          setStates((prevStates) => ({\r\n            ...prevStates,\r\n            [key]: { loading: false, data: null, error: err },\r\n          }));\r\n        });\r\n    },\r\n    [promiseMap],\r\n  );\r\n\r\n  const listener = useCallback(\r\n    (key: string) => {\r\n      if (!states[key]) {\r\n        return 'idle';\r\n      }\r\n      const state = states[key];\r\n      if (\r\n        state.loading === false &&\r\n        state.error !== null &&\r\n        state.data !== null\r\n      ) {\r\n        return 'idle';\r\n      }\r\n      if (state.loading === true) {\r\n        return 'loading';\r\n      }\r\n      if (state.data !== null) {\r\n        return 'resolved';\r\n      }\r\n      if (state.error !== null) {\r\n        return 'rejected';\r\n      }\r\n      return 'idle'; // Default case\r\n    },\r\n    [states],\r\n  );\r\n\r\n  return { states, execute, listener };\r\n}\r\n",
  "/lib/utils.ts": "import { clsx, type ClassValue } from 'clsx';\r\nimport { twMerge } from 'tailwind-merge';\r\nimport React from 'react';\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\nexport function mergeRefs<T = any>(\r\n  ...refs: Array<\r\n    React.MutableRefObject<T> | React.LegacyRef<T> | undefined | null\r\n  >\r\n): React.RefCallback<T> | null {\r\n  return (value: T | null) => {\r\n    refs.forEach((ref) => {\r\n      if (typeof ref === 'function') {\r\n        ref(value);\r\n      } else if (ref != null) {\r\n        (ref as React.MutableRefObject<T | null>).current = value;\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nexport function formatBytes(\r\n  bytes: number,\r\n  opts: {\r\n    decimals?: number;\r\n    sizeType?: 'accurate' | 'normal';\r\n  } = {},\r\n) {\r\n  const { decimals = 0, sizeType = 'normal' } = opts;\r\n\r\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\r\n  const accurateSizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB'];\r\n  if (bytes === 0) return '0 Byte';\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return `${(bytes / Math.pow(1024, i)).toFixed(decimals)} ${\r\n    sizeType === 'accurate'\r\n      ? (accurateSizes[i] ?? 'Bytes')\r\n      : (sizes[i] ?? 'Bytes')\r\n  }`;\r\n}\r\n",
  "/lib/zodRFM/index.ts": "export * from './zodRFM.extentions';\r\nexport * from './zodRFM.class';\r\n",
  "/lib/zodRFM/zodRFM.extentions.ts": "/*\r\nThis code is heavily inspired by https://github.com/asteasolutions/zod-to-openapi/blob/master/src/zod-extensions.ts\r\n */\r\n\r\nimport { extendApi } from './zodRFM.class';\r\nimport { z } from 'zod';\r\nimport { SchemaObject } from './zodRFM.class';\r\nimport { ZodTypeDef } from 'zod';\r\n\r\ndeclare module 'zod' {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  interface ZodSchema<\r\n    Output = any,\r\n    Def extends ZodTypeDef = ZodTypeDef,\r\n    Input = Output,\r\n  > {\r\n    rfm<T extends ZodSchema<Output, Def, Input>>(\r\n      this: T,\r\n      metadata: Partial<SchemaObject>,\r\n    ): T;\r\n  }\r\n}\r\n\r\nexport function extendZodWithReactFormMaker(\r\n  zod: typeof z,\r\n  forceOverride = false,\r\n) {\r\n  if (!forceOverride && typeof zod.ZodSchema.prototype.rfm !== 'undefined') {\r\n    return;\r\n  }\r\n\r\n  zod.ZodSchema.prototype.rfm = function (metadata?: Partial<SchemaObject>) {\r\n    return extendApi(this, metadata);\r\n  };\r\n}\r\n\r\n// on rend la fonction accessible depuis l'extérieur\r\n",
  "/components/ui/Typography.tsx": "import React from 'react';\r\n\r\ninterface Props {\r\n  className?: string;\r\n  children: string | string[] | React.ReactNode;\r\n}\r\n\r\nconst H1: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <h1\r\n      className={`scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl ${className}`}\r\n    >\r\n      {children}\r\n    </h1>\r\n  );\r\n};\r\n\r\nconst H2: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <h2\r\n      className={`scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0 ${className}`}\r\n    >\r\n      {children}\r\n    </h2>\r\n  );\r\n};\r\n\r\nconst H3: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <h3\r\n      className={`scroll-m-20 text-2xl font-semibold tracking-tight ${className}`}\r\n    >\r\n      {children}\r\n    </h3>\r\n  );\r\n};\r\n\r\nconst H4: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <h4\r\n      className={`scroll-m-20 text-xl font-semibold tracking-tight ${className}`}\r\n    >\r\n      {children}\r\n    </h4>\r\n  );\r\n};\r\n\r\nconst P: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <p className={`leading-7 [&:not(:first-child)]:mt-6 ${className}`}>\r\n      {children}\r\n    </p>\r\n  );\r\n};\r\n\r\nconst Blockquote: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <blockquote className={`mt-6 border-l-2 pl-6 italic ${className}`}>\r\n      {children}\r\n    </blockquote>\r\n  );\r\n};\r\n\r\nconst InlineCode: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <code\r\n      className={`relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold ${className}`}\r\n    >\r\n      {children}\r\n    </code>\r\n  );\r\n};\r\n\r\nconst Lead: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <p className={`text-xl text-muted-foreground ${className}`}>{children}</p>\r\n  );\r\n};\r\n\r\nconst Large: React.FC<Props> = ({ className, children }) => {\r\n  return <div className={`text-lg font-semibold ${className}`}>{children}</div>;\r\n};\r\n\r\nconst Muted: React.FC<Props> = ({ className, children }) => {\r\n  return (\r\n    <p className={`text-sm text-muted-foreground ${className}`}>{children}.</p>\r\n  );\r\n};\r\n\r\nexport { H1, H2, H3, H4, P, Lead, Large, Muted, Blockquote, InlineCode };\r\n"
}