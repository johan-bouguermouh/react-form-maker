{
  "/ReactFormMaker/DOCUMENTATION.md": "# React Form Maker Documentation\n\n## Introduction\n\nReact Form Maker is a tool designed to simplify the creation of simple and repetitive forms. It is based on a straightforward JSON approach, where all the necessary information for inserting form fields is provided in a configuration object.\nReact Form Maker leverages the power of React Hook Form & Zod to ensure robust state management and integrated form validation.\nReact Form Maker is built on ShadCn and the Radix UI library, allowing every developer to customize the behavior and UI of their components at the root level.\n\n## Philosophy\n\nThis project aims to:\n\n- **Standardize the UI** of forms using reusable and consistent components.\n- **Centralize business logic** and field configuration in objects or JSON, rather than in JSX.\n- **Reduce the amount of code to write** for each form, while retaining the power of React Hook Form and Zod for context management and validation.\n- **Facilitate customization** and the handling of complex cases (conditional fields, advanced validations, etc.) without making JSX code more complex.\n\n## Key Concepts\n\n**React Form Maker** adopts a **configuration-driven UI** pattern: the entire form is described by a business configuration, enabling dynamic generation of smart and consistent components, while keeping business logic centralized and factored.\n\n**ReactFormMaker** offers an architecture where business configuration drives form generation, relying on a solid and normalized UI foundation thanks to shadcn/ui.\nThis approach ensures forms are consistent, customizable, and easy to maintain, while limiting JSX code verbosity.\n\n## Using the `ReactFormMaker` Component\n\n### Component Props\n\nHere is the list of props accepted by the `ReactFormMaker` component:\n\n- **`formfields`**\n  - Type: `CompositeField[]`\n  - Required: Yes\n  - Description: An array of form field definitions used to generate the form. Each object in the array configures a field or a group of fields (fieldset).\n  - Example:\n    ```typescript\n    const formfields = [\n      {\n        name: 'username',\n        type: 'text',\n        label: 'Username',\n        validation: { required: true },\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email',\n        validation: { required: true, isEmail: true },\n      },\n    ];\n    ```\n\n- **`onSubmit`**\n  - Type: `(data: T | false, errors: FieldErrors<T> | false) => void`\n  - Required: Yes\n  - Description: Callback function triggered on form submission. It receives the form data if validation succeeds, or the errors if validation fails.\n  - Example:\n    ```typescript\n    function handleSubmit(data, errors) {\n      if (data) {\n        console.log('Form submitted successfully:', data);\n      } else {\n        console.error('Validation errors:', errors);\n      }\n    }\n    ```\n\n- **`className`**\n  - Type: `string`\n  - Required: Optional\n  - Description: Optional CSS class for the form container. Allows you to customize the form style.\n\n- **`footerClassName`**\n  - Type: `string`\n  - Required: Optional\n  - Default value: `'flex justify-end gap-4'`\n  - Description: Optional CSS class for the form footer section, where action buttons are usually placed.\n\n- **`children`**\n  - Type: `React.ReactNode`\n  - Required: Optional\n  - Description: Optional React children to render inside the form. Useful for inserting custom elements or additional action buttons in the footer.\n\n- **`btnTextSubmit`**\n  - Type: `string`\n  - Required: Optional\n  - Default value: `'Submit'`\n  - Description: Text to display on the main submit button of the form.\n\n- **`btnSubmitClassName`**\n  - Type: `string`\n  - Required: Optional\n  - Description: Optional CSS class for the main submit button.\n\n- **`stepper`**\n  - Type: `boolean`\n  - Required: Optional\n  - Default value: `false`\n  - Description: If `true`, the form will be rendered as a stepper (multi-step form). Each top-level `fieldset` in `formfields` will be treated as a step.\n\n- **`orientation`**\n  - Type: `'horizontal' | 'vertical'`\n  - Required: Optional\n  - Default value: `'horizontal'`\n  - Description: Sets the orientation of the stepper (horizontal or vertical). Used only if `stepper` is `true`.\n\n### Usage Examples\n\n#### Simple Example with Basic Fields\n\n```tsx\nimport ReactFormMaker from './ReactFormMaker'; // Adjust the import path\nimport { FieldValues } from 'react-hook-form';\nimport { z } from 'zod'; // Make sure to import Zod\n\nconst MyForm = () => {\n  const formFieldsDefinition = [\n    {\n      inputName: 'firstName',\n      inputType: 'text',\n      label: 'First Name',\n      zodObject: z.string().min(1, 'First name is required'),\n    },\n    {\n      inputName: 'lastName',\n      inputType: 'text',\n      label: 'Last Name',\n      zodObject: z.string().min(1, 'Last name is required'),\n    },\n    {\n      inputName: 'age',\n      inputType: 'number',\n      label: 'Age',\n      zodObject: z.number().min(18, 'You must be at least 18 years old'),\n    },\n  ];\n\n  const handleSubmit = (data: FieldValues) => {\n    console.log('Submitted data:', data);\n  };\n\n  return (\n    <ReactFormMaker\n      formfields={formFieldsDefinition}\n      onSubmit={handleSubmit}\n      btnTextSubmit=\"Send\"\n      className=\"my-custom-form\"\n    />\n  );\n};\n\nexport default MyForm;\n```\n\n#### Example with Custom Children\n\nYou can pass buttons or other React elements as children. They will be rendered in the form footer. If a `submit` button is passed as a child, the default submit button will not be displayed.\n\n```tsx\nimport ReactFormMaker from './ReactFormMaker'; // Adjust the import path\nimport { Button } from '@/components/ui/button'; // Make sure you have a Button component\nimport { FieldValues } from 'react-hook-form';\nimport { z } from 'zod'; // Make sure to import Zod\n\nconst FormWithCustomFooter = () => {\n  const formFieldsDefinition = [\n    {\n      inputName: 'feedback',\n      inputType: 'textarea',\n      label: 'Your feedback',\n      zodObject: z.string().max(200, 'Maximum 200 characters'),\n    },\n  ];\n\n  const handleSubmit = (data: FieldValues) => {\n    console.log('Feedback submitted:', data);\n  };\n\n  const handleReset = () => {\n    // Logic to reset the form (requires access to the form instance)\n    console.log('Form reset');\n  };\n\n  return (\n    <ReactFormMaker formfields={formFieldsDefinition} onSubmit={handleSubmit}>\n      <Button type=\"submit\" variant=\"secondary\">\n        Submit Feedback\n      </Button>\n      <Button type=\"button\" variant=\"outline\" onClick={handleReset}>\n        Reset\n      </Button>\n    </ReactFormMaker>\n  );\n};\n\nexport default FormWithCustomFooter;\n```\n\n#### Example with `stepper` Mode\n\nTo use the stepper mode, you need to structure `formfields` with objects implementing `ReactFormMakerStep` (which are essentially `ReactFormMakerFieldset` objects with additional stepper properties).\n\n```tsx\nimport ReactFormMaker from './ReactFormMaker'; // Adjust the import path\nimport { FieldValues } from 'react-hook-form';\nimport { z } from 'zod'; // Make sure to import Zod\n\nconst StepperFormExample = () => {\n  const stepperFormFields = [\n    {\n      stepName: 'step1', // ReactFormMakerStep property\n      isStep: true, // ReactFormMakerStep property\n      legend: 'Step 1: Personal Information',\n      fields: [\n        {\n          inputName: 'username',\n          inputType: 'text',\n          label: 'Username',\n          zodObject: z.string().min(1),\n        },\n        {\n          inputName: 'email',\n          inputType: 'email',\n          label: 'Email',\n          zodObject: z.string().email(),\n        },\n      ],\n    },\n    {\n      stepName: 'step2',\n      isStep: true,\n      legend: 'Step 2: Address',\n      fields: [\n        {\n          inputName: 'address',\n          inputType: 'text',\n          label: 'Address',\n          zodObject: z.string().min(1),\n        },\n        {\n          inputName: 'city',\n          inputType: 'text',\n          label: 'City',\n          zodObject: z.string().min(1),\n        },\n      ],\n    },\n    {\n      stepName: 'step3',\n      isStep: true,\n      legend: 'Step 3: Confirmation',\n      fields: [\n        {\n          inputName: 'confirm',\n          inputType: 'checkbox',\n          label: 'I confirm my information',\n          zodObject: z.boolean().refine((val) => val === true),\n        },\n      ],\n    },\n  ];\n\n  const handleSubmit = (data: FieldValues) => {\n    console.log('Stepper data submitted:', data);\n  };\n\n  return (\n    <ReactFormMaker\n      formfields={stepperFormFields}\n      onSubmit={handleSubmit}\n      stepper={true}\n      orientation=\"vertical\" // or \"horizontal\"\n      btnTextSubmit=\"Finish\"\n    />\n  );\n};\n\nexport default StepperFormExample;\n```\n\n## Form Field Configuration\n\nThe `formfields` prop is essential for `ReactFormMaker`. It is an array of objects that defines the structure and behavior of your form. Each object in this array can be an individual field, a group of fields (fieldset), a separator, or a form step (if `stepper` is enabled).\n\n### `CompositeField` Interface\n\n`CompositeField` is a base interface that most other field configurations inherit from. It provides common properties for composable form elements.\n\n| Property    | Type                                                                                    | Description                                                                                            |\n| :---------- | :-------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------- |\n| `classname` | `string` (optional)                                                                     | CSS class for styling the element.                                                                     |\n| `fields`    | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` (optional) | An array of child elements (fields, dividers, or fieldsets). Recommended for `ReactFormMakerFieldset`. |\n| `isHide`    | `boolean` (optional)                                                                    | If `true`, hides the element. Useful for conditionally hiding fields.                                  |\n\n### `FieldReactFormMaker` Interface\n\nThis interface defines a standard form field (input, select, etc.). It inherits from `CompositeField`.\n\n| Property                  | Type                                                       | Required | Description                                                                                                                                       |\n| :------------------------ | :--------------------------------------------------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `inputName`               | `string`                                                   | Yes      | Unique name of the field, used as the key in the form data.                                                                                       |\n| `label`                   | `string`                                                   | Optional | Text displayed above or beside the field.                                                                                                         |\n| `placeholder`             | `string`                                                   | Optional | Placeholder text displayed in the field when empty.                                                                                               |\n| `inputType`               | `InputType`                                                | Yes      | Type of field to display (see \"Field Types (`InputType`)\" below).                                                                                 |\n| `zodObject`               | `ZodType<any>`                                             | Optional | Zod validation schema for this field. Recommended for robust validation.                                                                          |\n| `defaultValues`           | `any`                                                      | Optional | Default value of the field.                                                                                                                       |\n| `options`                 | `string[] \\| { value: string \\| number; label: string }[]` | Optional | Options for `select`, `radio`, `checkbox`, `tileSelector`, `tileMultiSelector` fields. Required if `inputType` is one of these types.             |\n| `className`               | `string`                                                   | Optional | CSS class to style the field element itself.                                                                                                      |\n| `disabled`                | `boolean`                                                  | Optional | If `true`, disables the field.                                                                                                                    |\n| `description`             | `string`                                                   | Optional | Descriptive text displayed under or beside the field to provide additional information.                                                           |\n| `isSecure`                | `boolean`                                                  | Optional | If `true`, masks the field (e.g., for password fields, though `isHide` is more common for dynamic hiding).                                        |\n| `onChange`                | `(event: FormFieldEvent) => void`                          | Optional | Callback function executed when the field value changes. The `event` object contains a `form` property to interact with the form state.           |\n| `onBlur`                  | `(event: FormFieldEvent) => void`                          | Optional | Callback function executed when the field loses focus.                                                                                            |\n| `onSelect` (or `onFocus`) | `(event: FormFieldEvent) => void`                          | Optional | Callback function executed when the field gains focus.                                                                                            |\n| `onClick`                 | `(event: FormFieldEvent) => void`                          | Optional | Callback function executed on a click on the field (relevant for certain field types).                                                            |\n| `customInputFieldElement` | `React.ReactNode`                                          | Optional | Allows replacing the default rendering of the field with a custom React component. Must be a valid field element compatible with React Hook Form. |\n| `children`                | `React.ReactNode`                                          | Optional | React children to display inside the field structure (e.g., after the field itself but before the description).                                   |\n| `props`                   | `Record<string, any>`                                      | Optional | Additional properties to pass directly to the underlying HTML input element.                                                                      |\n\n#### Field Types (`InputType`)\n\n| Type                 | Description                                                                              |\n| :------------------- | :--------------------------------------------------------------------------------------- |\n| `text`               | Standard text input field.                                                               |\n| `password`           | Password input field (masks characters).                                                 |\n| `select`             | Dropdown list for single selection. Requires `options` prop.                             |\n| `selectAutocomplete` | Dropdown list with autocomplete. Requires `options` prop.                                |\n| `multiSelect`        | Dropdown list for multiple selections. Requires `options` prop.                          |\n| `textarea`           | Multi-line text area.                                                                    |\n| `date`               | Date picker.                                                                             |\n| `dateRange`          | Date range picker.                                                                       |\n| `radio`              | Radio buttons for single selection among multiple options. Requires `options` prop.      |\n| `checkbox`           | Single checkbox (for a boolean value) or group of checkboxes (if `options` is provided). |\n| `switch`             | Toggle switch (usually for a boolean value).                                             |\n| `file`               | Standard file upload field.                                                              |\n| `fileDropZone`       | Drag-and-drop area for file uploads.                                                     |\n| `number`             | Numeric input field.                                                                     |\n| `custom`             | Used when providing a `customInputFieldElement`.                                         |\n| `tileSelector`       | Tile selector for single selection. Requires `options` prop.                             |\n| `tileMultiSelector`  | Tile selector for multiple selections. Requires `options` prop.                          |\n| `phoneNumber`        | Phone number input (may include specific formatting).                                    |\n\n### `DividerReactFormMaker` Interface\n\nUsed to insert separators or non-interactive structuring elements in the form. Inherits from `CompositeField`.\n\n| Property    | Type                                                                         | Required | Description                                                                      |\n| :---------- | :--------------------------------------------------------------------------- | :------- | :------------------------------------------------------------------------------- |\n| `isDiv`     | `boolean`                                                                    | Yes      | Must be `true`. Indicates that this element is a divider/structural container.   |\n| `className` | `string`                                                                     | Optional | CSS class for styling the divider.                                               |\n| `isHide`    | `boolean`                                                                    | Optional | If `true`, hides the divider.                                                    |\n| `fields`    | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` | Optional | Allows nesting other elements inside this divider, creating a grouped structure. |\n| `children`  | `JSX.Element`                                                                | Optional | Custom JSX content to display inside the divider.                                |\n\n### `ReactFormMakerFieldset` Interface\n\nAllows logically grouping fields under a common title (`legend`). Inherits from `CompositeField`.\n\n| Property          | Type                                                                         | Required | Description                                                                         |\n| :---------------- | :--------------------------------------------------------------------------- | :------- | :---------------------------------------------------------------------------------- |\n| `fieldset`        | `string`                                                                     | Yes      | Unique name for the fieldset (mainly for internal organization, not for form data). |\n| `legend`          | `string`                                                                     | Optional | Title displayed for the group of fields.                                            |\n| `legendClassName` | `string`                                                                     | Optional | CSS class for styling the legend.                                                   |\n| `className`       | `string`                                                                     | Optional | CSS class for styling the fieldset element.                                         |\n| `fields`          | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]` | Optional | Array of nested fields, dividers, or fieldsets within this group.                   |\n| `isHide`          | `boolean`                                                                    | Optional | If `true`, hides the entire fieldset.                                               |\n\n### `ReactFormMakerStep` Interface\n\nDefines a step in a \"stepper\" form. This interface inherits from `CompositeField` and shares many properties with `ReactFormMakerFieldset`, but adds step-specific functionalities. It is used when the `stepper` prop of `ReactFormMaker` is set to `true`.\n\n| Property                | Type                                                                                             | Required | Description                                                                                                                                                                                |\n| :---------------------- | :----------------------------------------------------------------------------------------------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `stepName`              | `string`                                                                                         | Yes      | Unique name of the step, used for identification and navigation.                                                                                                                           |\n| `isStep`                | `boolean`                                                                                        | Optional | Must be `true` to indicate that this element is a step in the stepper.                                                                                                                     |\n| `legend`                | `string`                                                                                         | Optional | Title of the step, displayed at the top of the step.                                                                                                                                       |\n| `legendClassName`       | `string`                                                                                         | Optional | CSS class for styling the step legend.                                                                                                                                                     |\n| `className`             | `string`                                                                                         | Optional | CSS class for styling the step container.                                                                                                                                                  |\n| `fields`                | `(FieldReactFormMaker \\| DividerReactFormMaker \\| ReactFormMakerFieldset)[]`                     | Optional | Array of fields, dividers, or fieldsets contained in this step.                                                                                                                            |\n| `isHide`                | `boolean`                                                                                        | Optional | If `true`, hides the step.                                                                                                                                                                 |\n| `children`              | `React.ReactNode`                                                                                | Optional | Custom React children to display in the step content.                                                                                                                                      |\n| `disabledBefore`        | `boolean`                                                                                        | Optional | If `true` (default `false`), disables the \"Previous\" button and navigation to previous steps via the stepper header.                                                                       |\n| `isStrict`              | `boolean`                                                                                        | Optional | If `true` (default `false`), the user cannot proceed to the next step until all fields in the current step are valid according to their `zodObject`.                                       |\n| `onBeforeNextStep`      | `(data: { submissionState: StepFormState<any>; form: UseFormReturn<any>; }) => Promise<boolean>` | Optional | Asynchronous function executed before proceeding to the next step (after validation). Must return `true` to allow proceeding, `false` to prevent it. Allows for advanced validation logic. |\n| `IconStep`              | `React.ComponentType<any>`                                                                       | Optional | Custom React component for the step icon in the stepper's progress indicator.                                                                                                              |\n| `buttonNextContent`     | `string`                                                                                         | Optional | Custom text for the \"Next\" button of this step.                                                                                                                                            |\n| `buttonPreviousContent` | `string`                                                                                         | Optional | Custom text for the \"Previous\" button of this step.                                                                                                                                        |\n| `additionalButtons`     | `React.ReactNode`                                                                                | Optional | Additional JSX elements (e.g., buttons) to display in the step footer, after the standard navigation buttons.                                                                              |\n| `footerClassName`       | `string \\| string[]`                                                                             | Optional | CSS class(es) for styling the step footer.                                                                                                                                                 |\n\n### Field Configuration Examples\n\n```typescript\nimport { z } from 'zod'; // Make sure to import Zod for examples\n\nexport const formFieldsExamples = [\n  // 1. Simple text field\n  {\n    inputName: 'username',\n    label: 'Username',\n    inputType: 'text',\n    placeholder: 'Enter your username',\n    zodObject: z\n      .string()\n      .min(3, 'Username must be at least 3 characters long.'),\n    description: 'Your public username.',\n  },\n\n  // 2. Select field with options\n  {\n    inputName: 'country',\n    label: 'Country',\n    inputType: 'select',\n    options: [\n      { value: 'fr', label: 'France' },\n      { value: 'ca', label: 'Canada' },\n      { value: 'us', label: 'United States' },\n    ],\n    zodObject: z.string().nonempty('Please select a country.'),\n    defaultValues: 'fr',\n  },\n\n  // 3. Checkbox field\n  {\n    inputName: 'subscribe',\n    label: 'Subscribe to newsletter',\n    inputType: 'checkbox',\n    zodObject: z.boolean(),\n    defaultValues: true,\n  },\n\n  // 4. Group of checkboxes (options for the same inputName)\n  {\n    inputName: 'interests',\n    label: 'Your interests',\n    inputType: 'checkbox',\n    options: [\n      { value: 'tech', label: 'Technology' },\n      { value: 'sport', label: 'Sport' },\n      { value: 'music', label: 'Music' },\n    ],\n    zodObject: z\n      .array(z.string())\n      .min(1, 'Please select at least one interest.'),\n    description: 'Check all that apply.',\n  },\n\n  // 5. Using ReactFormMakerFieldset to group fields\n  {\n    fieldset: 'userProfile', // Fieldset name\n    legend: 'User Profile',\n    className: 'user-profile-fieldset',\n    fields: [\n      {\n        inputName: 'firstName',\n        label: 'First Name',\n        inputType: 'text',\n        zodObject: z.string().min(1, 'First name is required.'),\n      },\n      {\n        inputName: 'lastName',\n        label: 'Last Name',\n        inputType: 'text',\n        zodObject: z.string().min(1, 'Last name is required.'),\n      },\n    ],\n  },\n\n  // 6. Using ReactFormMakerStep (for a form with stepper={true})\n  // This would be an element of the main `formfields` array\n  {\n    stepName: 'personalInfo',\n    isStep: true,\n    legend: 'Personal Information',\n    fields: [\n      {\n        inputName: 'fullName',\n        label: 'Full Name',\n        inputType: 'text',\n        zodObject: z.string().min(2, 'Full name is required.'),\n      },\n      {\n        inputName: 'birthDate',\n        label: 'Date of Birth',\n        inputType: 'date',\n        zodObject: z\n          .date()\n          .refine((date) => date < new Date(), 'Date must be in the past.'),\n      },\n    ],\n    // Step-specific properties\n    isStrict: true,\n    buttonNextContent: 'Next: Address',\n  },\n];\n```\n\n## Programmatic Field Definition with `FieldFactory`\n\nIn many form generators, the initial configuration is often done in JSON format (or JavaScript literal objects). While this approach is universal and flexible, it quickly reaches its limits:\n\n- Complex forms become hard to read and maintain.\n- Business logic (validation, dynamic behaviors) gets scattered or duplicated.\n- The lack of strong typing and autocompletion tools harms code robustness.\n\n**`FieldFactory`** addresses these issues by offering an object-oriented approach to defining form fields. It serves as a base class for specialized classes (e.g., `TextField`, `SelectField`, `PasswordField`, etc.), providing several advantages :\n\n- **Fluent and Readable Configuration** : Thanks to method chaining, field configuration becomes more declarative and expressive.\n  ```typescript\n  const emailField = new TextField('email')\n    .setLabel('Email Address')\n    .isEmail() // Specific method for email validation\n    .setPlaceholder('Enter your email')\n    .setRequired('Email is required.');\n  ```\n- **Centralized Business Logic and Validation** : Each specialized class (e.g., `TextField`) can encapsulate its own Zod validation rules and behavior logics. For example, the `.isEmail()` method on a `TextField` instance could automatically set up the appropriate `zodObject` for email validation. This avoids duplication and ensures consistency.\n- **Easier Extensibility** : Adding a new field type or validation rule becomes simpler. You just need to create a new class inheriting from `FieldFactory` (or another field class) or add a new method to an existing class.\n- **Better Developer Experience** : Using classes and TypeScript provides strong typing, advanced autocompletion in IDEs, and integrated documentation via TSDoc, reducing errors and increasing productivity.\n- **Scalable Configuration** : For simple needs, literal object configuration remains possible. But for complex forms, the object-oriented approach with `FieldFactory` allows for deeper structuring without sacrificing readability or maintainability.\n\n### Usage and Utility\n\n`FieldFactory` and its derived classes allow you to :\n\n1.  **Define form fields in a declarative and expressive way.**\n2.  **Centralize business logic and validation** within field classes.\n3.  **Facilitate maintenance and evolution** of form configuration.\n4.  **Benefit from strong typing and advanced autocompletion.**\n\n### Example Usage with `TextField`\n\nThe `TextField` class (located in `frontend/src/components/ReactFormMaker/FormFields/Class/TextFields.class.ts`) is an example of a class derived from `FieldFactory`. Here is how to use it to define text fields and integrate them into `ReactFormMaker` :\n\n```typescript\n// Make sure the import path is correct\nimport { TextField } from './frontend/src/components/ReactFormMaker/FormFields/Class/TextFields.class';\nimport ReactFormMaker from './frontend/src/components/ReactFormMaker/ReactFormMaker'; // Adjust the path\nimport { FieldValues } from 'react-hook-form';\nimport { z } from 'zod'; // Import Zod for other fields if necessary\n\n// Define fields using the TextField class\nconst usernameField = new TextField('username') // 'username' is the inputName\n  .setLabel('Username')\n  .setPlaceholder('Your unique username')\n  .setRequired('Username is required.') // Applies a simple Zod validation\n  .setMinLength(5, 'Must be at least 5 characters long.');\n\nconst emailField = new TextField('userEmail')\n  .setLabel('Email Address')\n  .isEmail() // Applies the Zod validation for email and sets a default placeholder\n  .setRequired('Email is required.');\n\nconst websiteField = new TextField('userWebsite')\n  .setLabel('Website (optional)')\n  .isUrl() // Applies the Zod validation for URL and a onSelect behavior\n  .setZodObject(z.string().url().optional()); // Allows overriding or refining the ZodObject\n\n// The configured field objects can be directly used in formfields.\n// The FieldFactory class's .getConfig() method returns the FieldReactFormMaker object.\nconst myFormFields = [\n  usernameField.getConfig(),\n  emailField.getConfig(),\n  websiteField.getConfig(),\n  // You can still mix with literal configuration objects\n  {\n    inputName: 'age',\n    inputType: 'number',\n    label: 'Age',\n    zodObject: z.number().min(18)\n  }\n];\n\nconst MyComponentUsingFieldFactory = () => {\n  const handleSubmit = (data: FieldValues) => {\n    console.log('Form data:', data);\n  };\n\n  return (\n    <ReactFormMaker\n      formfields={myFormFields}\n      onSubmit={handleSubmit}\n      btnTextSubmit=\"Submit\"\n    />\n  );\n};\n\nexport default MyComponentUsingFieldFactory;\n```\n\nThis approach promotes better organization and reusability of your form field configuration, especially for large applications.\n\n## Style Customization\n\nMost form fields and the `ReactFormMaker` component itself rely on the **ShadCN/UI** component library, which is based on **Tailwind CSS**. The goal is to centralize style management to ensure consistency and maintainability, while offering multiple levels of customization to adapt to specific needs.\n\n### Best practices for style customization\n\nHere are the recommended approaches to customize the appearance of your forms:\n\n1.  **Centralization via Tailwind configuration (`tailwind.config.ts`)**\n    - **Description** : This is the preferred method for global and consistent modifications. By adjusting your `tailwind.config.ts` (or `tailwind.config.js`, `postcss.config.mjs` depending on your setup), you can redefine primary colors, fonts, spacings, etc., that will be applied across your entire UI, including ShadCN components used by `ReactFormMaker`.\n    - **Advantage** : Maintains stylistic consistency throughout your application.\n\n2.  **Overriding ShadCN/UI components (in the `ui` folder)**\n    - **Description** : When you initialize ShadCN/UI in your project (via `npx shadcn-ui@latest init`), the components you choose to use (like `Button`, `Input`, `Select`, etc.) are added to your code base, typically in a `components/ui` folder. `ReactFormMaker` uses these components. You can directly modify the code of these components for more specific adjustments that may not be possible via Tailwind configuration alone.\n    - **Advantage** : Fine control over the appearance and behavior of base components.\n    - **Note** : Be aware that if you update ShadCN components via their CLI (`add` for an existing component), your local changes may be overwritten. Manage these components as part of your source code.\n\n3.  **Adjusting styles of project-specific components (`ReactFormMaker/enhancements` and others)**\n    - **Description** : `ReactFormMaker` may contain internal components or \"enhancements\" that are not directly raw ShadCN/UI components. If these components have their own style files or allow style props, you can adjust them there. The exact path may vary, but explore the `ReactFormMaker` folder structure for such components.\n    - **Advantage** : Targets specific elements to the logic of `ReactFormMaker`.\n\n4.  **One-off customization via the `className` prop**\n    - **Description** :\n      - **On the `ReactFormMaker` component** : The `className` prop allows applying Tailwind (or global CSS) classes to the main container of the form. The `footerClassName` specifically targets the footer of the form.\n      - **On field definitions (`formfields`)** : Each field object in the `formfields` array (whether a `FieldReactFormMaker`, `ReactFormMakerFieldset`, etc.) can accept a `className` (or `classname` for `CompositeField` and its derivatives like `ReactFormMakerFieldset`, `legendClassName` for fieldset legends). These classes are applied to the wrapper element of the field or to the specific element.\n    - **Using `cn`** : It is recommended to use a utility function like `cn` (often provided by ShadCN/UI, based on `clsx` and `tailwind-merge`) to build your `className` strings. `cn` intelligently merges Tailwind classes, handles conditional classes, and avoids class conflicts.\n      ```typescript\n      // Example in field configuration\n      {\n        inputName: 'email',\n        inputType: 'text',\n        label: 'Email',\n        className: cn('border-blue-500', { 'bg-gray-100': isDisabled })\n      }\n      ```\n    - **Advantage** : Ideal for specific adjustments to a field or form without affecting others. Very flexible for dynamic changes based on state.\n\nBy combining these approaches, you can achieve precise control over the appearance of your forms generated by `ReactFormMaker`, while maintaining a consistent and easy-to-manage style base.\n\n## Advanced Aspects\n\nThis section covers more advanced features of `ReactFormMaker`, intended for users looking to extend or deeply customize the behavior of their forms.\n\n### Custom Hooks\n\n`ReactFormMaker` internally uses several React hooks to manage its logic. While direct use is generally not necessary for most use cases, knowing them can be useful for advanced extension or debugging scenarios.\n\n- **`useReactFormMaker<T extends FieldValues>(formfieldsAttributes: CompositeField[])`**\n  - **Role** : This hook is at the core of form generation. It takes the `formfields` configuration, initializes `react-hook-form` (including generating the Zod schema from fields' `zodObject` and managing default values), and returns the form instance (`form`), the generated Zod schema (`formSchema`), default values (`dataFieldsDefaultValues`), the raw Zod object (`zObject`), and a utility function `hasSubmitButton` to detect if a submit button is already present among the children.\n  - **Main utility** : Manages all the initialization logic of `react-hook-form` and transforms the `formfields` configuration into a usable Zod schema. Mainly used internally by the `ReactFormMaker` component.\n\n- **`useFormHandlers<T extends FieldValues>({ onSubmit: (data, errors) => void })`**\n  - **Role** : This hook simplifies handling `react-hook-form` submit callbacks. It takes a single `onSubmit` function (the one you pass to `ReactFormMaker`) and splits it into two handlers: `onValid` (for successful submissions) and `onInvalid` (for submissions failed due to validation errors).\n  - **Main utility** : Provides the `onValid` and `onInvalid` functions that `react-hook-form` expects for its own `handleSubmit` function. Used internally to wire your `onSubmit` callback to `react-hook-form`'s submit system.\n\n- **`useFormFieldsMap<T extends FieldValues>(form: UseFormReturn<T>)`**\n  - **Role** : This hook is responsible for the recursive rendering of form fields and fieldsets. It returns functions (`FormFieldsMap`, `FieldsetMap`) that iterate over the `formfields` configuration and display the appropriate field components (like `FormFieldElement`, `DivElementField`) or fieldsets. It also returns `InpuTComponentCallBack`, a memoized function to render the `InputComponent` used for each field.\n  - **Main utility** : Manages the mapping logic of field configuration to rendered JSX elements. This is the dynamic rendering engine of the fields. Mainly for internal use.\n\nThese hooks encapsulate the complexity of integrating with `react-hook-form` and the dynamic rendering logic. To extend `ReactFormMaker`, it is generally better to create custom field types or use the existing configuration props rather than interacting directly with these hooks, unless you are building a very specific form functionality.\n\n### Event Handling on Fields\n\nYou can attach event handlers directly to your fields when configuring them in the `formfields` array. Common events like `onChange`, `onBlur`, and `onClick` are supported.\n\nThese callback functions receive a `FormFieldEvent` object that contains two properties :\n\n- `event`: The raw browser event (e.g., `React.ChangeEvent<HTMLInputElement>`, `React.FocusEvent<HTMLInputElement>`).\n- `form`: The complete `react-hook-form` instance (`UseFormReturn<T>`). This gives you direct access to all methods of `react-hook-form` (like `setValue`, `getValue`, `trigger`, `formState`, etc.) inside your event handler.\n\nFor the exact signature and more details on `FormFieldEvent`, refer to the documentation of the `FieldReactFormMaker` interface (see \"Events\" section).\n\n#### Example using `onChange`\n\n```typescript\nimport { FormFieldEvent } from './frontend/src/components/ReactFormMaker/interfaces/FormFieldEvent'; // Adjust the path\nimport { FieldValues } from 'react-hook-form';\nimport { z } from 'zod';\n\n// Suppose TFormData is your form data type\ninterface TFormData extends FieldValues {\n  firstName: string;\n  lastName?: string;\n  hasNickname?: boolean;\n  nickname?: string;\n}\n\nconst handleFirstNameChange = (fieldEvent: FormFieldEvent<TFormData>) => {\n  const { event, form } = fieldEvent;\n  const newValue = (event.target as HTMLInputElement).value;\n\n  console.log(`First name is now: ${newValue}`);\n\n  // Example of interacting with react-hook-form :\n  // Dynamically update another field\n  form.setValue('lastName', newValue + ' Smith');\n\n  // Trigger validation for another field\n  if (newValue.length > 2) {\n    form.trigger('lastName');\n  }\n};\n\nconst handleNicknameVisibility = (fieldEvent: FormFieldEvent<TFormData>) => {\n  const { event, form } = fieldEvent;\n  const isChecked = (event.target as HTMLInputElement).checked;\n  // You could use form.setValue to show/hide or enable/disable the nickname field\n  // or just manage it locally if the nickname field is conditionally rendered\n  console.log(`Show nickname: ${isChecked}`);\n  if (!isChecked) {\n    form.setValue('nickname', ''); // Clear nickname if unchecked\n    form.unregister('nickname'); // Optional: unregister the field so it's not submitted\n  } else {\n    form.register('nickname'); // Register the field if it was unregistered\n  }\n};\n\nexport const formFieldsWithEvents: Array<FieldReactFormMaker> = [\n  {\n    inputName: 'firstName',\n    inputType: 'text',\n    label: 'First Name',\n    zodObject: z.string().min(1),\n    onChange: handleFirstNameChange,\n  },\n  {\n    inputName: 'hasNickname',\n    inputType: 'checkbox',\n    label: 'Do you have a nickname?',\n    onChange: handleNicknameVisibility,\n    zodObject: z.boolean().optional(),\n  },\n  {\n    inputName: 'nickname',\n    inputType: 'text',\n    label: 'Nickname (if applicable)',\n    // This field could be hidden/shown conditionally based on 'hasNickname'\n    // using the 'isHide' property and updating it via form.setValue in handleNicknameVisibility,\n    // or by managing it in the JSX rendering of your component.\n    // For this example, we assume it's always visible but its value is managed.\n    zodObject: z.string().optional(),\n  },\n  // ... other fields\n];\n\n// Then use formFieldsWithEvents in <ReactFormMaker formfields={formFieldsWithEvents} ... />\n```\n\nIn this example, `handleFirstNameChange` is called whenever the value of the \"firstName\" field changes. It has access to the browser event and the complete `react-hook-form` instance, allowing for complex logics and interactions between fields. Similarly, `handleNicknameVisibility` reacts to the checkbox changes to potentially manipulate the visibility or state of the \"nickname\" field.\n",
  "/ReactFormMaker/enhancements/CheckboxWithText.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { cn } from '../../../lib/utils';\n\nfunction CheckboxWithText(params: FieldParams): JSX.Element {\n  const { zFields, fieldProps, indexField } = params;\n  const classNameLabel =\n    'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70';\n  const classNameContainer = 'flex space-x-2 items-top';\n\n  return (\n    <div className={classNameContainer}>\n      <Checkbox\n        key={indexField}\n        className={cn(fieldProps.className)}\n        defaultChecked={Boolean(zFields.value)}\n        id={fieldProps.inputName}\n        {...zFields}\n        onCheckedChange={(checked: boolean) => {\n          zFields.onChange(checked);\n        }}\n      />\n      <div className=\"grid gap-1.5 leading-none\">\n        <label htmlFor={fieldProps.inputName} className={classNameLabel}>\n          {fieldProps.label}\n        </label>\n      </div>\n    </div>\n  );\n}\n\nexport default CheckboxWithText;\n",
  "/ReactFormMaker/enhancements/DatePickerSimple.tsx": "import React from 'react';\nimport { CalendarIcon } from '@radix-ui/react-icons';\nimport { format } from 'date-fns';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport {\n  Popover,\n  PopoverTrigger,\n  PopoverContent,\n} from '@/components/ui/popover';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport { cn } from '../../../lib/utils';\n\nconst DatePickerSimple = React.forwardRef<HTMLButtonElement, FieldParams>(\n  ({ zFields, fieldProps }, ref) => {\n    const [date, setDate] = React.useState<Date | undefined>();\n\n    return (\n      <Popover>\n        <PopoverTrigger asChild className={cn(fieldProps.className)}>\n          <Button\n            ref={ref}\n            variant=\"outline\"\n            className={cn(\n              'w-[240px] justify-start text-left font-normal',\n              !date && 'text-muted-foreground',\n            )}\n          >\n            <CalendarIcon className=\"w-4 h-4 mr-2\" />\n            {date ? format(date, 'PPP') : <span>{fieldProps.placeholder}</span>}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\n          <div>\n            <Calendar\n              mode=\"single\"\n              selected={date}\n              onSelect={(selectDate) => {\n                setDate(selectDate);\n                zFields.onChange(selectDate);\n              }}\n            />\n          </div>\n        </PopoverContent>\n      </Popover>\n    );\n  },\n);\nDatePickerSimple.displayName = 'DatePickerSimple';\n\nexport default DatePickerSimple;\n",
  "/ReactFormMaker/enhancements/DateRangePicker.tsx": "'use client';\n\nimport * as React from 'react';\nimport type {\n  DateRange,\n  DayPickerProps,\n  DropdownProps,\n} from 'react-day-picker';\nimport { CalendarIcon } from '@radix-ui/react-icons';\nimport { addDays, format, getYear, set, formatDistance } from 'date-fns';\nimport { ChevronLeft, ChevronRight } from 'lucide-react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport YearsDropdownCustom from './YearsDropdown';\n\nexport function DateRangePicker({ zFields, fieldProps }: FieldParams) {\n  const defaultRange = fieldProps?.defaultValues as DateRange | undefined;\n\n  const [date, setDate] = React.useState<DateRange>({\n    from: defaultRange?.from || addDays(new Date(), 1),\n    to: defaultRange?.to || addDays(new Date(), 2),\n  });\n  const [selectedYearFrom, setSelectedYearFrom] = React.useState<number>(\n    getYear(new Date()),\n  );\n  const [selectedYearTo, setSelectedYearTo] = React.useState<number>(\n    getYear(new Date()),\n  );\n  const dateEndMouth = set(new Date(), { month: 11, date: 31 });\n  dateEndMouth.setFullYear(dateEndMouth.getFullYear() + 100);\n\n  const modifiers: DayPickerProps['modifiers'] = {\n    selected: date,\n    range_start: date.from,\n    range_end: date.to,\n    range_middle: (day: Date) =>\n      date && date.from && date.to ? day > date.from && day < date.to : false,\n  };\n\n  React.useEffect(() => {\n    zFields.onChange(date);\n  }, [date]);\n\n  function onDayClickHandler(day: Date, range: 'from' | 'to') {\n    if (range === 'from') {\n      if (date?.from && day.toString() == date?.from.toString()) {\n        setDate({ ...date, from: undefined });\n      } else {\n        setDate({ ...date, from: day });\n      }\n    } else if (date?.to && day.toString() == date?.to.toString()) {\n      setDate({ ...date, to: undefined });\n    } else {\n      setDate({ ...date, to: day });\n    }\n  }\n\n  return (\n    <div className={cn('grid gap-2', fieldProps.className)}>\n      <Popover>\n        <PopoverTrigger asChild>\n          <Button\n            id=\"date\"\n            variant=\"outline\"\n            className={cn(\n              'w-[300px] justify-start text-left font-normal',\n              !date && 'text-muted-foreground',\n            )}\n          >\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\n            {date?.from ? (\n              date.to ? (\n                <>\n                  {format(date.from, 'LLL dd, y')} -{' '}\n                  {format(date.to, 'LLL dd, y')}\n                </>\n              ) : (\n                format(date.from, 'LLL dd, y')\n              )\n            ) : (\n              <span>Pick a date</span>\n            )}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\n          <div className=\"space-y-2 p-2 flex flex-row justify-between\">\n            <div className=\"mt-2\">\n              <h5 className=\"w-full text-center scroll-m-20 leading-7 text-xl font-semibold tracking-tight  m-2\">\n                Selected start date\n              </h5>\n              <Calendar\n                pagedNavigation\n                captionLayout=\"dropdown-years\"\n                endMonth={dateEndMouth}\n                modifiers={modifiers}\n                onDayClick={(day) => onDayClickHandler(day, 'from')}\n                numberOfMonths={1}\n                components={{\n                  Chevron: ({ ...props }) =>\n                    props.orientation === 'left' ? (\n                      <ChevronLeft {...props} className=\"h-4 w-4\" />\n                    ) : (\n                      <ChevronRight {...props} className=\"h-4 w-4\" />\n                    ),\n                  YearsDropdown: (props: DropdownProps) => {\n                    return (\n                      <YearsDropdownCustom\n                        {...props}\n                        range=\"from\"\n                        selectedYear={selectedYearFrom}\n                        setSelectedYear={setSelectedYearFrom}\n                      />\n                    );\n                  },\n                }}\n              />\n            </div>\n            <div>\n              <h5 className=\"w-full text-center scroll-m-20 text-xl font-semibold tracking-tight m-2\">\n                Selected end date\n              </h5>\n              <Calendar\n                pagedNavigation\n                captionLayout=\"dropdown-years\"\n                endMonth={dateEndMouth}\n                onDayClick={(day) => onDayClickHandler(day, 'to')}\n                modifiers={modifiers}\n                numberOfMonths={1}\n                components={{\n                  Chevron: ({ ...props }) =>\n                    props.orientation === 'left' ? (\n                      <ChevronLeft {...props} className=\"h-4 w-4\" />\n                    ) : (\n                      <ChevronRight {...props} className=\"h-4 w-4\" />\n                    ),\n                  YearsDropdown: (props: DropdownProps) => {\n                    return (\n                      <YearsDropdownCustom\n                        {...props}\n                        range=\"to\"\n                        selectedYear={selectedYearTo}\n                        setSelectedYear={setSelectedYearTo}\n                      />\n                    );\n                  },\n                }}\n              />\n            </div>\n          </div>\n          <div className=\"flex justify-center w-full mb-4\">\n            <span className=\"text-sm text-muted-foreground\">\n              {date && date.from && date.to\n                ? `The selected time slot is ${formatDistance(\n                    date.from,\n                    date.to,\n                  )}`\n                : 'Choose a date range'}\n            </span>\n          </div>\n        </PopoverContent>\n      </Popover>\n    </div>\n  );\n}\n",
  "/ReactFormMaker/enhancements/FileUploader/FileUploader.tsx": "'use client';\n\nimport {\n  Dispatch,\n  SetStateAction,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  useDropzone,\n  type DropzoneState,\n  type FileRejection,\n  type DropzoneOptions,\n} from 'react-dropzone';\nimport { toast } from 'sonner';\nimport { Trash2 as RemoveIcon } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Input } from '@/components/ui/input';\nimport { buttonVariants } from '@/components/ui/button';\n\ntype DirectionOptions = 'rtl' | 'ltr' | undefined;\n\ntype FileUploaderContextType = {\n  dropzoneState: DropzoneState;\n  isLOF: boolean;\n  isFileTooBig: boolean;\n  removeFileFromSet: (index: number) => void;\n  activeIndex: number;\n  setActiveIndex: Dispatch<SetStateAction<number>>;\n  orientation: 'horizontal' | 'vertical';\n  direction: DirectionOptions;\n};\n\nconst FileUploaderContext = createContext<FileUploaderContextType | null>(null);\n\nexport const useFileUpload = () => {\n  const context = useContext(FileUploaderContext);\n  if (!context) {\n    throw new Error('useFileUpload must be used within a FileUploaderProvider');\n  }\n  return context;\n};\n\nexport type FileUploaderProps = {\n  value: File[] | null;\n  reSelect?: boolean;\n  onValueChange: (value: File[] | null) => void;\n  dropzoneOptions: DropzoneOptions;\n  orientation?: 'horizontal' | 'vertical';\n};\n\n/**\n * File upload Docs: {@link: https://localhost:3000/docs/file-upload}\n */\n\nexport const FileUploader = forwardRef<\n  HTMLDivElement,\n  FileUploaderProps & React.HTMLAttributes<HTMLDivElement>\n>(\n  (\n    {\n      className,\n      dropzoneOptions,\n      value,\n      onValueChange,\n      reSelect,\n      orientation = 'vertical',\n      children,\n      dir,\n      ...props\n    },\n    ref,\n  ) => {\n    const [isFileTooBig, setIsFileTooBig] = useState(false);\n    const [isLOF, setIsLOF] = useState(false);\n    const [activeIndex, setActiveIndex] = useState(-1);\n    const {\n      accept = {\n        'image/*': ['.jpg', '.jpeg', '.png', '.gif'],\n      },\n      maxFiles = 1,\n      maxSize = 4 * 1024 * 1024,\n      multiple = true,\n    } = dropzoneOptions;\n\n    const reSelectAll = maxFiles === 1 ? true : reSelect;\n    const direction: DirectionOptions = dir === 'rtl' ? 'rtl' : 'ltr';\n\n    const removeFileFromSet = useCallback(\n      (i: number) => {\n        if (!value) return;\n        const newFiles = value.filter((_, index) => index !== i);\n        onValueChange(newFiles);\n      },\n      [value, onValueChange],\n    );\n\n    const handleKeyDown = useCallback(\n      (e: React.KeyboardEvent<HTMLDivElement>) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (!value) return;\n\n        const moveNext = () => {\n          const nextIndex = activeIndex + 1;\n          setActiveIndex(nextIndex > value.length - 1 ? 0 : nextIndex);\n        };\n\n        const movePrev = () => {\n          const nextIndex = activeIndex - 1;\n          setActiveIndex(nextIndex < 0 ? value.length - 1 : nextIndex);\n        };\n\n        const prevKey =\n          orientation === 'horizontal'\n            ? direction === 'ltr'\n              ? 'ArrowLeft'\n              : 'ArrowRight'\n            : 'ArrowUp';\n\n        const nextKey =\n          orientation === 'horizontal'\n            ? direction === 'ltr'\n              ? 'ArrowRight'\n              : 'ArrowLeft'\n            : 'ArrowDown';\n\n        if (e.key === nextKey) {\n          moveNext();\n        } else if (e.key === prevKey) {\n          movePrev();\n        } else if (e.key === 'Enter' || e.key === 'Space') {\n          if (activeIndex === -1) {\n            dropzoneState.inputRef.current?.click();\n          }\n        } else if (e.key === 'Delete' || e.key === 'Backspace') {\n          if (activeIndex !== -1) {\n            removeFileFromSet(activeIndex);\n            if (value.length - 1 === 0) {\n              setActiveIndex(-1);\n              return;\n            }\n            movePrev();\n          }\n        } else if (e.key === 'Escape') {\n          setActiveIndex(-1);\n        }\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [value, activeIndex, removeFileFromSet],\n    );\n\n    const onDrop = useCallback(\n      (acceptedFiles: File[], rejectedFiles: FileRejection[]) => {\n        const files = acceptedFiles;\n\n        if (!files) {\n          toast.error('file error , probably too big');\n          return;\n        }\n\n        const newValues: File[] = value ? [...value] : [];\n\n        if (reSelectAll) {\n          newValues.splice(0, newValues.length);\n        }\n\n        files.forEach((file) => {\n          if (newValues.length < maxFiles) {\n            newValues.push(file);\n          }\n        });\n\n        onValueChange(newValues);\n\n        if (rejectedFiles.length > 0) {\n          for (let i = 0; i < rejectedFiles.length; i++) {\n            if (rejectedFiles[i].errors[0]?.code === 'file-too-large') {\n              toast.error(\n                `File is too large. Max size is ${maxSize / 1024 / 1024}MB`,\n              );\n              break;\n            }\n            if (rejectedFiles[i].errors[0]?.message) {\n              toast.error(rejectedFiles[i].errors[0].message);\n              break;\n            }\n          }\n        }\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [reSelectAll, value],\n    );\n\n    useEffect(() => {\n      if (!value) return;\n      if (value.length === maxFiles) {\n        setIsLOF(true);\n        return;\n      }\n      setIsLOF(false);\n    }, [value, maxFiles]);\n\n    const opts = dropzoneOptions || { accept, maxFiles, maxSize, multiple };\n\n    const dropzoneState = useDropzone({\n      ...opts,\n      onDrop,\n      onDropRejected: () => setIsFileTooBig(true),\n      onDropAccepted: () => setIsFileTooBig(false),\n    });\n\n    return (\n      <FileUploaderContext.Provider\n        value={{\n          dropzoneState,\n          isLOF,\n          isFileTooBig,\n          removeFileFromSet,\n          activeIndex,\n          setActiveIndex,\n          orientation,\n          direction,\n        }}\n      >\n        <div\n          ref={ref}\n          tabIndex={0}\n          role=\"button\"\n          aria-label=\"Zone de dpt de fichiers\"\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\n            'grid w-full focus:outline-none overflow-hidden ',\n            className,\n            {\n              'gap-2': value && value.length > 0,\n            },\n          )}\n          dir={dir}\n          {...props}\n        >\n          {children}\n        </div>\n      </FileUploaderContext.Provider>\n    );\n  },\n);\n\nFileUploader.displayName = 'FileUploader';\n\nexport const FileUploaderContent = forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ children, className, ...props }, ref) => {\n  const { orientation } = useFileUpload();\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  return (\n    <div\n      className={cn('w-full px-1')}\n      ref={containerRef}\n      aria-description=\"content file holder\"\n    >\n      <div\n        {...props}\n        ref={ref}\n        className={cn(\n          'flex rounded-xl gap-1',\n          orientation === 'horizontal' ? 'flex-raw flex-wrap' : 'flex-col',\n          className,\n        )}\n      >\n        {children}\n      </div>\n    </div>\n  );\n});\n\nFileUploaderContent.displayName = 'FileUploaderContent';\n\nexport const FileUploaderItem = forwardRef<\n  HTMLDivElement,\n  { index: number } & React.HTMLAttributes<HTMLDivElement>\n>(({ className, index, children, ...props }, ref) => {\n  const { removeFileFromSet, activeIndex, direction } = useFileUpload();\n  const isSelected = index === activeIndex;\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        buttonVariants({ variant: 'ghost' }),\n        'h-6 p-1 justify-between cursor-pointer relative',\n        className,\n        isSelected ? 'bg-muted' : '',\n      )}\n      {...props}\n    >\n      <div className=\"font-medium leading-none tracking-tight flex items-center gap-1.5 h-full w-full\">\n        {children}\n      </div>\n      <button\n        type=\"button\"\n        className={cn(\n          'absolute',\n          direction === 'rtl' ? 'top-1 left-1' : 'top-1 right-1',\n        )}\n        onClick={() => removeFileFromSet(index)}\n      >\n        <span className=\"sr-only\">remove item {index}</span>\n        <RemoveIcon className=\"w-4 h-4 hover:stroke-destructive duration-200 ease-in-out\" />\n      </button>\n    </div>\n  );\n});\n\nFileUploaderItem.displayName = 'FileUploaderItem';\n\nexport const FileInput = forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, children, ...props }, ref) => {\n  const { dropzoneState, isFileTooBig, isLOF } = useFileUpload();\n  const rootProps = isLOF ? {} : dropzoneState.getRootProps();\n  return (\n    <div\n      ref={ref}\n      {...props}\n      className={`relative w-full ${\n        isLOF ? 'opacity-50 cursor-not-allowed ' : 'cursor-pointer '\n      }`}\n    >\n      <div\n        className={cn(\n          `w-full rounded-lg duration-300 ease-in-out\n         ${\n           dropzoneState.isDragAccept\n             ? 'border-green-500'\n             : dropzoneState.isDragReject || isFileTooBig\n               ? 'border-red-500'\n               : 'border-gray-300'\n         }`,\n          className,\n        )}\n        {...rootProps}\n      >\n        {children}\n      </div>\n      <Input\n        ref={dropzoneState.inputRef}\n        disabled={isLOF}\n        {...dropzoneState.getInputProps()}\n        className={`${isLOF ? 'cursor-not-allowed' : ''}`}\n      />\n    </div>\n  );\n});\n\nFileInput.displayName = 'FileInput';\n",
  "/ReactFormMaker/enhancements/FileUploader/variants/DefaultFileUploader.tsx": "'use client';\n\nimport { useState } from 'react';\nimport { type DropzoneOptions } from 'react-dropzone';\nimport { Paperclip } from 'lucide-react';\nimport {\n  type FileUploaderProps,\n  FileUploader,\n  FileUploaderContent,\n  FileUploaderItem,\n  FileInput,\n} from '@/components/ReactFormMaker/enhancements/FileUploader/FileUploader';\nimport { cn } from '@/lib/utils';\n\ninterface FileSvgDrawProps {\n  placeholder?: string | undefined;\n}\n\nfunction FileSvgDraw({ placeholder }: FileSvgDrawProps) {\n  return (\n    <>\n      <svg\n        className=\"w-8 h-8 mb-3 text-gray-500 dark:text-gray-400\"\n        aria-hidden=\"true\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        fill=\"none\"\n        viewBox=\"0 0 20 16\"\n      >\n        <path\n          stroke=\"currentColor\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          strokeWidth=\"2\"\n          d=\"M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2\"\n        />\n      </svg>\n      <p className=\"mb-1 text-sm text-gray-500 dark:text-gray-400\">\n        <span className=\"font-semibold\">Click to upload</span>\n        &nbsp; or drag and drop\n      </p>\n      <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n        {placeholder || 'Max file size: 4MB'}\n      </p>\n    </>\n  );\n}\n\nexport interface DefaultFileUploaderProps\n  extends Omit<FileUploaderProps, 'dropzoneOptions'>,\n    React.HTMLAttributes<HTMLDivElement> {\n  placeholder?: string;\n  value: File[] | null;\n  onValueChange: (value: File[] | null) => void;\n  dropzoneOptions?: DropzoneOptions;\n  className?: string;\n}\n\nfunction DefaultFileUploader({\n  placeholder,\n  ...props\n}: DefaultFileUploaderProps) {\n  const [files, setFiles] = useState<File[] | null>(props.value || null);\n\n  const dropZoneConfig = {\n    maxFiles: 5,\n    maxSize: 1024 * 1024 * 4,\n    multiple: true,\n  };\n\n  const handleOnchange = (files: File[] | null) => {\n    setFiles(files);\n    if (props.onValueChange) props.onValueChange(files);\n  };\n\n  return (\n    <FileUploader\n      value={files}\n      onValueChange={handleOnchange}\n      dropzoneOptions={props.dropzoneOptions || dropZoneConfig}\n      className={cn(\n        'relative bg-background rounded-lg p-2 border border-input shadow-sm',\n        props.className,\n      )}\n    >\n      <FileInput className=\"outline-dashed outline-1 outline-white\">\n        <div className=\"flex items-center justify-center flex-col pt-3 pb-4 w-full \">\n          <FileSvgDraw placeholder={placeholder} />\n        </div>\n      </FileInput>\n      <FileUploaderContent>\n        {files &&\n          files.length > 0 &&\n          files.map((file, i) => (\n            <FileUploaderItem key={i} index={i}>\n              <Paperclip className=\"h-4 w-4 stroke-current\" />\n              <span>{file.name}</span>\n            </FileUploaderItem>\n          ))}\n      </FileUploaderContent>\n    </FileUploader>\n  );\n}\n\nexport default DefaultFileUploader;\n",
  "/ReactFormMaker/enhancements/InputPasswordVisibility.tsx": "import React from 'react';\nimport { EyeClosedIcon, EyeOpenIcon } from '@radix-ui/react-icons';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { cn, mergeRefs } from '@/lib/utils';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\n\nconst InputPasswordVisibility = React.forwardRef<HTMLInputElement, FieldParams>(\n  ({ zFields, fieldProps, indexField, id }, _ref) => {\n    const [showPassword, setShowPassword] = React.useState(false);\n    const mergedRef = mergeRefs(_ref, zFields.ref);\n\n    const inputValue: string =\n      zFields.value !== undefined ? String(zFields.value) : '';\n\n    return (\n      <div className={cn('flex flex-row items-center', fieldProps.className)}>\n        <Input\n          id={id ?? fieldProps.inputName}\n          className=\" rounded-[var(--radius)_0px_0px_var(--radius)] w-[calc(100%_-_49px)] border-r-[none]\"\n          key={indexField}\n          type={showPassword ? 'text' : 'password'}\n          placeholder={fieldProps.placeholder}\n          {...zFields}\n          ref={mergedRef}\n          value={inputValue}\n        />\n        <Button\n          className=\"!rounded-[0px_var(--radius)_var(--radius)_0px] bg-white\"\n          variant=\"outline\"\n          type=\"button\"\n          onClick={() => setShowPassword((prev) => !prev)}\n        >\n          {showPassword ? <EyeOpenIcon /> : <EyeClosedIcon />}\n        </Button>\n      </div>\n    );\n  },\n);\nInputPasswordVisibility.displayName = 'InputPasswordVisibility';\n\nexport default InputPasswordVisibility;\n",
  "/ReactFormMaker/enhancements/MultiSelect/BadgeItem.tsx": "import React, { forwardRef } from 'react';\nimport { Cross1Icon } from '@radix-ui/react-icons';\nimport { cn } from '@/lib/utils';\nimport { type Option } from '../../utils/typeGuards/optionsFields.TypeGuards';\n\nexport interface BadgeItemParams extends React.ComponentProps<'div'> {\n  option: Option | undefined;\n  onRemove: (value: string | number) => void;\n  className?: string;\n}\n\nconst BadgeItem = forwardRef<HTMLDivElement, BadgeItemParams>((props, ref) => {\n  const { option, onRemove, className } = props;\n\n  const [isHovered, setIsHovered] = React.useState(false);\n\n  if (!option) return null;\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        'flex flex-row items-center justify-between px-2 break-words py-1 rounded-lg text-primary-background border border-input bg-background shadow-sm gap-2 transition-colors w-full max-w-full',\n        { 'bg-accent': isHovered },\n        className,\n      )}\n    >\n      {option && option.label}\n      <button\n        className={cn(\n          'flex item-center justify-center rounded-full bg-muted text-primary-background h-3 w-3 shadow-sm hover:bg-accent hover:text-accent-foreground transition',\n          { 'bg-accent text-accent-foreground scale-110 ': isHovered },\n        )}\n      >\n        <Cross1Icon\n          className={cn('w-3 h-3')}\n          onClick={() => onRemove(option.value)}\n          onMouseEnter={() => setIsHovered(true)}\n          onMouseLeave={() => setIsHovered(false)}\n        />\n      </button>\n    </div>\n  );\n});\n\nBadgeItem.displayName = 'BadgeItem';\n\nexport default BadgeItem;\n",
  "/ReactFormMaker/enhancements/MultiSelect/MultiSelect.tsx": "'use client';\n\nimport * as React from 'react';\nimport { type ClassValue } from 'clsx';\nimport { CaretSortIcon, CheckIcon } from '@radix-ui/react-icons';\nimport useResizeObserver from '@react-hook/resize-observer';\nimport { cn } from '@/lib/utils';\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport BadgeItem from './BadgeItem';\n\nexport type Option = { value: string | number; label: string };\n\nexport interface MultiSelectParams\n  extends React.ComponentProps<typeof Popover> {\n  defaultValues?: string[];\n  onChange: (values: string[] | number[]) => void;\n  options: { value: string | number; label: string }[];\n  placeholder?: string;\n  legend?: string;\n  id: string;\n  className?: ClassValue[] | string | undefined;\n}\n/**\n * ## MultiSelect Autocomplete\n *\n * A select autocomplete component that allows the user to select an option from a list of options.\n *\n * ### Attributes\n *\n * | Name | isRequired | Description | Type |\n * | --- | --- | --- | --- |\n * | defaultValue | false | The default value of the select autocomplete | string |\n * | onChange | true | The function to call when the value changes | (value: string) => void |\n * | options | true | The list of options to select from | { value: string; label: string }[] |\n * | placeholder | false | The placeholder text | string |\n * | legend | false | The legend text | string |\n *\n * #### Other attributes\n *\n * | Name | Description | Type |\n * | --- | --- | --- |\n * | children | The children of the component | React.ReactNode |\n * | open | The state of the popover | boolean |\n * | defaultOpen | The default state of the popover | boolean |\n * | onOpenChange | The function to call when the popover state changes | (open: boolean) => void |\n * | modal | The modal state of the popover | boolean |\n *\n * ### Usage & comportment\n *\n * - On Focus: The component displays a list of options.\n * - On Blur: The component hides the list of options.\n * - On Click: The component selects an option and puts it in the input. (the value is stored in the state)\n * - On Change: The component calls the `onChange` function with the selected value.\n *\n *\n * @param param0\n * @returns\n */\nexport const MultiSelect = React.forwardRef<HTMLDivElement, MultiSelectParams>(\n  (\n    {\n      defaultValues,\n      onChange,\n      options,\n      placeholder,\n      legend = 'Select option...',\n      id,\n      className,\n      ...props\n    }: MultiSelectParams,\n    ref,\n  ) => {\n    const inputTrigger = React.useRef<HTMLDivElement>(null);\n    const [open, setOpen] = React.useState(props.defaultOpen || false);\n    const [value, setValue] = React.useState<string[] | number[]>(\n      defaultValues || [],\n    );\n    const [currentOption, setCurrentOption] = React.useState<Option[] | null>(\n      options,\n    );\n    const [widthCombobox, setWidthCombobox] = React.useState<number | null>(\n      null,\n    );\n\n    useResizeObserver(inputTrigger, (entry) => {\n      setWidthCombobox(entry.borderBoxSize[0].inlineSize);\n    });\n\n    function pushValue(newValue: string | number): void {\n      if (\n        (value.every((item) => typeof item === 'string') &&\n          typeof newValue === 'string') ||\n        (value.length === 0 && typeof newValue === 'string')\n      ) {\n        const newArr = [...(value as string[]), newValue];\n        setValue(newArr);\n        onChange(newArr);\n      } else if (\n        (value.every((item) => typeof item === 'number') &&\n          typeof newValue === 'number') ||\n        (value.length === 0 && typeof newValue === 'number')\n      ) {\n        const newArr = [...(value as number[]), newValue];\n        setValue(newArr);\n        onChange(newArr);\n      } else {\n        console.warn(\n          'HAS every item go number ?',\n          value.every((item) => typeof item === 'number'),\n          value,\n        );\n        console.warn(\n          `Type mismatch: expected 'string' or 'number', got ${typeof newValue}`,\n        );\n      }\n    }\n\n    function removeValue(valueToRemove: string | number) {\n      let newArr: typeof value;\n      if (\n        (value.every((item) => typeof item === 'string') &&\n          typeof valueToRemove === 'string') ||\n        (value.length === 0 && typeof valueToRemove === 'string')\n      ) {\n        newArr = value.filter((v) => v !== valueToRemove) as string[];\n      } else if (\n        (value.every((item) => typeof item === 'number') &&\n          typeof valueToRemove === 'number') ||\n        (value.length === 0 && typeof valueToRemove === 'number')\n      ) {\n        newArr = (value as number[]).filter((v) => v !== valueToRemove);\n      } else {\n        console.warn(\n          `Type mismatch: expected 'string' or 'number', got ${typeof valueToRemove}`,\n        );\n        return;\n      }\n      setValue(newArr);\n      onChange(newArr);\n      if (newArr.length === 0) {\n        setCurrentOption(options);\n      }\n    }\n\n    const handleInputChange = (valueLabel: string) => {\n      const newValue = options.filter((option) =>\n        option.label\n          .toLowerCase()\n          .trim()\n          .includes(valueLabel.toLowerCase().trim()),\n      );\n\n      setCurrentOption(newValue);\n    };\n\n    function renderBadges() {\n      if (!value.length) return <span>{legend}</span>;\n      return value.map((v) => {\n        const optionItem = options.find((option) => option.value === v);\n        // eslint-disable-next-line react/jsx-no-bind\n        return <BadgeItem key={v} option={optionItem} onRemove={removeValue} />;\n      });\n    }\n\n    return (\n      <div ref={ref} className=\"w-full\">\n        <Popover open={open} onOpenChange={setOpen} {...props}>\n          <PopoverTrigger asChild>\n            <div\n              ref={inputTrigger}\n              className={cn(\n                'w-full max-w-full wrap p-2 inline-flex rounded-md transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50',\n                'border border-input bg-background-muted shadow-sm hover:bg-accent hover:text-accent-foreground',\n                className,\n              )}\n              role=\"combobox\"\n              aria-expanded={open}\n              aria-controls={id}\n              aria-haspopup=\"listbox\"\n              aria-owns={id}\n              aria-autocomplete=\"list\"\n              id={id}\n            >\n              <div className=\"flex flex-wrap gap-2 w-full max-w-full\">\n                {renderBadges()}\n              </div>\n              <CaretSortIcon className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n            </div>\n          </PopoverTrigger>\n          <PopoverContent\n            className=\"w-[100%] p-0\"\n            style={{\n              width: `${widthCombobox}px`,\n            }}\n          >\n            <Command>\n              <CommandInput\n                placeholder={placeholder}\n                className=\"h-9\"\n                onValueChange={(output) => handleInputChange(output)}\n              />\n              <CommandList>\n                <CommandEmpty>No option found.</CommandEmpty>\n                <CommandGroup>\n                  {currentOption &&\n                    currentOption.map((option) => (\n                      <CommandItem\n                        key={option.value}\n                        value={option.label}\n                        onSelect={(currentValue) => {\n                          const selectedValue = options.find(\n                            (optionElement) =>\n                              optionElement.label === currentValue,\n                          )?.value;\n\n                          if (!selectedValue) {\n                            return;\n                          }\n\n                          // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                          value.includes(selectedValue as never)\n                            ? removeValue(selectedValue)\n                            : pushValue(selectedValue);\n                        }}\n                      >\n                        {option.label}\n                        <CheckIcon\n                          className={cn(\n                            'ml-auto h-4 w-4',\n                            value.includes(option.value as never)\n                              ? 'opacity-100'\n                              : 'opacity-0',\n                          )}\n                        />\n                      </CommandItem>\n                    ))}\n                </CommandGroup>\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n      </div>\n    );\n  },\n);\nMultiSelect.displayName = 'MultiSelect';\nexport default MultiSelect;\n",
  "/ReactFormMaker/enhancements/PhoneInput.tsx": "import * as React from 'react';\nimport { type CountryCode } from 'libphonenumber-js/core';\nimport { CheckIcon, ChevronsUpDown } from 'lucide-react';\nimport * as RPNInput from 'react-phone-number-input';\nimport flags from 'react-phone-number-input/flags';\n\nimport { ScrollArea } from '@radix-ui/react-scroll-area';\nimport { Button } from '@/components/ui/button';\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command';\nimport { Input } from '@/components/ui/input';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport { cn } from '@/lib/utils';\n\ninterface CountrySelectOptionProps extends RPNInput.FlagProps {\n  selectedCountry: RPNInput.Country;\n  onChange: (country: RPNInput.Country) => void;\n}\n\ntype IpApiInfo = {\n  ip: string;\n  network: string;\n  version: string;\n  city: string;\n  region: string;\n  region_code: string;\n  country: string;\n  country_name: string;\n  country_code: CountryCode;\n  country_code_iso3: string;\n  country_capital: string;\n  country_tld: string;\n  continent_code: string;\n  in_eu: boolean;\n  postal: string;\n  latitude: number;\n  longitude: number;\n  timezone: string;\n  utc_offset: string;\n  country_calling_code: string;\n  currency: string;\n  currency_name: string;\n  languages: string;\n  country_area: number;\n  country_population: number;\n  asn: string;\n  org: string;\n};\n\ntype PhoneInputProps = Omit<\n  React.ComponentProps<'input'>,\n  'onChange' | 'value' | 'ref'\n> &\n  Omit<RPNInput.Props<typeof RPNInput.default>, 'onChange'> & {\n    onChange?: (value: RPNInput.Value) => void;\n  };\n\nconst InputComponent = React.forwardRef<\n  HTMLInputElement,\n  React.ComponentProps<'input'>\n>(({ className, ...props }, ref) => (\n  <Input\n    className={cn('rounded-e-lg rounded-s-none', className)}\n    {...props}\n    ref={ref}\n  />\n));\nInputComponent.displayName = 'InputComponent';\n\ntype CountryEntry = { label: string; value: RPNInput.Country | undefined };\n\ntype CountrySelectProps = {\n  disabled?: boolean;\n  value: RPNInput.Country;\n  options: CountryEntry[];\n  onChange: (country: RPNInput.Country) => void;\n};\n\nfunction FlagComponent({ country, countryName }: RPNInput.FlagProps) {\n  const Flag = flags[country];\n\n  return (\n    <span className=\"flex justify-center items-center h-4 w-6 overflow-hidden rounded-sm bg-foreground/20\">\n      {Flag && <Flag title={countryName} />}\n    </span>\n  );\n}\n\nfunction CountrySelectOption({\n  country,\n  countryName,\n  selectedCountry,\n  onChange,\n}: CountrySelectOptionProps) {\n  return (\n    <CommandItem className=\"gap-2\" onSelect={() => onChange(country)}>\n      <FlagComponent country={country} countryName={countryName} />\n      <span className=\"flex-1 text-sm\">{countryName}</span>\n      <span className=\"text-sm text-foreground/50\">{`+${RPNInput.getCountryCallingCode(country)}`}</span>\n      <CheckIcon\n        className={`ml-auto size-4 ${country === selectedCountry ? 'opacity-100' : 'opacity-0'}`}\n      />\n    </CommandItem>\n  );\n}\n\nfunction CountrySelect({\n  disabled,\n  value: selectedCountry,\n  options: countryList,\n  onChange,\n}: CountrySelectProps) {\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          className=\"flex gap-1 rounded-e-none rounded-s-lg border-r-0 px-3 focus:z-10\"\n          disabled={disabled}\n        >\n          <FlagComponent\n            country={selectedCountry}\n            countryName={selectedCountry}\n          />\n          <ChevronsUpDown\n            className={cn(\n              '-mr-2 size-4 opacity-50',\n              disabled ? 'hidden' : 'opacity-100',\n            )}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[300px] p-0\">\n        <Command>\n          <CommandInput placeholder=\"Search country...\" />\n          <CommandList>\n            <ScrollArea className=\"h-72\">\n              <CommandEmpty>No country found.</CommandEmpty>\n              <CommandGroup>\n                {countryList.map(({ value, label }) =>\n                  value ? (\n                    <CountrySelectOption\n                      key={value}\n                      country={value}\n                      countryName={label}\n                      selectedCountry={selectedCountry}\n                      onChange={onChange}\n                    />\n                  ) : null,\n                )}\n              </CommandGroup>\n            </ScrollArea>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  );\n}\n\nconst PhoneInput: React.ForwardRefExoticComponent<PhoneInputProps> =\n  React.forwardRef<React.ElementRef<typeof RPNInput.default>, PhoneInputProps>(\n    ({ className, onChange, ...props }, ref) => {\n      const [defaultCountry, setDefaultCountry] = React.useState<\n        RPNInput.Country | undefined\n      >(undefined);\n\n      React.useEffect(() => {\n        const fetchCountry = async () => {\n          try {\n            const response = await fetch('https://ipapi.co/json/');\n            const data = (await response.json()) as IpApiInfo;\n            setDefaultCountry(data.country_code);\n          } catch (error) {\n            console.warn('Error fetching geolocation data:', error);\n          }\n        };\n\n        fetchCountry().catch((error) => {\n          console.warn('Error fetching country data:', error);\n        });\n      }, []);\n\n      return (\n        // eslint-disable-next-line react/jsx-pascal-case\n        <RPNInput.default\n          ref={ref}\n          international\n          defaultCountry={defaultCountry}\n          className={cn('flex', className)}\n          flagComponent={FlagComponent}\n          countrySelectComponent={CountrySelect}\n          inputComponent={InputComponent}\n          smartCaret\n          focusInputOnCountrySelection\n          addInternationalOption\n          /**\n           * Handles the onChange event.\n           *\n           * react-phone-number-input might trigger the onChange event as undefined\n           * when a valid phone number is not entered. To prevent this,\n           * the value is coerced to an empty string.\n           *\n           * @param {E164Number | undefined} value - The entered value\n           */\n          onChange={(value) => onChange?.(value || ('' as RPNInput.Value))}\n          {...props}\n        />\n      );\n    },\n  );\nPhoneInput.displayName = 'PhoneInput';\n\nexport default PhoneInput;\n",
  "/ReactFormMaker/enhancements/SelectAutocomplete.tsx": "'use client';\n\nimport * as React from 'react';\nimport { CaretSortIcon, CheckIcon } from '@radix-ui/react-icons';\n\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport {\n  type Option,\n  isOption,\n  isOptionsArray,\n} from '../utils/typeGuards/optionsFields.TypeGuards';\n\nexport interface SelectAutocompleteParams\n  extends React.ComponentProps<typeof Popover> {\n  defaultValue?: string | number;\n  onChange: (value: string | number | null) => void;\n  options: Option[] | string[];\n  placeholder?: string;\n  legend?: string;\n  id: string;\n}\n/**\n * ## Select Autocomplete\n *\n * A select autocomplete component that allows the user to select an option from a list of options.\n *\n * ### Attributes\n *\n * | Name | isRequired | Description | Type |\n * | --- | --- | --- | --- |\n * | defaultValue | false | The default value of the select autocomplete | string |\n * | onChange | true | The function to call when the value changes | (value: string) => void |\n * | options | true | The list of options to select from | { value: string; label: string }[] |\n * | placeholder | false | The placeholder text | string |\n * | legend | false | The legend text | string |\n *\n * #### Other attributes\n *\n * | Name | Description | Type |\n * | --- | --- | --- |\n * | children | The children of the component | React.ReactNode |\n * | open | The state of the popover | boolean |\n * | defaultOpen | The default state of the popover | boolean |\n * | onOpenChange | The function to call when the popover state changes | (open: boolean) => void |\n * | modal | The modal state of the popover | boolean |\n *\n * ### Usage & comportment\n *\n * - On Focus: The component displays a list of options.\n * - On Blur: The component hides the list of options.\n * - On Click: The component selects an option and puts it in the input. (the value is stored in the state)\n * - On Change: The component calls the `onChange` function with the selected value.\n *\n *\n * @param param0\n * @returns\n */\nexport const SelectAutocomplete = React.forwardRef<\n  HTMLButtonElement,\n  SelectAutocompleteParams\n>(\n  (\n    {\n      defaultValue,\n      onChange,\n      options,\n      placeholder,\n      legend = 'Select option...',\n      id,\n      ...props\n    },\n    ref,\n  ) => {\n    const [open, setOpen] = React.useState(props.defaultOpen || false);\n    const [value, setValue] = React.useState(defaultValue || null);\n    const [currentOption, setCurrentOption] = React.useState<\n      Option[] | string[]\n    >(options);\n\n    React.useEffect(() => {\n      onChange(value);\n    }, [value, onChange]);\n\n    const handleInputChange = (data: string) => {\n      if (!data || data === '') setCurrentOption(options);\n      else if (isOptionsArray(options)) {\n        setCurrentOption(\n          options.filter((optionItem) =>\n            optionItem.label\n              .toLowerCase()\n              .trim()\n              .includes(data.toLowerCase().trim()),\n          ),\n        );\n      } else {\n        setCurrentOption(\n          options.filter((optionItem) =>\n            optionItem.toLowerCase().trim().includes(data.toLowerCase().trim()),\n          ),\n        );\n      }\n    };\n\n    return (\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            ref={ref}\n            variant=\"outline\"\n            role=\"combobox\"\n            aria-expanded={open}\n            className=\"w-[200px] justify-between\"\n            aria-controls={id}\n            aria-haspopup=\"listbox\"\n            aria-owns={id}\n            aria-autocomplete=\"list\"\n            aria-activedescendant={value ? `option-${value}` : undefined}\n            id={id}\n          >\n            {value\n              ? (() => {\n                  const selected = options.find((option) =>\n                    isOption(option)\n                      ? option.value === value\n                      : option === value,\n                  );\n                  if (!selected) return legend;\n                  if (isOption(selected)) return selected.label;\n                  if (typeof selected === 'string') return selected;\n                  return legend;\n                })()\n              : legend}\n            <CaretSortIcon className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-[200px] p-0\">\n          <Command>\n            <CommandInput\n              placeholder={placeholder}\n              className=\"h-9\"\n              onValueChange={(inputValue) => handleInputChange(inputValue)}\n            />\n            <CommandList>\n              <CommandEmpty>No option found.</CommandEmpty>\n              <CommandGroup>\n                {currentOption &&\n                  currentOption.map((option) => (\n                    <CommandItem\n                      id={`option-${isOption(option) ? option.value : option}`}\n                      key={isOption(option) ? option.value : option}\n                      value={isOption(option) ? option.label : option}\n                      onSelect={(currentValue) => {\n                        const selectedValue = isOptionsArray(options)\n                          ? options.find(\n                              (optionItem) => optionItem.label === currentValue,\n                            )\n                          : options.find(\n                              (optionItem) => optionItem === currentValue,\n                            );\n                        if (!selectedValue) {\n                          return;\n                        }\n                        const extractedValue = isOption(selectedValue)\n                          ? selectedValue.value\n                          : selectedValue;\n                        const isUnselecting = extractedValue === value;\n                        setValue(isUnselecting ? '' : extractedValue);\n                        if (!isUnselecting) setOpen(false);\n                      }}\n                    >\n                      {isOption(option) ? option.label : option}\n                      <CheckIcon\n                        className={cn(\n                          'ml-auto h-4 w-4',\n                          value === (isOption(option) ? option.value : option)\n                            ? 'opacity-100'\n                            : 'opacity-0',\n                        )}\n                      />\n                    </CommandItem>\n                  ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n    );\n  },\n);\n\nSelectAutocomplete.displayName = 'SelectAutocomplete';\n",
  "/ReactFormMaker/enhancements/SelectSimple.tsx": "import React from 'react';\nimport * as SelectPrimitive from '@radix-ui/react-select';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport {\n  Select,\n  SelectTrigger,\n  SelectValue,\n  SelectContent,\n  SelectGroup,\n  SelectLabel,\n  SelectItem,\n} from '@/components/ui/select';\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\nimport { mergeRefs } from '@/lib/utils';\n\nconst SelectSimple = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>, // Type attendu par SelectTrigger\n  FieldParams\n>(\n  (\n    { zFields, fieldProps, indexField }: FieldParams,\n    ref: React.ForwardedRef<React.ElementRef<typeof SelectPrimitive.Trigger>>,\n  ) => {\n    const { ref: zFieldsRef, ...restZFields } = zFields;\n    return (\n      <Select\n        key={indexField}\n        // className={fieldProps.className}\n        disabled={fieldProps.disabled}\n        onValueChange={(value: string | number) => {\n          // si la valeut est un string numeraire alors on le change en number\n          let newValue = value;\n          if (\n            typeof value === 'string' &&\n            Number.isFinite(parseInt(value, 10))\n          ) {\n            newValue = Number(value);\n          }\n          zFields.onChange(newValue);\n        }}\n        {...restZFields}\n      >\n        <SelectTrigger ref={mergeRefs(ref, zFieldsRef)}>\n          <SelectValue placeholder={fieldProps.placeholder} />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectGroup>\n            <SelectLabel>{fieldProps.label}</SelectLabel>\n            {fieldProps.options?.map((option) => (\n              <SelectItem\n                key={isOption(option) ? `select-item-${option.value}` : option}\n                value={isOption(option) ? (option.value as string) : option}\n              >\n                {isOption(option) ? option.label : option}\n              </SelectItem>\n            ))}\n          </SelectGroup>\n        </SelectContent>\n      </Select>\n    );\n  },\n);\nSelectSimple.displayName = 'SelectSimple';\n\nexport default SelectSimple;\n",
  "/ReactFormMaker/enhancements/TileSelector/TileMultiSelector.tsx": "import React, { useState, useEffect, useRef, forwardRef } from 'react';\nimport { type ClassValue } from 'clsx';\nimport { cn } from '@/lib/utils';\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\nimport TileSelectorItem from './TileSelectorItem';\nimport {\n  isOption,\n  type Option,\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\n\nexport interface TileMultiSelectorProps {\n  options: string[] | Option[];\n  onSelect?: (values: string[] | number[]) => void;\n  onChange?: (values: string[] | number[]) => void;\n  onBlur?: (values: string[]) => void;\n  value?: string[];\n  disabled?: boolean;\n  ref?: React.Ref<HTMLDivElement>;\n  defaultValue: string[];\n  legend?: string;\n  label?: string;\n  itemClassName?: string;\n  className?: ClassValue[] | string | undefined;\n  id?: string;\n  excludes?: string[] | number[];\n  icon?: React.ReactNode;\n}\n\nconst TileMultiSelector = forwardRef<HTMLDivElement, TileMultiSelectorProps>(\n  (props, ref) => {\n    const {\n      options,\n      onSelect,\n      onChange,\n      defaultValue = [],\n      className,\n      disabled,\n      id,\n      legend,\n      itemClassName,\n      excludes,\n    } = props;\n    const [selectedValues, setSelectedValues] = useState<string[] | number[]>(\n      defaultValue,\n    );\n    const [focusedIndex, setFocusedIndex] = useState(0);\n    const uuids = useGenerateUUIDs(\n      options.map((item) => (isOption(item) ? item.value : item)),\n    );\n    const itemsRef = useRef<(HTMLDivElement | null)[]>([]);\n\n    function isChildFocused(\n      activeElement: Element | null = document.activeElement,\n    ) {\n      return itemsRef.current.some((item) => item === activeElement);\n    }\n\n    const handleChange = (value: string | number) => {\n      let newSelectedValues: string[] | number[] = [];\n      if (selectedValues && selectedValues.includes(value as never)) {\n        newSelectedValues = selectedValues.filter((v) => v !== value) as\n          | string[]\n          | number[];\n      } else {\n        newSelectedValues = [...selectedValues, value] as string[] | number[];\n      }\n\n      setSelectedValues(newSelectedValues);\n      onSelect && onSelect(newSelectedValues);\n      onChange && onChange(newSelectedValues);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (!isChildFocused) {\n        return;\n      }\n\n      if (e.key === 'ArrowDown') {\n        setFocusedIndex((prevIndex) => (prevIndex + 1) % options.length);\n      } else if (e.key === 'ArrowUp') {\n        setFocusedIndex(\n          (prevIndex) => (prevIndex - 1 + options.length) % options.length,\n        );\n      } else if (e.key === 'Enter' || e.key === ' ') {\n        const optionSelected = options[focusedIndex];\n        handleChange(\n          isOption(optionSelected) ? optionSelected.label : optionSelected,\n        );\n      }\n    };\n\n    useEffect(() => {\n      itemsRef.current[focusedIndex]?.focus();\n    }, [focusedIndex]);\n\n    function isSelected(item: string | Option) {\n      if (!selectedValues || !selectedValues.length) {\n        return false;\n      }\n      return selectedValues.includes(\n        (isOption(item) ? item.value : item) as never,\n      );\n    }\n\n    return (\n      <div\n        ref={ref}\n        id={id}\n        aria-disabled={disabled}\n        role=\"listbox\"\n        tabIndex={0}\n        className={cn('flex flex-col p-4', className)}\n        onKeyDown={handleKeyDown}\n      >\n        <legend className=\"text-sm font-semibold\">{legend}</legend>\n        {options.map((item, index) => {\n          const itemValue = isOption(item) ? item.label : item;\n          function isExcluded() {\n            return (\n              excludes &&\n              excludes.includes(\n                (isOption(itemValue) ? itemValue.value : itemValue) as never,\n              )\n            );\n          }\n\n          return (\n            <TileSelectorItem\n              disabled={disabled || isExcluded()}\n              key={uuids[index]}\n              option={item}\n              isSelected={isSelected(item)}\n              onSelect={handleChange}\n              className={itemClassName}\n              ref={(el) => {\n                itemsRef.current[index] = el;\n              }}\n              id={`tileMultiSelectorItem-${itemValue}`}\n              icon={props.icon ?? null}\n            />\n          );\n        })}\n      </div>\n    );\n  },\n);\n\nTileMultiSelector.displayName = 'TileMultiSelector';\n\nexport default TileMultiSelector;\n",
  "/ReactFormMaker/enhancements/TileSelector/TileSelector.tsx": "import React, { useState, useEffect, useRef, forwardRef } from 'react';\nimport { cn } from '@/lib/utils';\nimport { useGenerateUUIDs } from '@/lib/useGenerateUUIDs';\nimport TileSelectorItem from './TileSelectorItem';\nimport {\n  isOption,\n  type Option,\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\n\ninterface TileSelectorProps {\n  options: string[] | Option[];\n  onSelect?: (value: string) => void;\n  onChange?: (value: string) => void;\n  onBlur?: (value: string) => void;\n  onClick?: (value: string | number) => void;\n  value?: string;\n  disabled?: boolean;\n  ref?: React.Ref<HTMLDivElement>;\n  defaultValue: string;\n  legend?: string;\n  label?: string;\n  itemClassName?: string;\n  className?: string;\n  id?: string;\n  excludes?: string[] | number[];\n}\n\nconst TileSelector = forwardRef<HTMLDivElement, TileSelectorProps>(\n  (props, ref) => {\n    const {\n      options,\n      onClick,\n      defaultValue,\n      className,\n      disabled,\n      id,\n      legend,\n      itemClassName,\n      excludes,\n    } = props;\n    const [selectedValue, setSelectedValue] = useState<string | number | null>(\n      defaultValue,\n    );\n    const [focusedIndex, setFocusedIndex] = useState(0);\n    const uuids = useGenerateUUIDs(\n      options.map((item) => (isOption(item) ? item.value : item)),\n    );\n    const itemsRef = useRef<(HTMLDivElement | null)[]>([]);\n\n    function isChildFocused(\n      activeElement: Element | null = document.activeElement,\n    ) {\n      return itemsRef.current.some((item) => item === activeElement);\n    }\n\n    const handleChange = (value: string | number) => {\n      const option = options.find(\n        (item) => (isOption(item) ? item.label : item) === value,\n      );\n      if (!option) {\n        return;\n      }\n\n      const newValue =\n        value === selectedValue\n          ? null\n          : isOption(option)\n            ? option.value\n            : option;\n\n      if (!newValue) {\n        setSelectedValue(null);\n        return;\n      }\n\n      setSelectedValue(newValue);\n      if (onClick && newValue) {\n        onClick(newValue);\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (!isChildFocused) {\n        return;\n      }\n\n      if (e.key === 'ArrowDown') {\n        setFocusedIndex((prevIndex) => (prevIndex + 1) % options.length);\n      } else if (e.key === 'ArrowUp') {\n        setFocusedIndex(\n          (prevIndex) => (prevIndex - 1 + options.length) % options.length,\n        );\n      } else if (e.key === 'Enter' || e.key === ' ') {\n        const optionSelected = options[focusedIndex];\n        handleChange(\n          isOption(optionSelected) ? optionSelected.label : optionSelected,\n        );\n      }\n    };\n\n    useEffect(() => {\n      itemsRef.current[focusedIndex]?.focus();\n    }, [focusedIndex]);\n\n    function isSelected(item: string | Option) {\n      return selectedValue === (isOption(item) ? item.value : item);\n    }\n\n    return (\n      <div\n        ref={ref}\n        id={id}\n        aria-disabled={disabled}\n        role=\"listbox\"\n        tabIndex={0}\n        className={cn('flex flex-col p-4', className)}\n        onKeyDown={handleKeyDown}\n      >\n        <legend className=\"text-sm font-semibold\">{legend}</legend>\n        {options.map((item, index) => {\n          const itemValue = isOption(item) ? item.value : item;\n          function isExcluded() {\n            return excludes && excludes.includes(itemValue as never);\n          }\n\n          return (\n            <TileSelectorItem\n              disabled={disabled || isExcluded()}\n              key={uuids[index]}\n              option={item}\n              isSelected={isSelected(item)}\n              onSelect={handleChange}\n              className={itemClassName}\n              ref={(el) => {\n                itemsRef.current[index] = el;\n              }}\n              id={`tileSelectorItem-${itemValue}`}\n            />\n          );\n        })}\n      </div>\n    );\n  },\n);\n\nTileSelector.displayName = 'TileSelector';\n\nexport default TileSelector;\n",
  "/ReactFormMaker/enhancements/TileSelector/TileSelectorItem.tsx": "import React, { forwardRef } from 'react';\nimport { Check } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport {\n  isOption,\n  type Option,\n} from '../../utils/typeGuards/optionsFields.TypeGuards';\n\ninterface TileSelectorItemProps {\n  option: string | Option;\n  isSelected: boolean;\n  onSelect: (value: string | number) => void;\n  className?: string;\n  id?: string | undefined;\n  disabled?: boolean;\n  icon?: React.ReactNode;\n}\n\nconst TileSelectorItem = forwardRef<HTMLDivElement, TileSelectorItemProps>(\n  ({ option, isSelected, onSelect, className, id, disabled, icon }, ref) => {\n    const TileSelectorItemStyle = cn(\n      'w-full flex flex-row items-center justify-start p-4 border border-gray-300 rounded-md cursor-pointer mb-2 shadow-sm transition-colors',\n      {\n        'bg-primary text-primary-foreground hover:bg-primary/90': isSelected,\n      },\n      {\n        'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground':\n          !isSelected,\n      },\n      {\n        'cursor-not-allowed opacity-50': disabled,\n      },\n      className,\n    );\n\n    function getValue(option: string | Option): string | number {\n      return isOption(option) ? option.value : option;\n    }\n\n    function getLabel(option: string | Option) {\n      return isOption(option) ? option.label : option;\n    }\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === 'Enter' || e.key === ' ') {\n        if (disabled) {\n          e.preventDefault();\n          e.stopPropagation();\n          return;\n        }\n        onSelect(getValue(option));\n      }\n    };\n\n    return (\n      <div\n        id={id}\n        ref={ref}\n        className={TileSelectorItemStyle}\n        role=\"option\"\n        aria-disabled={disabled}\n        aria-checked={isSelected}\n        tabIndex={disabled ? -1 : 0}\n        onClick={() => {\n          if (disabled) return;\n          onSelect(getValue(option));\n        }}\n        onKeyDown={(e) => handleKeyDown(e)}\n        aria-selected={isSelected}\n      >\n        <div className=\"flex items-center justify-center w-6 h-6 mr-2\">\n          {icon ||\n            (isSelected && (\n              <Check className=\"w-4 h-4 text-primary-foreground\" />\n            ))}\n        </div>\n        {getLabel(option)}\n      </div>\n    );\n  },\n);\n\nTileSelectorItem.displayName = 'TileSelectorItem';\n\nexport default TileSelectorItem;\n",
  "/ReactFormMaker/enhancements/YearsDropdown.tsx": "import {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@radix-ui/react-popover';\nimport { ChevronDown } from 'lucide-react';\nimport React from 'react';\nimport {\n  type DropdownOption,\n  type DropdownProps,\n  useDayPicker,\n} from 'react-day-picker';\nimport { cn } from '@/lib/utils';\nimport {\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselNext,\n  CarouselPrevious,\n} from '@/components/ui/carousel';\nimport { Button } from '@/components/ui/button';\n\nexport interface YearsDropdownProps extends DropdownProps {\n  selectedYear: number;\n  setSelectedYear: React.Dispatch<React.SetStateAction<number>>;\n  range?: 'from' | 'to';\n}\n\nexport interface DateRange {\n  from: Date;\n  to: Date;\n}\n\nexport default function YearsDropdownCustom({\n  selectedYear,\n  setSelectedYear,\n  range = 'from',\n}: YearsDropdownProps) {\n  const { goToMonth, selected } = useDayPicker();\n  const [isOpen, setIsOpen] = React.useState(false);\n\n  const selectedData: DateRange = selected ?? {\n    from: new Date(),\n    to: new Date(),\n  };\n\n  const currentYear = new Date().getFullYear();\n  const decade = parseInt(`${currentYear.toString().slice(0, -1)}0`, 10);\n\n  const decades = Array.from({ length: 200 }, (_, i) => decade - 100 + i);\n\n  const segementDecade: Array<DropdownOption[]> = decades.reduce(\n    (acc: DropdownOption[][], year, index) => {\n      if (index % 10 === 0) {\n        acc.push([\n          {\n            value: year,\n            label: year.toString(),\n            disabled: false,\n          },\n        ]);\n      } else {\n        acc[acc.length - 1].push({\n          value: year,\n          label: year.toString(),\n          disabled: false,\n        });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  function indexToStart(): number {\n    const index = segementDecade.findIndex((decadeData) => {\n      return decadeData.some((option) => {\n        return option.value === selectedYear;\n      });\n    });\n    return index;\n  }\n\n  return (\n    <Popover\n      onOpenChange={(e) => {\n        setIsOpen(e);\n      }}\n    >\n      <PopoverTrigger asChild>\n        <Button variant=\"ghost\">\n          {selectedYear}\n          <ChevronDown\n            orientation={isOpen ? 'up' : 'down'}\n            className={cn(\n              'h-4 w-4 transition-all transform duration-300 rotate-0',\n              isOpen && 'transform rotate-180',\n            )}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0 z-10\">\n        <div className=\"bg-[white] w-[265px] items-center flexjustify-center p-3 acity-100 z-10 rounded-lg shadow-md border \">\n          <Carousel\n            opts={{\n              align: 'start',\n              startIndex: indexToStart(),\n            }}\n            className=\"w-[240px] max-w-sm\"\n          >\n            <CarouselContent>\n              {segementDecade.map((decade) => (\n                <CarouselItem\n                  key={decade[0].label}\n                  className=\"flex flex-row items-center justify-center w-full h-full flex-wrap m-2\"\n                >\n                  {decade.map((option) => (\n                    <Button\n                      key={option.value}\n                      onClick={() => {\n                        const newDate = new Date(\n                          option.value,\n                          selectedData[range]?.getMonth() ||\n                            new Date().getMonth(),\n                        );\n                        goToMonth(newDate);\n                        setSelectedYear(option.value);\n                      }}\n                      variant=\"ghost\"\n                      className={cn(\n                        'w-20 h-10',\n                        option.value === selectedYear &&\n                          'bg-primary text-primary-foreground',\n                      )}\n                    >\n                      {option.label}\n                    </Button>\n                  ))}\n                </CarouselItem>\n              ))}\n            </CarouselContent>\n            <CarouselPrevious />\n            <CarouselNext />\n          </Carousel>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}\n",
  "/ReactFormMaker/formElements/DivElementField.tsx": "import React, { useMemo } from 'react';\nimport { v4 as uuidV4 } from 'uuid';\nimport { Slottable } from '@radix-ui/react-slot';\nimport type {\n  CompositeField,\n  DividerReactFormMaker,\n} from '../interfaces/FieldInterfaces';\n\ninterface DivElementFieldProps {\n  elementField: DividerReactFormMaker;\n  FormFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[];\n}\n\nconst DivElementField: React.FC<DivElementFieldProps> = ({\n  elementField,\n  FormFieldsMap,\n}) => {\n  const uuid = useMemo(() => {\n    return uuidV4();\n  }, []);\n\n  return (\n    <div\n      key={uuid}\n      className={`${elementField.className} ${elementField.isHide ? 'hidden' : ''}`}\n    >\n      {\n        // Si l'lment comprend des sous-champs, on continue de les mapper\n        elementField.fields && FormFieldsMap(elementField.fields)\n      }\n      <Slottable>\n        {\n          // Si le champ est de type custom, on clone l'lment JSX et on lui passe les props\n          elementField.children &&\n            React.cloneElement(elementField.children as React.ReactElement, {})\n        }\n      </Slottable>\n    </div>\n  );\n};\n\nexport default DivElementField;\n",
  "/ReactFormMaker/formElements/FormFieldElement.tsx": "import React from 'react';\nimport type { FieldValues, Path, UseFormReturn } from 'react-hook-form';\nimport {\n  FormField,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n} from '@/components/ui/form';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport type { CustomInputFieldElementParams } from '../interfaces/CustomInputFieldElementParams';\nimport type { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\n\ninterface FormFieldElementProps<T extends FieldValues> {\n  elementField: FieldReactFormMaker;\n  index: string;\n  form: UseFormReturn<T>;\n  InpuTComponentCallBack: (params: FieldParams) => JSX.Element;\n}\n\nfunction FormFieldElement<T extends FieldValues>({\n  elementField,\n  index: key,\n  form,\n  InpuTComponentCallBack,\n}: FormFieldElementProps<T>) {\n  return (\n    <FormField\n      key={`fomr-field-element-${key}`}\n      control={form.control}\n      name={elementField.inputName as Path<T>}\n      render={({ field }) => (\n        <FormItem\n          className=\"flex flex-col\"\n          key={`formitem${key}`}\n          onBlur={(e: any) => {\n            if (elementField.onBlur) {\n              e.controlField = field;\n              e.form = form;\n              elementField.onBlur(e);\n            }\n          }}\n          onSelect={(e: any) => {\n            if (elementField.onSelect) {\n              e.controlField = field;\n              e.form = form;\n              elementField.onSelect(e);\n            }\n          }}\n          onChange={(e: any) => {\n            if (elementField.onChange) {\n              e.controlField = field;\n              e.form = form;\n              elementField.onChange(e);\n            }\n          }}\n          onClick={(e: any) => {\n            if (elementField.onClick) {\n              e.controlField = field;\n              e.form = form;\n              elementField.onClick(e);\n            }\n          }}\n        >\n          {elementField.label && !elementField.isSecure && (\n            <FormLabel htmlFor={elementField.inputName}>\n              {elementField.label}\n            </FormLabel>\n          )}\n          <FormControl>\n            <InpuTComponentCallBack\n              zFields={field}\n              fieldProps={elementField}\n              indexField={`input${key}`}\n            />\n          </FormControl>\n          {elementField.description && !elementField.isSecure && (\n            <FormDescription>{elementField.description}</FormDescription>\n          )}\n          <FormMessage />\n          {elementField.children &&\n            React.isValidElement(elementField.children) &&\n            React.cloneElement(elementField.children, {\n              zFields: field,\n              fieldProps: elementField,\n              index: key,\n              ...elementField.props,\n            } as CustomInputFieldElementParams<any>)}\n        </FormItem>\n      )}\n    />\n  );\n}\n\nexport default FormFieldElement;\n",
  "/ReactFormMaker/formElements/InputComponent.tsx": "import React, { useMemo } from 'react';\nimport { v4 as uuidV4 } from 'uuid';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport TextInput from '../inputs/TextInput';\nimport PasswordInput from '../inputs/PasswordInput';\nimport SelectInput from '../inputs/SelectInput';\nimport TextareaInput from '../inputs/TextareaInput';\nimport DateInput from '../inputs/DateInput';\nimport RadioInput from '../inputs/RadioInput';\nimport CheckboxInput from '../inputs/CheckboxInput';\nimport SwitchInput from '../inputs/SwitchInput';\nimport NumberInput from '../inputs/NumberInput';\nimport FileInput from '../inputs/FileInput';\nimport TileSelectorInput from '../inputs/TileSelectorInput';\nimport TileMultiSelectorInput from '../inputs/TileMultiselectorInput';\nimport SelectAutocompleteInput from '../inputs/SelectAutocompleteInput';\nimport PhoneNumberInput from '../inputs/PhoneNumberInput';\nimport FileDropZone from '../inputs/FileUploaderInput';\nimport MultiSelectInput from '../inputs/MultiSelectInput';\nimport DateRangeInput from '../inputs/DateRangeInput';\n\n/**\n * InputComponent is a versatile component that renders different types of input fields\n * based on the `inputType` provided in the `fieldProps`. It supports various input types\n * such as text, password, select, textarea, date, dateRange, radio, checkbox, switch, file,\n * number, and custom components.\n *\n * @param {FieldParams} params - The parameters for the input field.\n * @param {Object} params.fieldProps - The properties of the field.\n * @param {string} params.fieldProps.inputType - The type of input to render.\n * @param {React.ReactNode} params.fieldProps.children - The children elements for custom input.\n *\n * @returns {JSX.Element} The rendered input component based on the **input type**.\n *\n * ---\n *\n * @see {@link FieldParams} for the interface used in the `params` argument.\n */\nfunction InputComponent(params: FieldParams): JSX.Element {\n  const {\n    fieldProps: { inputType, customInputFieldElement },\n  } = params;\n\n  // const [uuid, setUuid] = useState<string>(uuidV4());\n  const uuid = useMemo(() => uuidV4(), []);\n\n  switch (inputType) {\n    case 'text':\n      return <TextInput {...params} key={uuid} />;\n    case 'password':\n      return <PasswordInput {...params} key={uuid} />;\n    case 'select':\n      return <SelectInput {...params} key={uuid} />;\n    case 'selectAutocomplete':\n      return <SelectAutocompleteInput {...params} key={uuid} />;\n    case 'multiSelect':\n      return <MultiSelectInput {...params} key={uuid} />;\n    case 'textarea':\n      return <TextareaInput {...params} key={uuid} />;\n    case 'date':\n      return <DateInput {...params} key={uuid} />;\n    case 'dateRange':\n      return <DateRangeInput {...params} key={uuid} />;\n    case 'radio':\n      return <RadioInput {...params} key={uuid} />;\n    case 'checkbox':\n      return <CheckboxInput {...params} key={uuid} />;\n    case 'switch':\n      return <SwitchInput {...params} key={uuid} />;\n    case 'file':\n      return <FileInput {...params} key={uuid} />;\n    case 'fileDropZone':\n      return <FileDropZone {...params} key={uuid} />;\n    case 'number':\n      return <NumberInput {...params} key={uuid} />;\n    case 'tileSelector':\n      return <TileSelectorInput {...params} key={uuid} />;\n    case 'tileMultiSelector':\n      return <TileMultiSelectorInput {...params} key={uuid} />;\n    case 'phoneNumber':\n      return <PhoneNumberInput {...params} key={uuid} />;\n    case 'custom':\n      return React.cloneElement(customInputFieldElement as React.ReactElement, {\n        ...params,\n      });\n    default:\n      return (\n        <p key={uuid}>{`Type d'input non reconnu : ${inputType as string}`}</p>\n      );\n  }\n}\n\nexport default InputComponent;\n",
  "/ReactFormMaker/formElements/mapChildrenWithForm.tsx": "import React from 'react';\nimport type { UseFormReturn } from 'react-hook-form';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\ninterface FormEvent extends React.SyntheticEvent {\n  form: any;\n}\n\n/**\n * Maps over the children components and injects the form object into event handlers.\n * - - -\n * @param childrenComponents - The children components to be processed.\n * @param form - The form object to be injected into event handlers.\n * @returns A new set of children components with the form object injected into their event handlers.\n */\nconst mapChildrenWithForm = (\n  childrenComponents: React.ReactNode,\n  form: UseFormReturn<any>,\n): React.ReactNode =>\n  React.Children.map(childrenComponents, (child) => {\n    if (React.isValidElement(child)) {\n      const newProps = { ...child.props };\n      Object.keys(newProps).forEach((propName) => {\n        if (typeof newProps[propName] === 'function') {\n          const originalEventHandler = newProps[propName];\n          newProps[propName] = (event: FormEvent) => {\n            event.form = form;\n            originalEventHandler(event);\n          };\n        }\n      });\n      return React.cloneElement(child, newProps);\n    }\n    return child;\n  });\n\nexport default mapChildrenWithForm;\n",
  "/ReactFormMaker/formElements/Stepper/StepperContext.tsx": "import React from 'react';\nimport type { UseFormReturn, FieldValues, Path } from 'react-hook-form';\nimport { z } from 'zod';\nimport type { CompositeField } from '../../interfaces/FieldInterfaces';\nimport type {\n  orientationMutable,\n  StepElement,\n  StepFormState,\n  StepperContextProps,\n} from './SteppersElements/StepperContext.interface';\nimport {\n  isFieldReactFormMaker,\n  isStepReactFormMaker,\n} from '../../utils/typeGuards/compositeField.TypeGuards';\nimport stepReducer, { initialSteps } from './SteppersElements/stepReducer';\nimport { usePromiseObserver } from '@/lib/usePromiseObserver';\nimport { CommandManager } from '@/lib/commandManager';\n\nconst StepperContext = React.createContext<\n  StepperContextProps<any> | undefined\n>(undefined);\n\nfunction extractFieldNamesFromStep(\n  step: CompositeField,\n  FieldNames: string[] = [],\n): string[] {\n  if (step.fields && step.fields.length > 0) {\n    step.fields.forEach((field) => {\n      if (isFieldReactFormMaker(field)) {\n        FieldNames.push(field.inputName);\n      } else {\n        extractFieldNamesFromStep(field, FieldNames);\n      }\n    });\n  }\n  return FieldNames;\n}\n\n/**\n * ### Stepper Provider\n *\n * The `StepperProvider` component is a component that allows you to manage the state of the stepper.\n * This Provider is used specifically for the stepper in the form.\n *\n * ---\n *\n * #### Proprieties to pass\n *\n * - `children`: used to display the children of the component\n * - `form`: used to manage the form state inside each step\n * - `formfields`:  used to manage the steps and the rendering of the form\n * - `zObject`:  used to manage the validation of the form\n * - `orientation`: used to manage the orientation of the stepper (default: 'horizontal')\n *\n * ---\n *\n * For more information, see the {@link StepperProvider} interface or the {@link StepperContextProps} interface\n * @param param0\n * @returns\n */\nexport function StepperProvider<T extends FieldValues>({\n  children,\n  form,\n  formfields,\n  zObject,\n  orientation = 'horizontal',\n}: {\n  children: React.ReactNode;\n  form: UseFormReturn<T>;\n  formfields: CompositeField[];\n  orientation?: 'vertical' | 'horizontal';\n  zObject: { [key in keyof T]: z.ZodType<T[key], z.ZodTypeDef, T[key]> };\n}) {\n  const [stepIndex, setStepIndex] = React.useState<number>(0);\n  const [orientationMutable, setOrientationMutable] =\n    React.useState<orientationMutable>({ orientation, isOriginal: true });\n\n  const onBeforeNextStepMapper = React.useMemo(() => {\n    return formfields\n      .filter((field) => isStepReactFormMaker(field))\n      .reduce(\n        (acc, step) => {\n          if (step.onBeforeNextStep) {\n            acc[step.stepName] = step.onBeforeNextStep;\n          }\n          return acc;\n        },\n        {} as {\n          [key: string]: (data: {\n            submissionState: StepFormState<T>;\n            form: UseFormReturn<T>;\n          }) => Promise<boolean>;\n        },\n      );\n  }, [formfields]);\n\n  const handlersObserver = usePromiseObserver<\n    {\n      submissionState: StepFormState<T>;\n      form: UseFormReturn<T>;\n    },\n    boolean\n  >(onBeforeNextStepMapper);\n\n  const inputsNamesBySteps: string[][] = React.useMemo(() => {\n    return formfields.map((stepField) => {\n      return extractFieldNamesFromStep(stepField);\n    });\n  }, [formfields]);\n\n  const [steps, dispatch] = React.useReducer(\n    stepReducer,\n    formfields,\n    initialSteps,\n  );\n\n  const getFieldStatesBySteps = (\n    index: number = stepIndex,\n  ): StepFormState<T> => {\n    const StepFormState: StepFormState<T> = {\n      isValidStep: true,\n      fieldStatesDetails: {},\n    };\n    const currentInputsNames = inputsNamesBySteps[index] as Path<T>[];\n    currentInputsNames.forEach((inputName) => {\n      let isValid = false;\n      const value = form.getValues(inputName);\n      const fiedState = form.getFieldState(inputName);\n      const zField = zObject[inputName];\n\n      const { invalid, isDirty } = fiedState;\n      const fieldHasValue: boolean = value !== undefined;\n      const fieldIsNullable: boolean = zField.isNullable();\n      const fieldIsOptional: boolean = zField.isOptional();\n      if (fieldIsOptional || fieldIsNullable) {\n        isValid = isDirty ? !invalid : true;\n      } else {\n        isValid = isDirty ? !invalid : fieldHasValue;\n      }\n      const keyName = inputName as string;\n      if (!isValid) {\n        StepFormState.isValidStep = false;\n      }\n      StepFormState.fieldStatesDetails[keyName] = {\n        isValid,\n        value,\n        FieldState: fiedState,\n        zField,\n      };\n    });\n\n    return StepFormState;\n  };\n\n  React.useEffect(() => {\n    dispatch({ type: 'CHANGE_FOCUS', currentStepIndex: stepIndex });\n  }, [stepIndex]);\n\n  const triggeringFormStep = async (\n    currentStepIndex: number,\n  ): Promise<boolean> => {\n    const inputsNames = inputsNamesBySteps[currentStepIndex] as Path<T>[];\n    return form.trigger(inputsNames);\n  };\n\n  const executeStepCompletion = async (currentStepIndex: number) => {\n    const dispachQueue = new CommandManager({\n      dispatch,\n      stepIndex: currentStepIndex,\n    });\n\n    dispachQueue.addCommands([\n      {\n        name: 'setDone',\n        command: async ({ dispatch, stepIndex }) => {\n          dispatch({ type: 'SET_DONE', currentStepIndex: stepIndex });\n          return { success: true };\n        },\n      },\n      {\n        name: 'setStrictDisabledEffect',\n        command: async ({ dispatch }) => {\n          dispatch({ type: 'SET_STRICT_DISABLED_EFFECT' });\n          return { success: true };\n        },\n      },\n      {\n        name: 'setBeforeDisabledEffect',\n        command: async ({ dispatch }) => {\n          dispatch({ type: 'SET_BETFORE_DISABLED_EFFECT' });\n          return { success: true };\n        },\n      },\n    ]);\n    await dispachQueue.execute();\n  };\n\n  const getNbSteps = () => steps.length;\n\n  const getCurrentStep = () => steps[stepIndex];\n\n  const goToStep = async (newStepIndex: number) => {\n    if (stepIndex === newStepIndex) {\n      return;\n    }\n    if (steps[newStepIndex].isdisabled) {\n      return;\n    }\n    if (stepIndex > newStepIndex) {\n      setStepIndex(newStepIndex);\n      return;\n    }\n    triggeringFormStep(stepIndex).then((isValid) => {\n      if (isValid) {\n        executeStepCompletion(stepIndex).then(() => {\n          setStepIndex(newStepIndex);\n        });\n      } else {\n        dispatch({ type: 'REMOVE_DONE', currentStepIndex: stepIndex });\n      }\n    });\n  };\n\n  const goNextStep = (): void => {\n    triggeringFormStep(stepIndex).then((isValid) => {\n      if (isValid) {\n        if (steps[stepIndex].onBeforeNextStep) {\n          const submissionState = getFieldStatesBySteps();\n          const data = {\n            submissionState,\n            form,\n          };\n          handlersObserver.execute(steps[stepIndex].stepName, data);\n          steps[stepIndex].onBeforeNextStep(data).then((isSwitch: boolean) => {\n            if (isSwitch) {\n              executeStepCompletion(stepIndex).then(() => {\n                setStepIndex(stepIndex + 1);\n              });\n            }\n          });\n        } else {\n          executeStepCompletion(stepIndex).then(() => {\n            setStepIndex(stepIndex + 1);\n          });\n        }\n      } else {\n        dispatch({ type: 'REMOVE_DONE', currentStepIndex: stepIndex });\n      }\n    });\n  };\n\n  const goPreviousStep = (): void => {\n    if (stepIndex > 0) {\n      setStepIndex(stepIndex - 1);\n    }\n  };\n\n  const getPreviousStep = (): StepElement | undefined => {\n    if (stepIndex > 0) {\n      return steps[stepIndex - 1];\n    }\n    return undefined;\n  };\n\n  const getNextStep = (): StepElement | undefined => {\n    if (stepIndex < steps.length - 1) {\n      return steps[stepIndex + 1];\n    }\n    return undefined;\n  };\n\n  const shiftOrientation = (width: number): void => {\n    const { orientation: currentOrientation, isOriginal } = orientationMutable;\n    if (width < 640) {\n      if (currentOrientation === 'vertical' && isOriginal) {\n        setOrientationMutable({ orientation: 'horizontal', isOriginal: false });\n      }\n    } else if (currentOrientation === 'horizontal' && !isOriginal) {\n      setOrientationMutable({ orientation: 'vertical', isOriginal: true });\n    }\n  };\n\n  const getListenerObserver = (\n    index: number,\n  ): 'idle' | 'loading' | 'resolved' | 'rejected' => {\n    const { stepName } = steps[index];\n    return handlersObserver.listener(stepName);\n  };\n\n  return (\n    <StepperContext.Provider\n      value={{\n        steps,\n        getNbSteps,\n        getCurrentStep,\n        goToStep,\n        goNextStep,\n        goPreviousStep,\n        form,\n        getFieldStatesBySteps,\n        getPreviousStep,\n        getNextStep,\n        stepIndex,\n        orientation: orientationMutable.orientation,\n        shiftOrientation,\n        getListenerObserver,\n      }}\n    >\n      {children}\n    </StepperContext.Provider>\n  );\n}\n\n/**\n * ### Stepper Context Hook\n *\n * Hook to use the stepper context in a functional component of stepper components\n *\n * @returns StepperContextProps\n *\n * ---\n *\n * Must be used within a StepperProvider\n *\n * ---\n *\n * For more information, see the {@link StepperContextProps} interface\n */\nexport const useStepper = <T extends FieldValues>() => {\n  const context = React.useContext(\n    StepperContext as React.Context<StepperContextProps<T> | undefined>,\n  );\n  if (!context) {\n    throw new Error('useStepper must be used within a StepperProvider');\n  }\n  return context;\n};\n",
  "/ReactFormMaker/formElements/Stepper/StepperForm.componenent.tsx": "import React from 'react';\nimport type { FieldValues, UseFormReturn } from 'react-hook-form';\nimport type {\n  CompositeField,\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  ReactFormMakerStep,\n} from '../../interfaces/FieldInterfaces';\nimport { StepperProvider } from './StepperContext';\nimport { StepperContent } from './SteppersElements/StepperContent';\nimport FooterStepperReactHookForm from './SteppersElements/FooterSteppers.component';\nimport { Stepper } from './SteppersElements/Stepper.component';\nimport NavigationStepper from './SteppersElements/HeaderStepper/HeaderStepper.componenent';\nimport { useStepperItemsMap } from './SteppersElements/useStepperItemMap.hook';\n\ninterface StepperFormProps<T extends FieldValues> {\n  form: UseFormReturn<T>;\n  formfields: CompositeField[];\n  zObject: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n  orientation: 'horizontal' | 'vertical';\n  formFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[];\n}\n\n/**\n * ### StepperForm Component\n *\n * The StepperForm component is the complete component that manages the forms generated by React Form Maker under a Stepper distribution interface.\n *\n * ---\n *\n * #### Behavior\n *\n * ##### It intuitively to its own size.\n * To avoid overloading className configurations, ReactFormMaker's StepperForm compoenent adapts its ergonomics to the layout. In vertical mode, for example, if the space allocated to it is too small for the display to be adapted to the user experience. The component will naturally choose a more suitable format.\n *\n * ##### Advanced management of the form.\n *\n * The StepperForm is managed by the `ReactFormMakerStep` interface. This interface includes functions handlers that allow you to interact with the various states of the form throughout its lifecycle. So you can influence and control the form at any time.\n *\n * For more information, see the {@link ReactFormMakerStep} interface.\n *\n * ---\n * @param\n * @returns\n */\nfunction StepperForm<T extends FieldValues>({\n  form,\n  formfields,\n  zObject,\n  orientation,\n  formFieldsMap: FormFieldsMap,\n}: StepperFormProps<T>) {\n  const { StepperItemsMap } = useStepperItemsMap(FormFieldsMap);\n  return (\n    <StepperProvider<T>\n      form={form}\n      formfields={formfields}\n      zObject={zObject} // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n      orientation={orientation}\n    >\n      <Stepper<T>>\n        <NavigationStepper />\n        <div className=\"flex flex-col min-w-0 flex-auto\">\n          <StepperContent className=\"flex flex-row min-h-[400px]\">\n            {StepperItemsMap(formfields)}\n          </StepperContent>\n          <FooterStepperReactHookForm />\n        </div>\n      </Stepper>\n    </StepperProvider>\n  );\n}\n\nexport default StepperForm;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/FooterSteppers.component.tsx": "import React from 'react';\nimport { type ButtonProps } from 'react-day-picker';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { useStepper } from '../StepperContext';\n\ninterface FooterStepperReactHookFormProps extends Omit<ButtonProps, 'variant'> {\n  className?: string;\n  variant?:\n    | 'outline'\n    | 'ghost'\n    | 'default'\n    | 'link'\n    | 'destructive'\n    | 'secondary'\n    | null\n    | undefined;\n}\n\n/**\n * ### FooterStepperReactHookForm Component\n *\n * The footer of the stepper is a component that allows you to navigate between the steps of the stepper.\n *\n * The footer is composed of two buttons:\n *  - The first button allows you to go back to the previous step.\n *  - The second button allows you to go to the next step.\n *\n * The footer is displayed at the bottom of the stepper.\n *\n * #### Behavior\n *\n *  - If the current step is the first step, the previous button is disabled.\n *  - If the previous step is disabled, the previous button is disabled.\n *  - If Steps is not valid, the next button is disabled.\n *  - If the current step is the last step, the next button is replaced by a submit button.\n */\nconst FooterStepperReactHookForm = React.forwardRef<\n  HTMLButtonElement,\n  FooterStepperReactHookFormProps\n>(({ variant = 'default' }, ref) => {\n  const {\n    getFieldStatesBySteps,\n    goNextStep,\n    goPreviousStep,\n    getCurrentStep,\n    getNbSteps,\n    getPreviousStep,\n    getListenerObserver,\n  } = useStepper();\n\n  const step = getCurrentStep();\n\n  function isLastStep() {\n    return getCurrentStep().stepIndex === getNbSteps() - 1;\n  }\n\n  function hasPreviousButton() {\n    const prevStep = getPreviousStep();\n    if (getCurrentStep().stepIndex === 0) {\n      return false;\n    }\n    if (prevStep?.disabledBefore && prevStep.isDone) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function formIsLoading(): boolean {\n    return getListenerObserver(getCurrentStep().stepIndex) === 'loading';\n  }\n\n  return (\n    <footer\n      ref={ref}\n      className={cn(\n        'flex flex-col-reverse align-center sm:flex-row sm:justify-between transition-all duration-300',\n        step.footerClassName,\n      )}\n    >\n      {hasPreviousButton() ? (\n        <Button\n          className=\"w-full sm:w-auto mt-2\"\n          onClick={goPreviousStep}\n          type=\"button\"\n          variant=\"secondary\"\n          disabled={formIsLoading()}\n        >\n          Previous\n        </Button>\n      ) : (\n        <div />\n      )}\n      {isLastStep() ? (\n        <Button\n          className=\"w-full sm:w-auto mt-2\"\n          type=\"submit\"\n          disabled={!getFieldStatesBySteps().isValidStep || formIsLoading()}\n        >\n          {step.buttonNextContent ? step.buttonNextContent : 'Previous'}\n        </Button>\n      ) : (\n        <Button\n          className=\"w-full sm:w-auto mt-2\"\n          onClick={goNextStep}\n          type=\"button\"\n          disabled={!getFieldStatesBySteps().isValidStep || formIsLoading()}\n          variant={variant}\n        >\n          {step.buttonNextContent ? step.buttonNextContent : 'Next'}\n        </Button>\n      )}\n      {step?.additionalButtons}\n    </footer>\n  );\n});\n\nFooterStepperReactHookForm.displayName = 'FooterStepperReactHookForm';\n\nexport default FooterStepperReactHookForm;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.componenent.tsx": "import React from 'react';\nimport HeaderStepperItem from './HeaderStepperItem/HeaderStepperItem.component';\nimport { useHeaderStepper } from './HeaderStepper.hook';\nimport HeaderStepperStyle from './HeaderStepper.style';\n\n/**\n * ### NavigationStepper Component\n *\n * The navigation bar varies according to the oriantation defined in the form.\n *\n * The navigation has been designed to be both perfectly responsive to the space allocated to it on the screen.\n *\n * #### Behavior\n *\n * Breakpoints are defined to adapt the size of the navigation bar to the space available on the screen.\n *\n * - if the space width can't contain name of the steps, the name will be hidden.\n * - If the space is less than 768px, the navigation bar will be horizontal.\n * - If the space is greater than 768px, the orientation will be respected.\n */\nfunction NavigationStepper() {\n  const { navRef, stepElements, steps, orientation, size } = useHeaderStepper();\n\n  const styleProps = {\n    orientation,\n    size,\n    stepsLength: steps.length,\n  };\n\n  const Style = new HeaderStepperStyle(styleProps);\n  return (\n    <nav ref={navRef} className={Style.navClass} style={Style.navStyle}>\n      {steps.map((step, index) => {\n        return (\n          <HeaderStepperItem\n            key={`stepper-header-item-${step.stepName}`}\n            step={step}\n            index={index}\n            size={size}\n            ref={(el) => {\n              stepElements.current[index] = el;\n            }}\n          />\n        );\n      })}\n    </nav>\n  );\n}\n\nexport default NavigationStepper;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.hook.tsx": "import { useRef, useState } from 'react';\nimport useResizeObserver from '@react-hook/resize-observer';\nimport { useStepper } from '../../StepperContext';\nimport type { StepElement } from '../StepperContext.interface';\n\ninterface HeaderStepperReturn {\n  /**\n   * Reference to the stepper navigation element\n   * @type {React.RefObject<HTMLDivElement>}\n   * @default null\n   */\n  navRef: React.RefObject<HTMLDivElement>;\n  /**\n   * Reference to the steps elements in the stepper navigation\n   * Used to calculate the height of the stepper navigation in vertical orientation\n   * and determine the height of the stepper navigation in horizontal orientation\n   * @type {React.MutableRefObject<(HTMLDivElement | null)[]>}\n   * @default []\n   */\n  stepElements: React.MutableRefObject<(HTMLDivElement | null)[]>;\n  /**\n   * Array of step elements\n   * @type {StepElement[]}\n   */\n  steps: StepElement[];\n  /**\n   * Orientation of the stepper defined in the StepperContext and passed to the HeaderStepper\n   * @type {string}\n   */\n  orientation: string;\n  /**\n   * Size of the stepper navigation\n   * Observed by the ResizeObserver to calculate the height and width of the stepper navigation\n   * @type {SizeElement}\n   */\n  size: SizeElement;\n}\n\nexport interface SizeElement {\n  width: number;\n  height: number;\n}\n\n/**\n * Hook to manage the stepper navigation element\n * @returns {HeaderStepperReturn}\n */\nexport function useHeaderStepper(): HeaderStepperReturn {\n  const navRef = useRef<HTMLDivElement>(null);\n  const stepElements = useRef<(HTMLDivElement | null)[]>([]);\n  const { steps, orientation } = useStepper();\n  const [size, setSize] = useState<SizeElement>({\n    width: 0,\n    height: 0,\n  });\n\n  const calculateNavHeight = () => {\n    if (orientation === 'vertical') {\n      const totalHeight: number = stepElements.current.reduce((sum, el) => {\n        return sum + (el?.offsetHeight || 0) + 24;\n      }, 0);\n      return Math.floor(totalHeight);\n    }\n    const heights = stepElements.current\n      .filter((el) => el !== null)\n      .map((el) => el.offsetHeight || 150);\n\n    if (heights.length === 0) {\n      return 150;\n    }\n\n    const maxHeight: number = Math.max(...heights);\n    return Math.floor(maxHeight);\n  };\n\n  function calculateNavWidth(entry: ResizeObserverEntry) {\n    if (orientation === 'horizontal') {\n      return entry.contentRect.width;\n    }\n    return 270;\n  }\n\n  useResizeObserver(navRef, (entry) => {\n    if (typeof window === 'undefined' || !navRef.current) return;\n    setSize({\n      width: calculateNavWidth(entry),\n      height: calculateNavHeight(),\n    });\n  });\n\n  return {\n    navRef,\n    stepElements,\n    steps,\n    orientation,\n    size,\n  };\n}\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepper.style.ts": "import { cn } from '@/lib/utils';\n\ninterface StyleProps {\n  orientation: string;\n  size: { width: number; height: number };\n  stepsLength: number;\n}\n\n/**\n * Class to manage the style of the stepper navigation\n * @class HeaderStepperStyle\n * @param {StyleProps} props - Props to manage the style of the stepper navigation\n * @property {string} navClass - Class to apply to the stepper navigation could be horizontal or vertical\n * @property {React.CSSProperties} navStyle - Style to apply to the stepper navigation could be width whene orientation is horizontal or height when orientation is vertical\n */\nclass HeaderStepperStyle {\n  navClass: string;\n\n  navStyle: React.CSSProperties;\n\n  constructor(props: StyleProps) {\n    this.navClass = cn({\n      'flex flex-row items-center justify-between min-h-full sm:px-8 md:px-12 lg:px-24 xl:px-32 mb-4 sm:mb-[72px]':\n        props.orientation === 'horizontal',\n      'flex flex-col gap-2 min-w-[270px] h-full max-h-full overflow-y-auto justify-start scrollbar-gray':\n        props.orientation !== 'horizontal',\n    });\n\n    this.navStyle =\n      props.orientation === 'horizontal'\n        ? {\n            marginBottom:\n              props.size.width / props.stepsLength - 12 > 80 ? '72px' : '12px',\n          }\n        : { width: props.size.width };\n  }\n}\n\nexport default HeaderStepperStyle;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.component.tsx": "// HeaderStepperItem.component.tsx\nimport React, { forwardRef } from 'react';\nimport { useHeaderStepperItem } from './useHeaderStepperItem.hook';\nimport StepInfoDisplay from './StepInfoDisplay.component';\nimport type {\n  HeaderStepperItemInterface,\n  HeaderStepperItemProps,\n} from './HeaderStepperItem.interface';\n\n/**\n * ### HeaderStepperItem Component\n *\n * The items represent the control points of the breadcrumb trail generated by navigation from the configuration passed in the form and the various ReactFormMakerSteps that make it up.\n *\n *\n *\n * ---\n *\n * #### Behavior\n *\n * ##### Horizontal Orientation\n *\n * - The items are clickable and allow the user to navigate to the corresponding step.\n * - The items display the name of the step if the space available on the screen allows it.\n * - Legend is a tooltip that displays the description of the step.\n * - The space available on the screen is calculated based on the width of the nav and the number of steps. Steps are hidden if the space is not enough.\n *\n * ##### Vertical Orientation\n *\n * - The legend is displayed on the right of the step name.\n * - The step item adaptes its height to the space available for readability of the legend.\n * - If the space is not enought, this item change to horizontal orientation.\n */\nconst HeaderStepperItem: HeaderStepperItemInterface = forwardRef<\n  HTMLDivElement,\n  HeaderStepperItemProps\n>((props, ref) => {\n  const {\n    stepName,\n    legend,\n    isLastStep,\n    localRef,\n    styles,\n    maxWidth,\n    icon,\n    ajustHeightProgressBar,\n    positionTooltip,\n    infoShouldBeDisplayed,\n    goToStep,\n    orientation,\n    formIsLoading,\n  } = useHeaderStepperItem({ ...props, ref });\n\n  const { index } = props;\n\n  return (\n    <React.Fragment key={index}>\n      <div\n        role=\"tab\"\n        tabIndex={0}\n        className={`${styles.stepDirectionContainerClass} ${styles.cursorClass}`}\n        onClick={() => {\n          if (formIsLoading()) return;\n          goToStep(index);\n        }}\n        onKeyDown={(e) => {\n          if (formIsLoading()) return;\n          if (e.key === 'Enter' || e.key === ' ') {\n            goToStep(index);\n          }\n        }}\n      >\n        {icon()}\n        {infoShouldBeDisplayed(maxWidth) && (\n          <div\n            className={styles.positionLabelClass}\n            style={{\n              width: orientation === 'horizontal' ? `${maxWidth}px` : '80%',\n            }}\n          >\n            <StepInfoDisplay\n              key={index}\n              stepName={stepName}\n              legend={legend}\n              orientation={orientation}\n              maxWidth={maxWidth}\n              opacityClass={styles.opacityClass}\n              positionTooltip={positionTooltip}\n              ref={localRef}\n            />\n          </div>\n        )}\n      </div>\n      {!isLastStep() && (\n        <div\n          className={`${styles.progressBarPositionClass} ${styles.barProgressClass}`}\n          style={ajustHeightProgressBar()}\n        />\n      )}\n    </React.Fragment>\n  );\n});\n\nHeaderStepperItem.displayName = 'HeaderStepperItem';\n\nexport default HeaderStepperItem;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.interface.tsx": "import { StepElement } from '../../StepperContext.interface';\nimport { SizeElement } from '../HeaderStepper.hook';\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nimport type { ReactFormMakerStep } from '@/components/ReactFormMaker/interfaces/FieldInterfaces';\n\n/**\n * **Properties for the HeaderStepperItem component**\n * @interface HeaderStepperItemProps\n *\n * ---\n *\n * @param {StepElement} step - The step element. See {@link StepElement}\n * @param {SizeElement} size - The size of the step element. See {@link SizeElement}\n * @param {number} index - The index of the step element.\n */\nexport type HeaderStepperItemProps = {\n  step: StepElement;\n  size: SizeElement;\n  index: number;\n};\n\n/**\n * ### HeaderStepperItem Component\n *\n * This component represents an item in the header stepper.\n * It uses the `useHeaderStepperItem` hook to manage its state and behavior.\n *\n * The items represent the control points of the breadcrumb trail generated by navigation from the configuration passed in the form and the various ReactFormMakerSteps that make it up.\n *\n * See {@link ReactFormMakerStep}\n *\n * ---\n *\n * @param {HeaderStepperItemProps} props - The properties for the component.\n * @param {StepElement} props.step - The step element.\n * @param {SizeElement} props.size - The size of the step element.\n * @param {number} props.index - The index of the step element.\n */\nexport type HeaderStepperItemInterface = React.ForwardRefExoticComponent<\n  HeaderStepperItemProps & React.RefAttributes<HTMLDivElement>\n> & {\n  displayName?: string;\n};\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/HeaderStepperItem.style.ts": "// HeaderStepperItem.style.ts\nimport { cn } from '@/lib/utils';\n\ninterface StyleProps {\n  isdisabled: boolean;\n  isCurrent: boolean;\n  isDone: boolean;\n  currentStepIndex: number;\n  stepIndex: number;\n  orientation: string;\n}\n\nclass HeaderStepperItemStyle {\n  opacityClass: string;\n\n  cursorClass: string;\n\n  barProgressClass: string;\n\n  stepDirectionContainerClass: string;\n\n  positionLabelClass: string;\n\n  progressBarPositionClass: string;\n\n  constructor(props: StyleProps) {\n    this.opacityClass = cn(\n      'opacity-60', // Default opacity\n      {\n        'opacity-80': props.isDone,\n        'opacity-100': props.isCurrent,\n        'opacity-40': props.isdisabled,\n      },\n    );\n\n    this.cursorClass = cn({\n      'cursor-not-allowed': props.isdisabled,\n      'cursor-pointer': !props.isdisabled,\n    });\n\n    this.barProgressClass = cn({\n      'bg-primary': props.currentStepIndex > props.stepIndex,\n      'bg-gray-200': props.currentStepIndex <= props.stepIndex,\n    });\n\n    this.stepDirectionContainerClass = cn({\n      'flex flex-col items-center justify-center mx-2 relative w-8 h-8 z-10':\n        props.orientation === 'horizontal',\n      'flex flex-row relative': props.orientation !== 'horizontal',\n    });\n\n    this.positionLabelClass = cn({\n      'w-1 h-8 text-center absolute top-0 transform translate-y-[32px] flex flex-col h-24':\n        props.orientation === 'horizontal',\n      'text-start absolute top-0 transform translate-x-[32px] flex flex-col h-24':\n        props.orientation !== 'horizontal',\n    });\n\n    this.progressBarPositionClass = cn({\n      'flex-1 h-0.5': props.orientation === 'horizontal',\n      'flex-1 w-0.5 ml-3': props.orientation !== 'horizontal',\n    });\n  }\n}\n\nexport default HeaderStepperItemStyle;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/StepInfoDisplay.component.tsx": "// StepInfoDisplay.component.tsx\nimport { forwardRef } from 'react';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@radix-ui/react-tooltip';\nimport { Large, Muted } from '@/components/ui/Typography';\n\ntype StepInfoDisplayProps = {\n  stepName: string;\n  legend: string | undefined;\n  orientation: string;\n  maxWidth: number;\n  opacityClass: string;\n  positionTooltip: () => 'center' | 'start' | 'end';\n};\n\nconst StepInfoDisplay = forwardRef<HTMLDivElement, StepInfoDisplayProps>(\n  ({ stepName, legend, orientation, opacityClass, positionTooltip }, ref) => {\n    return (\n      <>\n        {orientation === 'horizontal' ? (\n          <TooltipProvider delayDuration={300}>\n            <Tooltip>\n              <TooltipTrigger disabled>\n                <span className={`max-h-[72px] line-clamp-3 ${opacityClass}`}>\n                  {stepName}\n                </span>\n              </TooltipTrigger>\n              <TooltipContent\n                side=\"bottom\"\n                align={positionTooltip()}\n                className=\"z-99 bg-[#000000FE] p-2 rounded-lg\"\n              >\n                <Muted className=\"max-w-[200px] block \">{legend}</Muted>\n              </TooltipContent>\n            </Tooltip>\n          </TooltipProvider>\n        ) : (\n          <div className={opacityClass} ref={ref}>\n            <Large className=\"text-md\">{stepName}</Large>\n            <Muted>{legend}</Muted>\n          </div>\n        )}\n      </>\n    );\n  },\n);\n\nStepInfoDisplay.displayName = 'StepInfoDisplay';\n\nexport default StepInfoDisplay;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/HeaderStepper/HeaderStepperItem/useHeaderStepperItem.hook.tsx": "// useHeaderStepperItem.hook.ts\nimport { useCallback, useRef, useImperativeHandle, createElement } from 'react';\nimport { Circle, CircleCheck, CircleDashed, CircleDotIcon } from 'lucide-react';\nimport HeaderStepperItemStyle from './HeaderStepperItem.style';\nimport { useStepper } from '@/components/ReactFormMaker/formElements/Stepper/StepperContext';\nimport { type SizeElement } from '../HeaderStepper.hook';\nimport { type StepElement } from '../../StepperContext.interface';\n\ninterface UseHeaderStepperItemProps {\n  step: StepElement;\n  index: number;\n  size: SizeElement;\n  ref: React.Ref<HTMLDivElement>;\n}\n\nexport function useHeaderStepperItem({\n  step,\n  size,\n  ref,\n}: UseHeaderStepperItemProps) {\n  const { stepName, stepIndex, legend, isNext, isDone, isdisabled, isCurrent } =\n    step;\n\n  const { getCurrentStep, steps, goToStep, orientation, getListenerObserver } =\n    useStepper();\n\n  const localRef = useRef<HTMLDivElement | null>(null);\n  useImperativeHandle(ref, () => localRef.current as HTMLDivElement);\n\n  const styleProps = {\n    isdisabled,\n    isCurrent,\n    isDone,\n    currentStepIndex: getCurrentStep().stepIndex,\n    stepIndex,\n    orientation,\n  };\n\n  const styles = new HeaderStepperItemStyle(styleProps);\n\n  const isLastStep = useCallback(\n    () => stepIndex === steps.length - 1,\n    [stepIndex, steps.length],\n  );\n\n  const maxWidth =\n    size.width > 0 ? Math.floor(size.width / steps.length - 12) : 150;\n\n  const icon = useCallback(() => {\n    if (step.IconStep) {\n      return createElement(step.IconStep, { className: styles.opacityClass });\n    }\n    if (isCurrent) return <CircleDotIcon className={styles.opacityClass} />;\n    if (isDone) return <CircleCheck className={styles.opacityClass} />;\n    if (isdisabled) return <CircleDashed className={styles.opacityClass} />;\n    if (isNext) return <Circle className={styles.opacityClass} />;\n    return <Circle className={styles.opacityClass} />;\n  }, [isCurrent, isDone, isNext, isdisabled, styles.opacityClass]);\n\n  const ajustHeightProgressBar = () => {\n    if (orientation === 'horizontal') return { height: '1px' };\n    const heightBar =\n      localRef.current !== null\n        ? {\n            'min-height': `${localRef.current.offsetHeight.toString()}px`,\n            'max-height': `${localRef.current.offsetHeight.toString()}px`,\n          }\n        : { flex: 1 };\n    return heightBar;\n  };\n\n  const positionTooltip = (): 'start' | 'end' | 'center' => {\n    if (orientation === 'horizontal') {\n      if (stepIndex === 0) return 'start';\n      if (stepIndex === steps.length - 1) return 'end';\n      return 'center';\n    }\n    return 'start';\n  };\n\n  const infoShouldBeDisplayed = (maxWidth: number) => {\n    if (orientation === 'horizontal') return maxWidth > 80;\n    return true;\n  };\n\n  function formIsLoading(): boolean {\n    return getListenerObserver(getCurrentStep().stepIndex) === 'loading';\n  }\n\n  return {\n    stepName,\n    legend,\n    isLastStep,\n    localRef,\n    styles,\n    maxWidth,\n    icon,\n    ajustHeightProgressBar,\n    positionTooltip,\n    infoShouldBeDisplayed,\n    goToStep,\n    orientation,\n    formIsLoading,\n  };\n}\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/Stepper.component.tsx": "import React, { type ReactNode, useEffect } from 'react';\nimport type { FieldValues } from 'react-hook-form';\nimport useResizeObserver from '@react-hook/resize-observer';\nimport { cn } from '@/lib/utils';\nimport { useStepper } from '../StepperContext';\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\ninterface StepperProps<T extends FieldValues> {\n  children: ReactNode;\n}\n/**\n * ### Stepper Component\n *\n * The `Stepper` component is a component that allows you to display the stepper.\n *\n * ---\n *\n * #### Behavior\n *  > _Becarfull ! Orientation define the orientation of navigation stepper_\n *\n * - The orientation of the stepper is updated when the width of the container changes.\n * - The orientation of the stepper is horizontal by default.\n * - The orientation of the stepper is horizontal when the width of the container is less than 768px.\n *\n * ---\n *\n *\n * @param param0\n * @returns\n */\nfunction Stepper<T extends FieldValues>({\n  children,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement> & StepperProps<T>) {\n  const { orientation: stepperOrientation, shiftOrientation } = useStepper();\n  const wrapperRef = React.useRef<HTMLDivElement>(null);\n  const [cnOrientation, setCnOrientation] =\n    React.useState<string>(' flex flex-row');\n\n  useResizeObserver(wrapperRef, (entry) => {\n    shiftOrientation(entry.contentRect.width);\n  });\n\n  useEffect(() => {\n    if (stepperOrientation === 'horizontal') {\n      setCnOrientation(' flex flex-col gap-4');\n    } else {\n      setCnOrientation(' flex flex-row');\n    }\n  }, [stepperOrientation]);\n\n  return (\n    <div\n      ref={wrapperRef}\n      className={cn('relative ', props.className) + cnOrientation}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport { Stepper };\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperContent.tsx": "import React, { useEffect, useRef } from 'react';\nimport { cn } from '@/lib/utils';\nimport { useStepper } from '../StepperContext';\n\n/**\n * ### StepperContent Component\n *\n * The `StepperContent` component is a component that allows you to display the content of the stepper.\n * Here, the content of the stepper is displayed in a horizontal way. A slider is used to display the content of the stepper.\n *\n * ---\n *\n * #### Behavior\n *\n * - Position of the slider is updated when the step index changes.\n * - The slider is translated by the percentage of the step index.\n * - First Div is the container of the slider in overflow hidden (don't show the content outside the container).\n */\nconst StepperContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const sliderRef = useRef<HTMLDivElement>(null);\n  const { stepIndex, getNbSteps } = useStepper();\n\n  useEffect(() => {\n    const newPos = stepIndex * 100;\n    sliderRef.current?.style.setProperty(\n      'transform',\n      `translateX(-${newPos}%)`,\n    );\n  }, [stepIndex]);\n\n  return (\n    <div ref={ref} className=\"overflow-hidden flex-auto\">\n      <div\n        ref={sliderRef}\n        className={cn(\n          'flex',\n          `w-[${getNbSteps() * 100}%]`,\n          'transition-transform',\n          'duration-300',\n          'transform',\n          'ease-in-out',\n          className,\n        )}\n        {...props}\n      />\n    </div>\n  );\n});\nStepperContent.displayName = 'StepperContent';\n\nexport { StepperContent };\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperContext.interface.tsx": "import type { FieldError, FieldValues, UseFormReturn } from 'react-hook-form';\nimport { z } from 'zod';\nimport type { ReactFormMakerStep } from '../../../interfaces/FieldInterfaces';\n\n/**\n * **Define the structure of a field state in the stepper context**\n *\n * _Cette interface rsume l'tat d'un champs selon le formContext de React Hook Form_\n */\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nexport interface FieldState<T> {\n  /**\n   * @type {boolean}\n   *\n   * **Define if the field is valid**\n   *\n   * _The valid state is a boolean that indicates if React Hook Form considers the field to be valid.\n   * More explicitly, it is the result of the validation of the field by the zod schema._\n   */\n  invalid: boolean;\n\n  /**\n   * @type {boolean}\n   *\n   * **Define if the field is dirty**\n   * _The dirty state is a boolean that indicates if the field has been modified by the user._\n   */\n  isDirty: boolean;\n\n  /**\n   * @type {boolean}\n   *\n   * **Define if the field is touched**\n   * _The touched state is a boolean that indicates if the field has been touched by the user._\n   */\n  isTouched: boolean;\n\n  /**\n   * @type {boolean}\n   *\n   * **Define if the field is validating**\n   *\n   * _The validating state is a boolean that indicates if the field is currently being validated by the zod schema._\n   */\n  isValidating: boolean;\n\n  /**\n   * @type {FieldError | undefined}\n   *\n   * **Define the error of the field**\n   *\n   * _The error state is an object that contains the error message if the field is invalid._\n   * _If the field is valid, the error state is undefined._\n   * _The error message is the message returned by the zod schema if the field is invalid._\n   *\n   * @see {@link FieldError}\n   */\n  error?: FieldError | undefined;\n}\n\n/**\n * **Define the structure of a field state detail in the stepper context for each fields**\n *\n * _This interface summarizes the state of a field according to the formContext of React Hook Form_\n */\nexport interface FieldStatesDetail<T> {\n  /**\n   * @type {boolean}\n   *\n   * **Defines whether the field is considered valid as a whole.**\n   *\n   * _The fluctuation of this value is arbitrary and depends on whether the original field has optional or nullable attributes._\n   */\n  isValid: boolean;\n\n  /**\n   * @type {any}\n   *\n   * **Value of the field**\n   *\n   * _The value of the field is the value entered by the user in the field._\n   * _This value can be the default value applied by the program._\n   */\n  value: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  /**\n   * @type {FieldState<T>}\n   *\n   * **State of the field**\n   *\n   * _Allows you to obtain more details about the reason for the isValid state_\n   *\n   * @see {@link FieldState}\n   */\n  FieldState: FieldState<T>;\n\n  /**\n   * @type {z.ZodType<T>}\n   *\n   * **Zod schema of the field**\n   *\n   * _The zod schema of the field is the schema used to validate the field._\n   *\n   * @see {@link z.ZodType}\n   */\n  zField: z.ZodType<T>;\n}\n\n/**\n * **Define the structure of a step form state in the stepper context**\n *\n * This interface brings together all the status of the fields that make it up. It provides a general overview of form status, as well as precise details on the status of each form.\n */\nexport interface StepFormState<T> {\n  /**\n   * @type {boolean}\n   *\n   * **Define if the step is valid**\n   *\n   * _The isValidStep state defines whether the step is considered valid as a whole._\n   *\n   * _This state is a general synthesis of all the fields that make it up. It is true if all fields are considered valid._\n   *\n   * ---\n   *\n   * > **Warning**: this state does not ensure that nullable or optional fields are in a dirty state.\n   */\n  isValidStep: boolean;\n\n  /**\n   * @type {FieldStatesDetail<T>[]}\n   *\n   * **Details of the fields of the step**\n   *\n   * _The fieldStatesDetails state is a list of all the fields that make up the step, with their respective states._\n   *\n   * ---\n   *\n   * @see {@link FieldStatesDetail}\n   */\n  fieldStatesDetails: { [key: string]: FieldStatesDetail<T> };\n}\n\n/**\n * **Define the structure of a step element in the stepper context**\n *\n * _Step Element is a representation of a step, it contains all the information needed to manage the step and its fields_\n * _Here states could be managed to know if the step is done, current, next, disabled, subjected to strict effect or subjected to disabled effect_\n *\n * ---\n *\n * @param {number} stepIndex - The index of the step in the stepper\n * @param {boolean} isDone - The state of the step, if it is done or not\n * @param {boolean} isCurrent - The state of the step, if it is the current step or not\n * @param {boolean} isNext - The state of the step, if it is the next step or not\n * @param {boolean} isdisabled - The state of the step, if it is disabled or not\n * @param {string[]} subjectedStrictSteps - list of other steps that block this step due to their strict effect\n * @param {string[]} subjectedDisabledBeforeSteps - list of other steps that block this step due to their constraint effect after their respective submission: disabledBefore state.\n *\n * ---\n *\n * @extends {ReactFormMakerStep}\n * @see {@link ReactFormMakerStep}\n */\nexport interface StepElement extends ReactFormMakerStep {\n  /**\n   * @type {number}\n   *\n   * **Indexation of the step in the stepper**\n   *\n   * _Index is incremented by 1 for each step_\n   *\n   * _Index starts at 0_\n   *\n   */\n  stepIndex: number;\n  /**\n   * @type {boolean}\n   *\n   * **Define if the step is done**\n   * The isDone state defines whether the part of the form it contains, as well as each step field, has been filled in and defined as correct.\n   *\n   * _The state can change when one of the fields has been changed and returns an error, or when the next step is taken (a partial submission is then executed)._\n   */\n  isDone: boolean;\n  /**\n   * @type {boolean}\n   *\n   * **Define if the step is the current step**\n   *\n   * The isCurrent state defines whether the step is the one currently displayed in the stepper.\n   *\n   * _This field is used to follow the step displayed on the screen when the carousel is slid._\n   */\n  isCurrent: boolean;\n\n  /**\n   * @type {boolean}\n   *\n   * **Define if the step is the next step**\n   *\n   * The isNext state defines whether the step is the next step to be displayed in the stepper.\n   *\n   * _This field is used to follow the step displayed on the screen when the carousel is slid._\n   */\n  isNext: boolean;\n\n  /**\n   * @type {boolean}\n   *\n   * **Define if the step is disabled**\n   *\n   * The isDisabled state is an overview of whether the step can be consulted by the user.\n   * The isDisabled state depends on its default state, but can also be forced by adjacent steps (preceding or following)\n   *\n   *_see next two properties_.\n   */\n  isdisabled: boolean;\n\n  /**\n   * @type {string[]}\n   *\n   * **List of other steps that block this step due to their strict effect**\n   *\n   * The subjectedStrictSteps state is a list of other steps that block this step due to their strict effect.\n   *\n   *  _If the table contains at least one value, the step is considered disabled._\n   */\n  subjectedStrictSteps: string[];\n\n  /**\n   * @type {string[]}\n   *\n   * **List of other steps that block this step due to their constraint effect after their respective submission: disabledBefore state**\n   *\n   * The subjectedDisabledBeforeSteps state is a list of other steps that block this step due to their constraint effect after their respective submission: disabledBefore state.\n   *\n   * _If the table contains at least one value, the step is considered disabled._\n   */\n  subjectedDisabledBeforeSteps: string[];\n}\n\n/**\n * **Stepper Context to manage the steps of a form in a stepper components**\n *\n * _The stepper context is a context that allows you to manage the steps of a form in a stepper._\n *\n * ---\n *\n * @param {StepElement[]} steps - List of steps\n * @param {() => number} getNbSteps - Get the number of steps in the stepper\n * @param {() => StepElement} getCurrentStep - Get the current step in the stepper\n * @param {(stepIndex: number) => void} goToStep - Go to a specific step in the stepper\n * @param {() => void} goNextStep - Go to the next step in the stepper\n * @param {() => void} goPreviousStep - Go to the previous step in the stepper\n * @param {UseFormReturn<T>} form - Access the form context of React Hook Form\n * @param {() => StepFormState<T>} getFieldStatesBySteps - Get the state of the fields of the form according to the steps\n * @param {() => StepElement | undefined} getPreviousStep - Get the previous step in the stepper\n * @param {() => StepElement | undefined} getNextStep - Get the next step in the stepper\n * @param {number} stepIndex - Index of the current step in the stepper\n * @param {'vertical' | 'horizontal'} orientation - orientation of the stepper\n * @param {(width: number) => void} shiftOrientation - Shift the orientation of the stepper\n *\n */\nexport interface StepperContextProps<T extends FieldValues> {\n  /**\n   * @type {StepElement[]}\n   *\n   * **List of steps**\n   *\n   * _The steps state is a list of all the steps that make up the form._\n   *\n   * For more information :  {@link StepElement}\n   */\n  steps: StepElement[];\n\n  /**\n   * **Get the number of steps in the stepper**\n   *\n   * @returns {number}\n   */\n  getNbSteps: () => number;\n  /**\n   * ** Get the current step in the stepper**\n   * @returns {StepElement}\n   *\n   * For more informations see : {@link StepElement}\n   */\n  getCurrentStep: () => StepElement;\n\n  /**\n   * **Go to a specific step in the stepper**\n   *\n   * _handle the transition between steps_\n   *\n   * @param {number} stepIndex - The index of the step in the stepper\n   *\n   * @returns {void}\n   */\n  goToStep: (stepIndex: number) => void;\n\n  /**\n   * **Go to the next step in the stepper**\n   *\n   * _handle the transition between steps by incrementing the step index_\n   *\n   * @returns {void}\n   */\n  goNextStep: () => void;\n\n  /**\n   * **Go to the previous step in the stepper**\n   *\n   * _handle the transition between steps by decrementing the step index_\n   *\n   * @returns {void}\n   */\n  goPreviousStep: () => void;\n\n  /**\n   * **Access the form context of React Hook Form**\n   *\n   * _ Used to manage the form and its fields_\n   *\n   * @type {UseFormReturn<T>}\n   *\n   * For more informations see : {@link UseFormReturn}\n   */\n  form: UseFormReturn<T>;\n\n  /**\n   * **Get the state of the fields of the form according to the steps**\n   *\n   * _Used to manage the form and its fields whene the step form has presubmitted_\n   *\n   * @returns {StepFormState<T>}\n   * For more informations see : {@link StepFormState}\n   */\n  getFieldStatesBySteps: (stepIndex?: number) => StepFormState<T>;\n\n  /**\n   * **Get the previous step in the stepper**\n   *\n   * _Is used for control management between different step states if there are causal links between_\n   *\n   * @returns {StepElement | undefined}\n   * For more informations see : {@link StepElement}\n   */\n  getPreviousStep: () => StepElement | undefined;\n\n  /**\n   * **Get the next step in the stepper**\n   *\n   * _Is used for control management between different step states if there are causal links between_\n   * @returns {StepElement | undefined}\n   */\n  getNextStep: () => StepElement | undefined;\n\n  /**\n   * @type {number}\n   *\n   * **Index of the current step in the stepper**\n   */\n  stepIndex: number;\n\n  /**\n   * @type {'vertical' | 'horizontal'}\n   *\n   * **orientation of the stepper**\n   *\n   * _Becarful, the orientation is mutable_\n   *\n   * _The orientation state is a string that indicates the orientation of the stepper._\n   *\n   * For more informations see : {@link orientationMutable}\n   */\n  orientation: 'vertical' | 'horizontal';\n\n  /**\n   * **Shift the orientation of the stepper**\n   *\n   * _The orientation of the stepper is shifted according to the width of the component_\n   * @param width\n   * @returns\n   */\n  shiftOrientation: (width: number) => void;\n\n  /**\n   * **Get the state of the listener observer**\n   * _The listener observer is a state that allows you to know the status of the listener_\n   * @param key\n   * @returns\n   */\n  getListenerObserver: (\n    index: number,\n  ) => 'idle' | 'loading' | 'resolved' | 'rejected';\n}\n\n/**\n * **Define the structure of the orientation mutable**\n *\n * _This interface summarizes the orientation of the stepper and its mutability_\n *\n * ---\n *\n * @param {'vertical' | 'horizontal'} orientation - The orientation of the stepper\n * @param {boolean} isOriginal - The state of the orientation, if it is the original orientation or not\n */\nexport interface orientationMutable {\n  /**\n   * @type {'vertical' | 'horizontal'}\n   *\n   * Define the orientation of the stepper\n   */\n  orientation: 'vertical' | 'horizontal';\n\n  /**\n   * @type {boolean}\n   *\n   * Define if the orientation is the original orientation\n   *\n   * _If the orientation has been mutated by program, the isOriginal state is false_\n   */\n  isOriginal: boolean;\n}\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/StepperItems.tsx": "import React from 'react';\nimport { Loader2 } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useStepper } from '../StepperContext';\n\nconst StepperItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { getListenerObserver, stepIndex } = useStepper();\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        'min-w-0 shrink-0 grow-0 basis-full px-4 relative',\n        className,\n      )}\n      {...props}\n    >\n      {getListenerObserver(stepIndex) === 'loading' && (\n        <div className=\"flex justify-center items-center w-full backdrop-brightness-[110%] h-full absolute z-10 backdrop-blur-[2px]  bg-[#ffffff66] transition-all duration-300\">\n          <Loader2 size={32} className=\"animate-spin\" />\n        </div>\n      )}\n      {props.children}\n    </div>\n  );\n});\nStepperItem.displayName = 'StepperItem';\n\nexport { StepperItem };\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/stepReducer.ts": "import { type CompositeField } from '@/components/ReactFormMaker/interfaces/FieldInterfaces';\nimport type { StepElement } from './StepperContext.interface';\nimport { isStepReactFormMaker } from '@/components/ReactFormMaker/utils/typeGuards/compositeField.TypeGuards';\n\ntype TypeReducerActionNames =\n  | 'CHANGE_FOCUS'\n  | 'SET_DONE'\n  | 'REMOVE_DONE'\n  | 'SET_STRICT_DISABLED_EFFECT'\n  | 'SET_BETFORE_DISABLED_EFFECT';\n\ntype ActionType = {\n  type: TypeReducerActionNames;\n  currentStepIndex?: number;\n};\n\nexport function setStrictDisabledEffect(state: StepElement[]): StepElement[] {\n  const disabledAfterBy: string[] = [];\n\n  return state.map((step: StepElement) => {\n    const newStep = {\n      ...step,\n      subjectedStrictSteps: [...disabledAfterBy],\n      isdisabled:\n        disabledAfterBy.length > 0 ||\n        step.subjectedDisabledBeforeSteps.length > 0,\n    };\n    if (step.isStrict && !step.isDone) {\n      disabledAfterBy.push(step.stepName);\n    }\n    return newStep;\n  });\n}\n\nexport function setDisabledBeforeEffect(state: StepElement[]): StepElement[] {\n  const disabledBeforeBy: string[] = [];\n\n  const currentStates = state.map((step: StepElement) => {\n    return step;\n  });\n\n  const newStates = currentStates.reverse().map((step: StepElement) => {\n    const newStep = {\n      ...step,\n      subjectedDisabledBeforeSteps: [...disabledBeforeBy],\n      isdisabled:\n        disabledBeforeBy.length > 0 ||\n        step.subjectedStrictSteps.length > 0 ||\n        (step.disabledBefore !== undefined &&\n          step.disabledBefore === true &&\n          step.isDone),\n    };\n    if (step.disabledBefore && step.isDone) {\n      disabledBeforeBy.push(step.stepName);\n    }\n    return newStep;\n  });\n\n  return newStates.reverse();\n}\n\nexport function initialSteps(formfields: CompositeField[]): StepElement[] {\n  const currentForm: StepElement[] = formfields\n    .filter((field) => isStepReactFormMaker(field))\n    .map((step, index) => ({\n      ...step,\n      stepIndex: index,\n      isDone: false,\n      isCurrent: index === 0,\n      isNext: index === 1,\n      isdisabled: false,\n      subjectedStrictSteps: [],\n      subjectedDisabledBeforeSteps: [],\n    }));\n\n  const currentFormWithStrictEffect = setStrictDisabledEffect(currentForm);\n  return setDisabledBeforeEffect(currentFormWithStrictEffect);\n}\n\nconst stepReducer = (\n  state: StepElement[],\n  action: ActionType,\n): StepElement[] => {\n  switch (action.type) {\n    case 'SET_STRICT_DISABLED_EFFECT':\n      return setStrictDisabledEffect(state);\n\n    case 'SET_BETFORE_DISABLED_EFFECT':\n      return setDisabledBeforeEffect(state);\n\n    case 'CHANGE_FOCUS':\n      return state.map((step, index) => {\n        if (action.currentStepIndex === undefined) {\n          throw new Error(\n            'currentStepIndex is required for CHANGE_FOCUS action',\n          );\n        }\n        if (index === action.currentStepIndex) {\n          return {\n            ...step,\n            isCurrent: true,\n            isNext: false,\n          };\n        }\n        if (index === action.currentStepIndex + 1) {\n          return {\n            ...step,\n            isNext: true,\n            isCurrent: false,\n          };\n        }\n        return {\n          ...step,\n          isCurrent: false,\n          isNext: false,\n        };\n      });\n    case 'SET_DONE':\n      return state.map((step, index) => {\n        if (index === action.currentStepIndex) {\n          return {\n            ...step,\n            isDone: true,\n          };\n        }\n        return step;\n      });\n    case 'REMOVE_DONE':\n      return state.map((step, index) => {\n        if (index === action.currentStepIndex) {\n          return {\n            ...step,\n            isDone: false,\n          };\n        }\n        return step;\n      });\n    default:\n      return state;\n  }\n};\n\nexport default stepReducer;\n",
  "/ReactFormMaker/formElements/Stepper/SteppersElements/useStepperItemMap.hook.tsx": "import React, { useCallback } from 'react';\nimport type {\n  CompositeField,\n  FieldReactFormMaker,\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  ReactFormMakerStep,\n} from '../../../interfaces/FieldInterfaces';\nimport { StepperItem } from './StepperItems';\nimport { isStepReactFormMaker } from '../../../utils/typeGuards/compositeField.TypeGuards';\nimport { H3, Lead } from '@/components/ui/Typography';\n\ninterface UseStepperItemsMapReturn {\n  /**\n   * ### Array of StepperItems components\n   *\n   * This function allows you to map the form fields to the StepperItems component.\n   *\n   * ---\n   *\n   *  #### StepperItem Content\n   *\n   * The StepperItem component is a component that allows you to display the content of the stepper :\n   *  - The title of the step is displayed in a `H3` tag.\n   *  - The legend of the step is displayed in a `Lead` tag. (optional, if the legend is not defined, the tag is not displayed)\n   *  - Rest of fields are displayed by the `FieldReactFormMaker` present in the each `ReactFormMakerStep` object.\n   *\n   * ---\n   *\n   * For more information, see the {@link FieldReactFormMaker} and {@link ReactFormMakerStep} interfaces.\n   *\n   * @param formfields\n   * @returns\n   */\n  StepperItemsMap: (\n    formfields: CompositeField[],\n  ) => (React.ReactElement<typeof StepperItem> | null)[];\n}\n\nexport function useStepperItemsMap(\n  FormFieldsMap: (dataField: CompositeField[]) => (React.JSX.Element | null)[],\n): UseStepperItemsMapReturn {\n  const StepperItemsMap = useCallback(\n    (\n      formfields: CompositeField[],\n    ): (React.ReactElement<typeof StepperItem> | null)[] => {\n      return formfields.map((element, index) => {\n        if (isStepReactFormMaker(element)) {\n          return (\n            <StepperItem\n              key={`stepper-${element.stepName}-${index}`}\n              className={`${element.className} ${element.isHide ? 'hidden' : ''}`}\n            >\n              <H3 className={element?.legendClassName}>{element.stepName}</H3>\n              {element?.legend && (\n                <Lead className={element?.legendClassName}>\n                  {element.legend}\n                </Lead>\n              )}\n              {FormFieldsMap(element.fields as FieldReactFormMaker[])}\n            </StepperItem>\n          );\n        }\n        return null;\n      });\n    },\n    [FormFieldsMap],\n  );\n\n  return { StepperItemsMap };\n}\n",
  "/ReactFormMaker/FormFields/Class/FieldFactory/FieldFactory.class.ts": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z, ZodString, ZodType, type ZodTypeDef } from 'zod';\nimport React from 'react';\nimport type {\n  DividerReactFormMaker,\n  FieldReactFormMaker,\n  InputType,\n  ReactFormMakerFieldset,\n} from '../../../interfaces/FieldInterfaces';\nimport type { FormFieldEvent } from '../../../interfaces/FormFieldEvent';\nimport type { CustomInputFieldElementParams } from '@/components/ReactFormMaker/interfaces/CustomInputFieldElementParams';\nimport type { Option } from '@/components/ReactFormMaker/utils/typeGuards/optionsFields.TypeGuards';\n\nimport {\n  isBetween,\n  islaterThan,\n  isOlderThan,\n  type SimpleDurationValues,\n} from '../../../utils/validators/dateValidators';\n\n/**\n * Represents a condition where a value must be in the past.\n */\ntype Past = 'past';\n\n/**\n * Represents a condition where a value must be in the future.\n */\ntype Future = 'future';\n\n/**\n * Represents a condition where a value must be more than a specified duration.\n *\n * @property {string} type - The type of condition, which is always 'moreThan' for this interface.\n * @property {SimpleDurationValues} value - The duration value that the condition is compared against.\n */\ntype OlderThan = { type: 'olderThan'; value: SimpleDurationValues };\n\n/**\n * Represents a condition where a value must be less than a specified duration.\n *\n * @property {string} type - The type of the condition, which is always 'olderThan'.\n * @property {SimpleDurationValues} value - The value that the condition is compared against.\n */\ntype LaterThan = { type: 'laterThan'; value: SimpleDurationValues };\n\n/**\n * Represents a type that indicates a difference of values. Is used to calculate the difference in a DateRangeType between two `from` values and `to` values.\n *\n * @property type - A string literal type that is always 'differenceOf'.\n * @property value - An object of type `SimpleDurationValues` that holds the duration values.\n */\ntype IsBetween = { type: 'isBetween'; value: SimpleDurationValues };\n\ntype IsOutside = { type: 'isOutside'; value: SimpleDurationValues };\n\n// Dfinition du type ZodeDateType\n/**\n * Represents a type for date validation in Zod.\n *\n * This type can be one of the following:\n * - `Past`: A date must be in the past.\n * - `Future`: A date must be in the future.\n * - `OlderThan`: Defines a difference between today's date and the input selected by the user, e.g.{type : olderThan, value: {years: 18}} to define a birthDate for which the user must select a date prior to 18 years of age\n * - `LaterThan`: Defines a difference between today's date and the input selected by the user, e.g.{type : laterThan, value: {weeks: 1}} to define a date that must be at least 1 week away\n * - `ZodType<any, ZodTypeDef, any>`: A generic Zod type for any date validation.\n */\ntype ZodeDateType =\n  | Past\n  | Future\n  | OlderThan\n  | LaterThan\n  | ZodType<any, ZodTypeDef, any>;\n\n/**\n * Represents a date range with a start date (`from`) and an end date (`to`).\n *\n * @typedef {Object} DateRangeType\n * @property {ZodeDateType} from - The start date of the range.\n * @property {ZodeDateType} to - The end date of the range.\n */\ntype DateRangeType = {\n  from: ZodeDateType;\n  to: ZodeDateType;\n};\n\n/**\n * A type representing a date range, which can be one of the following:\n * - `DateRangeType`: A custom type representing a range of dates.\n * - `DifferenceOf`: A custom type representing the difference between two dates.\n * - `ZodType<any, ZodTypeDef, any>`: A Zod schema type that can validate any value.\n */\ntype ZodDateRangeType =\n  | DateRangeType\n  | IsBetween\n  | IsOutside\n  | ZodType<any, ZodTypeDef, any>;\n\n/**\n * Converts a string to a no-spaces string by replacing all spaces with underscores.\n * If the input string contains spaces, a warning is logged to the console.\n *\n * @param value - The input string to be converted.\n * @returns The converted string with spaces replaced by underscores.\n */\nfunction createNoSpacesString(value: string): string {\n  if (value.includes(' ')) {\n    console.warn(`Name of field cannot contain spaces: ${value}`);\n    return value.trim().replaceAll(' ', '_');\n  }\n  return value;\n}\n\n/**\n * Determines the Zod type based on the input value's type.\n *\n * @param value - The value to determine the type for.\n * @returns A ZodType corresponding to the type of the input value.\n *\n * The function returns:\n * - `z.string()` if the value is a string.\n * - `z.number()` if the value is a number.\n * - `z.boolean()` if the value is a boolean.\n * - `z.object(value)` if the value is an object.\n * - `z.any()` for any other type.\n */\nfunction defineType(value: any): ZodType<any, ZodTypeDef, any> {\n  switch (typeof value) {\n    case 'string':\n      return z.string();\n    case 'number':\n      return z.number();\n    case 'boolean':\n      return z.boolean();\n    case 'object':\n      return z.object(value);\n    default:\n      return z.any();\n  }\n}\n\nfunction stringifyDuration(duration: SimpleDurationValues): string {\n  const { years, months, weeks, days } = duration;\n  const parts = [];\n  if (years) parts.push(`${years} year${years > 1 ? 's' : ''}`);\n  if (weeks) parts.push(`${weeks} week${weeks > 1 ? 's' : ''}`);\n  if (months) parts.push(`${months} month${months > 1 ? 's' : ''}`);\n  if (days) parts.push(`${days} day${days > 1 ? 's' : ''}`);\n\n  return parts.join(', ');\n}\n\n/**\n * @template T - The type of the form data.\n *\n *\n * @attribute {T} inputName - The name of the input field.\n * @class Field\n * @implements {FieldReactFormMaker}\n */\nexport default class Field<T extends FieldReactFormMaker> {\n  inputName: string;\n\n  label?: string;\n\n  placeholder?: string;\n\n  defaultValues: any;\n\n  zodObject: ZodType<any, ZodTypeDef, any> | undefined;\n\n  inputType: InputType = 'text';\n\n  // defaultValue?: any;\n  options?: string[] | Option[];\n\n  className?: string;\n\n  isHide?: boolean;\n\n  disabled?: boolean | undefined;\n\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n\n  legend?: string;\n\n  legendClassName?: string;\n\n  description?: string;\n\n  isSecure?: boolean;\n\n  children?: React.ReactNode;\n\n  customInputFieldElement?: React.ReactNode;\n\n  props?: Record<string, any>;\n\n  onBlur?: ((event: FormFieldEvent) => void) | undefined;\n\n  onSelect?: ((event: FormFieldEvent) => void) | undefined;\n\n  onChange?: ((event: FormFieldEvent) => void) | undefined;\n\n  onClick?: ((event: FormFieldEvent) => void) | undefined;\n\n  constructor(name: string, entries?: Partial<T>) {\n    this.inputName = createNoSpacesString(name);\n    if (entries) Object.assign(this, entries);\n  }\n\n  /**\n   * Creates a Zod schema from a list of options.\n   *\n   * @param options - An array of options which can be either strings or objects with a `value` property.\n   * @param hasMultipleInput - A boolean indicating if the input can have multiple values. Defaults to `false`.\n   * @returns A Zod schema that validates the provided options.\n   *\n   * @remarks\n   * - If `options` contains objects, it assumes each object has a `value` property and creates a schema based on the type of the first `value`.\n   * - If `options` contains strings, it creates an enum schema from the strings.\n   * - The schema includes a refinement to ensure the value is one of the provided options.\n   *\n   * @example\n   * ```typescript\n   * const options = ['option1', 'option2', 'option3'];\n   * const schema = createEnumFromOptions(options);\n   * // schema will be a Zod enum schema for the provided options\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const options = [{ value: 1, label: \"first Label\" }, { value: 2, label: \"second Label\" }];\n   * const schema = createEnumFromOptions(options);\n   * // schema will be a Zod schema based on the type of the `value` property\n   * ```\n   */\n  private createEnumFromOptions(\n    options: string[] | Option[],\n    hasMultipleInput?: boolean,\n  ): ZodType<any, ZodTypeDef, any> {\n    hasMultipleInput = hasMultipleInput || false;\n    // define options type\n    const isComplexeOption =\n      typeof options[0] === 'object' && options[0].hasOwnProperty('value');\n    let zodObject: ZodType<any, ZodTypeDef, any>;\n    if (isComplexeOption) {\n      options = options as Option[];\n      const typeValue = defineType(options[0].value);\n      zodObject = hasMultipleInput ? z.array(typeValue) : typeValue;\n    } else {\n      zodObject = hasMultipleInput\n        ? z.array(z.enum(options as [string, ...string[]]))\n        : z.enum(options as [string, ...string[]]);\n    }\n\n    zodObject.refine(\n      (data: any) => {\n        if (isComplexeOption) {\n          options = options as Option[];\n          return options.some((option) => option.value === data);\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-unsafe-argument */\n        return options.includes(data);\n      },\n      {\n        message: 'Invalid option selected',\n      },\n    );\n\n    return zodObject;\n  }\n\n  /**\n   * Defines a Zod date type based on the provided `ZodeDateType`.\n   *\n   * @param type - The type of date validation to apply. It can be one of the following:\n   * - 'past': Validates that the date is in the past.\n   * - 'future': Validates that the date is in the future.\n   * - An object with a `type` property:\n   *   - `{ type: 'olderThan', value: Date }`: Validates that the date is older than the specified value.\n   *   - `{ type: 'laterThan', value: Date }`: Validates that the date is later than the specified value.\n   * - An instance of `ZodType`: Uses the provided Zod type for validation.\n   *\n   * @returns A Zod date type with the specified validation.\n   */\n  private defineZodDateType(type: ZodeDateType): ZodType<any, ZodTypeDef, any> {\n    switch (type) {\n      case 'past':\n        return z.date().refine((date) => date < new Date(), {\n          message: 'Date must be in the past',\n        });\n      case 'future':\n        return z.date().refine((date) => date > new Date(), {\n          message: 'Date must be in the future',\n        });\n      default:\n        if (typeof type === 'object' && 'type' in type) {\n          if (type.type === 'olderThan') {\n            return z.date().refine((date) => isOlderThan(date, type.value), {\n              message: `Date must be later than ${stringifyDuration(type?.value)} ago`,\n            });\n          }\n          if (type.type === 'laterThan') {\n            return z.date().refine((date) => islaterThan(date, type.value), {\n              message: `Date must be older than ${stringifyDuration(type?.value)} away`,\n            });\n          }\n        } else if (type instanceof ZodType) {\n          return type;\n        }\n    }\n\n    return z.date();\n  }\n\n  /**\n   * ** Set Config **\n   *\n   * You can set the config object for the field with this method :\n   *  - **label** : If you want to set a label it will be displayed above the field\n   *  - **placeholder** : If you want to set a placeholder\n   * - **defaultValues** : If you want to set a default value (warning: this value will be overrided by the value in the form)\n   * - **zodObject** : Set a zod object to validate the field (see zod documentation: https://zod.dev/\n   * - **inputType** : Set the type of the input. _is recommended to use the methods provided by the class to set the input type_\n   * - **options** : If you want to set options for a select or radio input (only used for select and radio input type)\n   * - **className** : If you want to set a class name to the\n   * - **isHide** : If you want to hide the field\n   * - **disabled** : If you want to disable the field\n   * - **fields** : If you want to set a fieldset\n   * - **legend** : If you want to set a legend to the fieldset\n   * - **legendClassName** : If you want to set a class name to the legend\n   * - **description** : If you want to set a description to the field\n   * - **isSecure** : If you want to set the field as secure\n   * - **children** : If you want to set children to the field (is recommended to use the methods provided by the class to set)\n   *\n   * ---\n   * Set the config object for the field\n   * @param entries config object to set\n   * @returns\n   */\n  setConfig(entries: Partial<FieldReactFormMaker>): this {\n    Object.assign(this, entries);\n    return this;\n  }\n\n  /**\n   * @description\n   * The onBlur event of the input field.\n   * This is the onBlur event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * _This is optional._\n   *\n   * ---\n   *\n   * @see {@link FormFieldEvent}\n   */\n  public handlerBlur(callback: (e: FormFieldEvent) => void): this {\n    this.onBlur = callback;\n    return this;\n  }\n\n  /**\n   * @description\n   * The onFocus event of the input field.\n   * This is the onFocus event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<T> to the event for controlling the form directly from the event.\n   * _This is optional._\n   *\n   * ---\n   *\n   * @see {@link FormFieldEvent}\n   */\n  public handlerSelect(callback: (e: FormFieldEvent) => void): this {\n    this.onSelect = callback;\n    return this;\n  }\n\n  /**\n   * @description\n   * The onChange event of the input field.\n   * This is the onChange event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * _This is optional._\n   * You can use it to trigger the onChange event of the input field.\n   *\n   * ---\n   *\n   * @see {@link FormFieldEvent}\n   */\n  public handlerChange(callback: (e: FormFieldEvent) => void): this {\n    this.onChange = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback function to be executed when a click event occurs on the form field.\n   * is used whene native trigger of click is on element of the field\n   * like TileSelector, TileMultiSelector, and cutom component\n   *\n   * @param callback - The function to be called when the click event is triggered.\n   *                   It receives a `FormFieldEvent` object as its argument.\n   * @returns The current instance of the class, allowing for method chaining.\n   */\n  public handlerClick(callback: (e: FormFieldEvent) => void): this {\n    this.onClick = callback;\n    return this;\n  }\n\n  /**\n   * Sets the input type to 'text' and optionally assigns a Zod schema object for validation.\n   *\n   * @param {ZodType<any, ZodTypeDef, String>} [zodObject] - Optional Zod schema object for validation. If not provided, defaults to a string schema.\n   * @returns {this} The current instance of the class for method chaining.\n   */\n  public text(zodObject?: ZodType<any, ZodTypeDef, string>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.string();\n    }\n    this.zodObject = zodObject;\n    this.zodObject as ZodString;\n    this.inputType = 'text';\n    return this;\n  }\n\n  /**\n   * Sets the field as a password input with optional Zod validation.\n   *\n   * @param zodObject - An optional Zod schema object for validating the password. If not provided, a default schema is used.\n   *   The default schema requires:\n   *   - A minimum length of 8 characters.\n   *   - At least one uppercase letter.\n   *   - At least one lowercase letter.\n   *   - At least one number.\n   *\n   * ---\n   * @info > If you use key name `password` exactly, and second password type with namekey `confirmPassword`, the form will automaticly check if the two passwords are the same. The seconde password will be deleted from returned data for security reason.\n   * @returns The current instance of the class for method chaining.\n   */\n  public password(zodObject?: ZodType<any, ZodTypeDef, string>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z\n        .string()\n        .min(6, {\n          message: 'Password must be at least 6 characters.',\n        })\n        .refine(\n          (data) => {\n            // regex password submition\n            return data.match(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/);\n          },\n          {\n            message:\n              'Password must contain at least one uppercase letter, one lowercase letter and one number.',\n          },\n        );\n    }\n    this.zodObject = zodObject;\n    this.zodObject as ZodString;\n    this.inputType = 'password';\n    return this;\n  }\n\n  /**\n   * Configures the field as a select input with the provided options and optional Zod schema.\n   *\n   * @param option - An array of strings or Option objects representing the selectable options.\n   * @param zodObject - An optional Zod schema object for validating the selected option.\n   *  If not provided, a default schema is created based on the type of the options.\n   * @returns The current instance of the field for method chaining.\n   *\n   * ---\n   *\n   * @see {@link Option} for the interface used in the `option` argument.\n   * @see {@link createEnumFromOptions} for creating a Zod schema from the provided options when no Zod schema is provided.\n   */\n  public select(\n    option: string[] | Option[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option);\n    }\n\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'select';\n    return this;\n  }\n\n  /**\n   * Configures the field as a select autocomplete input.\n   *\n   * @param option - An array of strings or Option objects representing the selectable options.\n   * @param zodObject - An optional Zod schema object for validation. If not provided, a schema will be created from the options.\n   * If the options are strings, the schema will be an enum schema. If the options are objects, the schema will be based on the type of the `value` property.\n   * @returns The current instance of the class for method chaining.\n   *\n   * ---\n   *\n   * @see {@link Option} for the interface used in the `option` argument.\n   * @see {@link createEnumFromOptions} for creating a Zod schema from the provided options when no Zod schema is provided.\n   */\n  public selectAutocomplete(\n    option: string[] | Option[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option);\n    }\n\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'selectAutocomplete';\n    return this;\n  }\n\n  /**\n   * Sets the input type to 'textarea' and optionally assigns a Zod validation schema.\n   *\n   * @param {ZodType<any, ZodTypeDef, String>} [zodObject] - Optional Zod validation schema for the textarea input. If not provided, defaults to a string schema.\n   * @returns {this} The current instance of the class for method chaining.\n   */\n  public textarea(zodObject?: ZodType<any, ZodTypeDef, string>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.string();\n    }\n    this.inputType = 'textarea';\n    return this;\n  }\n\n  /**\n   * Sets the field type to 'date' and assigns a Zod date schema to the field.\n   *\n   * @param {ZodeDateType} [zodObject] - An optional Zod date schema object. If not provided, a default Zod date schema will be used.\n   * Possible values for the schema are:\n   * - **past**: The date must be in the past.\n   * - **future**: The date must be in the future.\n   * - **OlderThan**: The date must be more than a specified date. The schema must be an object with a `type` property set to 'moreThan' and a `value` property with the date to compare against.\n   * - **LaterThan**: The date must be less than a specified date. The schema must be an object with a `type` property set to 'lessThan' and a `value` property with the date to compare against.\n   * - A Zod schema object for date validation.\n   * @returns {this} The current instance of the class for method chaining.\n   *\n   * @remarks OlderThan and LaterThan are used to compare the date with a specified date. he used type is SimpleDurationValues\n   * SimpleDurationValues is an object with the following properties:\n   * ```typescript\n   * type SimpleDurationValues = {\n   *    years?: number;\n   *    months?: number;\n   *    weeks?: number;\n   *    days?: number;\n   * }\n   * ```\n   *\n   * ---\n   *\n   * @example\n   * ```typescript\n   *\n   * const dateField = new Field('dateField').date('past'); ///on error return \"Date must be in the past\"\n   * const dateField = new Field('dateField').date('future'); ///on error return \"Date must be in the future\"\n   * const dateField = new Field('dateField').date({ type: 'LaterThan', value: { week: 1 } });\n   * //on error return : \"Date must be late than 1 week away\"\n   * const dateField = new Field('dateField').date({ type: 'OlderThan', value: { years: 18 } });\n   * //on error return : \"Date must be older than 18 years ago\"\n   *\n   * // Version with Zod schema if you want more specific validation\n   * const dateField = new Field('dateField').date(z.date().refine((date) => date > new Date(), { message: 'Date must be in the future' })); ///on error return \"Date must be in the future\"\n   *```\n   * ---\n   * @see {@link ZodeDateType} for the possible values for the Zod date schema.\n   * @see {@link defineZodDateType} for creating a Zod date schema based on the provided value.\n   * @see {@link SimpleDurationValues} for the interface used in the `value` property of the `moreThan` and `lessThan` schemas.\n   */\n  public date(zodDateHelper?: ZodeDateType): this {\n    if (!zodDateHelper || zodDateHelper === undefined) {\n      zodDateHelper = z.date();\n    } else {\n      zodDateHelper = this.defineZodDateType(zodDateHelper);\n    }\n    this.zodObject = zodDateHelper;\n    this.inputType = 'date';\n    return this;\n  }\n\n  /**\n   * **Date Range Picker**\n   *\n   * ---\n   *\n   * @param {ZodDateRangeType} [zodObject] - An optional Zod date range schema object. If not provided, a default Zod date range schema will be used.\n   * Possible values for the schema are:\n   * - **isBetween**: The difference between the chosen dates must be less than the specified duration. The schema must be an object with a `type` property set to 'isBetween' and a `value` property with the duration to compare against.\n   * - **isOutside**: The difference between the chosen dates must be more than the specified duration. The schema must be an object with a `type` property set to 'isOutside' and a `value` property with the duration to compare against.\n   * - A Zod schema object for date range validation.\n   *\n   *  *ZodShema need to be an object with the following properties:*\n   *\n   * ```typescript\n   *       zodObject = z.object({\n   *     from: z.date(),\n   *     to: z.date(),\n   *   });\n   * ```\n   *\n   * ---\n   *\n   * @example\n   *\n   * ```typescript\n   * const dateRangeField = new Field('dateRangeField').dateRange({ type: 'isBetween', { weeks: 1 }});\n   * //on error return : \"The difference between the chosen dates must be less than 1 week\"\n   *\n   * const dateRangeField = new Field('dateRangeField').dateRange({ type: 'isOutside', { mouths: 1, years: 1 }});\n   * //on error return : \"The difference between the chosen dates must be more than 1 month and 1 year\"\n   *\n   * // Version with Zod schema if you want more specific validation\n   * const dateRangeField = new Field('dateRangeField').dateRange(z.object({\n   *    from: z.date().refine((date) => date < new Date(), { message: 'Date must be in the past' }),\n   *   to: z.date().refine((date) => date > new Date(), { message: 'Date must be in the future' }));\n   * }));\n   * ```\n   */\n  public dateRange(zodObject?: ZodDateRangeType): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.object({\n        from: z.date(),\n        to: z.date(),\n      });\n    } else if (typeof zodObject === 'object' && 'type' in zodObject) {\n      const { type, value } = zodObject;\n      switch (type) {\n        case 'isBetween':\n          zodObject = z\n            .object({\n              from: z.date(),\n              to: z.date(),\n            })\n            .superRefine((data, ctx) => {\n              const { from, to } = data;\n              if (from && to) {\n                const constrainIsRespected = isBetween(from, to, value);\n                if (!constrainIsRespected) {\n                  ctx.addIssue({\n                    code: z.ZodIssueCode.custom,\n                    message: `The difference between the chosen dates must be less than ${stringifyDuration(value)}`,\n                  });\n                }\n              } else {\n                ctx.addIssue({\n                  code: z.ZodIssueCode.custom,\n                  message: \"You must provide a 'from' and 'to' date\",\n                });\n              }\n            });\n\n        case 'isOutside':\n          zodObject = z\n            .object({\n              from: z.date(),\n              to: z.date(),\n            })\n            .superRefine((data, ctx) => {\n              const { from, to } = data;\n              if (from && to) {\n                const constrainIsRespected = !isBetween(from, to, value);\n                if (!constrainIsRespected) {\n                  ctx.addIssue({\n                    code: z.ZodIssueCode.custom,\n                    message: `The difference between the chosen dates must be more than ${stringifyDuration(value)}`,\n                  });\n                }\n              } else {\n                ctx.addIssue({\n                  code: z.ZodIssueCode.custom,\n                  message: \"You must provide a 'from' and 'to' date\",\n                });\n              }\n            });\n      }\n    } else if (zodObject instanceof ZodType) {\n      zodObject = zodObject;\n    } else if (\n      typeof zodObject === 'object' &&\n      'from' in zodObject &&\n      'to' in zodObject\n    ) {\n      zodObject = z.object({\n        from: this.defineZodDateType(zodObject.from),\n        to: this.defineZodDateType(zodObject.to),\n      });\n    } else {\n      console.warn('Invalid date range type');\n      zodObject = z.object({\n        from: z.date(),\n        to: z.date(),\n      });\n    }\n    this.zodObject = zodObject;\n    this.inputType = 'dateRange';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * @beta This method is still in beta and may change in the future.\n   * ---\n   * define the field type as radio\n   */\n  public radio(\n    option: string[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option);\n    }\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'radio';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as checkbox\n   */\n  public checkbox(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.boolean();\n    }\n    this.zodObject = zodObject;\n    this.inputType = 'checkbox';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as switch\n   */\n  public switch(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.boolean();\n    }\n    this.inputType = 'switch';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as file\n   */\n  public file(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.instanceof(File);\n    }\n    this.zodObject = zodObject;\n    this.inputType = 'file';\n    return this;\n  }\n\n  public fileDropZone(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.array(z.instanceof(File));\n    }\n    this.zodObject = zodObject;\n    this.inputType = 'fileDropZone';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as number\n   */\n  public number(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z\n        .string()\n        .refine((data) => !isNaN(Number(data)), {\n          message: 'Invalid number',\n        })\n        .transform((data) => Number(data));\n    }\n    this.zodObject = zodObject;\n    // this.zodObject as ZodNumber;\n    this.inputType = 'number';\n    return this;\n  }\n\n  /**\n   * **Field Type: Custom**\n   *\n   * ---\n   * Allows defining a custom field using a React component. This method is useful for integrating custom components\n   * into the form system while automatically wrapping the provided properties into the `props` key.\n   *\n   * ---\n   * @template T - The type of the specific properties for the custom component.\n   *\n   * @param {React.ComponentType<CustomInputFieldElementParams<T>>} type\n   * The React component to use as the custom field. This component must accept props conforming to `CustomInputFieldElementParams<T>`.\n   *\n   * @param {T} [props]\n   * The specific properties to pass to the custom component. These properties will automatically be wrapped into the `props` key.\n   * If no properties are provided, an empty object will be passed by default.\n   *\n   * @param {...React.ReactNode} children\n   * Optional React children to include within the custom component.\n   *\n   * @returns {this} The current instance of the class, allowing method chaining.\n   *\n   * ---\n   *\n   * @remarks\n   * - This method is useful for creating custom input fields that are not covered by the standard field types.\n   * - It allows for greater flexibility and customization in the form system.\n   * - The properties like `zFields`, `fieldProps`, and `index` will be dynamically injected into the cloned component.\n   */\n  public custom<T>(\n    type: React.ComponentType<\n      CustomInputFieldElementParams<\n        T extends Record<string, any> ? T : Record<string, any>\n      >\n    >,\n    props?: T,\n    ...children: React.ReactNode[]\n  ): this {\n    this.inputType = 'custom';\n\n    // Encapsuler automatiquement les proprits dans un objet `props`\n    const wrappedProps: CustomInputFieldElementParams<\n      T extends Record<string, any> ? T : Record<string, any>\n    > = {\n      props: (props || {}) as T extends Record<string, any>\n        ? T\n        : Record<string, any>, // Si `props` est vide, on passe un objet vide\n    };\n\n    this.customInputFieldElement = React.createElement(\n      type,\n      wrappedProps,\n      ...children,\n    );\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as tileSelector\n   */\n  public tileSelector(\n    option: string[] | Option[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    // if the option is a string array, convert it to an array of options with the same value and label\n    if (typeof option[0] === 'string') {\n      option = (option as string[]).map((value) => {\n        return { value, label: value } as Option;\n      });\n    }\n\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option);\n    }\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'tileSelector';\n    return this;\n  }\n\n  /**\n   * ** Field Type **\n   *\n   * ---\n   * define the field type as tileMultiSelector\n   */\n  public tileMultiSelector(\n    option: string[] | Option[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option, true);\n    }\n\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'tileMultiSelector';\n    return this;\n  }\n\n  /**\n   * **MultiSelect**\n   *\n   * ---\n   *\n   * define the field type as multiSelect\n   * @param option\n   * @param zodObject\n   * @returns\n   */\n  public multiSelect(\n    option: string[] | Option[],\n    zodObject?: ZodType<any, ZodTypeDef, any>,\n  ): this {\n    // if the option is a string array, convert it to an array of options with the same value and label\n    if (typeof option[0] === 'string') {\n      option = (option as string[]).map((value) => {\n        return { value, label: value } as Option;\n      });\n    }\n    if (!zodObject || zodObject === undefined) {\n      zodObject = this.createEnumFromOptions(option, true);\n    }\n    this.options = option;\n    this.zodObject = zodObject;\n    this.inputType = 'multiSelect';\n    return this;\n  }\n\n  /**\n   * **Phone Number field**\n   *\n   * ---\n   *\n   * Define the field type as phoneNumber\n   * @param zodObject\n   * *optional zod object to validate the phone number, if not provided a default zod object will be used to validate the phone number on **international format***\n   * @returns\n   */\n  public phoneNumber(zodObject?: ZodType<any, ZodTypeDef, any>): this {\n    if (!zodObject || zodObject === undefined) {\n      zodObject = z.string().refine((data) => {\n        return data.match(\n          /^\\+((?:9[679]|8[035789]|6[789]|5[90]|42|3[578]|2[1-689])|9[0-58]|8[1246]|6[0-6]|5[1-8]|4[013-9]|3[0-469]|2[70]|7|1)(?:\\W*\\d){0,13}\\d$/,\n        );\n      });\n    }\n    this.zodObject = zodObject;\n    this.inputType = 'phoneNumber';\n    return this;\n  }\n\n  /**\n   * **Add childre JSX Element under the field**\n   *\n   * Set a component as children of the field\n   *\n   * @param children\n   * @returns\n   */\n  public Children<T>(\n    type: React.ComponentType<\n      CustomInputFieldElementParams<\n        T extends Record<string, any> ? T : Record<string, any>\n      >\n    >,\n    props?: T,\n    ...children: React.ReactNode[]\n  ): this {\n    // Encapsuler automatiquement les proprits dans un objet `props`\n    const wrappedProps: CustomInputFieldElementParams<\n      T extends Record<string, any> ? T : Record<string, any>\n    > = {\n      props: (props || {}) as T extends Record<string, any>\n        ? T\n        : Record<string, any>, // Si `props` est vide, on passe un objet vide\n    };\n\n    this.children = React.createElement(type, wrappedProps, ...children);\n    return this;\n  }\n\n  /**\n   * **Disabled input**\n   *\n   * @param value Can be use a codition to enable or disable the field, by default the field is disabled\n   * @returns\n   */\n  disable(value: boolean = true): this {\n    this.disabled = value;\n    return this;\n  }\n\n  /**\n   * ** Hide input **\n   *\n   * @param value Can be use a codition to hide or show the field, by default the field is hidden\n   * @returns\n   */\n  hide(value: boolean = true): this {\n    this.isHide = value;\n    return this;\n  }\n\n  /**\n   * **Optionnal input**\n   * @param value define the field as optional\n   * @returns\n   */\n  optionnal(value: boolean = true): this {\n    if (value) {\n      this.zodObject = this.zodObject\n        ? this.zodObject.optional()\n        : z.any().optional();\n    }\n    return this;\n  }\n\n  /**\n   * Define the field as nullable\n   * @param value define the field as nullable or not by default the field is nullable\n   * @returns\n   */\n  nullable(value: boolean = true): this {\n    if (value) {\n      this.zodObject = this.zodObject\n        ? this.zodObject.nullable()\n        : z.any().nullable();\n    }\n    return this;\n  }\n\n  /**\n   * **Set error a single error message**\n   *\n   * ---\n   *\n   * Set a custom error message for the field. This method will override any previous error messages set for the field.\n   * * @param message The error message to set for the field.\n   * * @returns The current instance of the field for method chaining.\n   *\n   * ---\n   *\n   * *If you need to set complex error messages, you need to improve the setValidation method with a custom zod object.*\n   */\n  public err(message: string): this {\n    if (this.zodObject) {\n      this.zodObject = this.zodObject.refine(() => false, {\n        message,\n      });\n    } else {\n      this.zodObject = z.any().refine(() => false, {\n        message,\n      });\n    }\n    return this;\n  }\n\n  /** GETTER */\n\n  getConfig(): Partial<FieldReactFormMaker> {\n    return {\n      inputName: this.inputName,\n      label: this.label,\n      placeholder: this.placeholder,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      defaultValues: this.defaultValues,\n      zodObject: this.zodObject,\n      inputType: this.inputType,\n      options: this.options,\n      className: this.className,\n      isHide: this.isHide,\n      disabled: this.disabled,\n      fields: this.fields,\n      legend: this.legend,\n      legendClassName: this.legendClassName,\n      description: this.description,\n      isSecure: this.isSecure,\n      children: this.children,\n      customInputFieldElement: this.customInputFieldElement,\n      props: this.props,\n    };\n  }\n\n  /**\n   * Get the field name\n   * @returns\n   */\n  getName(): string {\n    return this.inputName;\n  }\n\n  /**\n   * Get the field type\n   * @returns\n   */\n  getType(): InputType {\n    return this.inputType;\n  }\n\n  /**\n   * Get the field label\n   * @returns\n   */\n  getLabel(): string | undefined {\n    return this.label;\n  }\n\n  /**\n   * Get the field placeholder\n   * @returns\n   */\n  getPlaceholder(): string | undefined {\n    return this.placeholder;\n  }\n\n  /**\n   * Get the field default value\n   * @returns\n   */\n  getDefaultValues(): any {\n    return this.defaultValues;\n  }\n\n  getZodObject(): ZodType<any, ZodTypeDef, any> | undefined {\n    return this.zodObject;\n  }\n\n  getOptions(): string[] | Option[] | undefined {\n    return this.options;\n  }\n\n  getClassName(): string | undefined {\n    return this.className;\n  }\n\n  isHidden(): boolean | undefined {\n    return this.isHide;\n  }\n\n  isDisabled(): boolean | undefined {\n    return this.disabled;\n  }\n\n  getFields():\n    | (FieldReactFormMaker | DividerReactFormMaker | ReactFormMakerFieldset)[]\n    | undefined {\n    return this.fields;\n  }\n\n  getLegend(): string | undefined {\n    return this.legend;\n  }\n\n  getLegendClassName(): string | undefined {\n    return this.legendClassName;\n  }\n\n  getDescription(): string | undefined {\n    return this.description;\n  }\n\n  hasSecure(): boolean | undefined {\n    return this.isSecure;\n  }\n\n  getChildren(): React.ReactNode | undefined {\n    return this.children;\n  }\n\n  getCustomInputFieldElement(): React.ReactNode | undefined {\n    return this.customInputFieldElement;\n  }\n\n  getProps(): Record<string, any> | undefined {\n    return this.props;\n  }\n\n  /**\n   * Get the field value\n   * @returns\n   */\n  getValue(): any {\n    return this.props?.value;\n  }\n\n  /** SETTER */\n\n  /**\n   * Set the field name\n   * @param value\n   * @returns\n   */\n  setName(value: string): this {\n    this.inputName = value;\n    return this;\n  }\n\n  /**\n   * Set the field label\n   * @param value\n   * @returns\n   */\n  setLabel(value: string): this {\n    this.label = value;\n    return this;\n  }\n\n  /**\n   * Set the field placeholder\n   * @param value\n   * @returns\n   */\n  setPlaceholder(value: string): this {\n    this.placeholder = value;\n    return this;\n  }\n\n  /**\n   * Set the field default value\n   * @param value\n   * @returns\n   */\n  setDefaultValues(value: any): this {\n    /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */\n    this.defaultValues = value;\n    return this;\n  }\n\n  /**\n   * set if the field is disabled\n   * @param value\n   * @returns\n   */\n  setDisabled(value: boolean): this {\n    this.disabled = value;\n    return this;\n  }\n\n  /**\n   * Set the field zod object\n   * @param value\n   * @returns\n   */\n  setValidation(value: ZodType<any, ZodTypeDef, any>): this {\n    this.zodObject = value;\n    return this;\n  }\n}\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n",
  "/ReactFormMaker/FormFields/Class/FieldFactory/README.MD": "# FieldFactory Class\n\n## Proprits de la classe `FieldFactory`\n\n| Attribut          | Type                                               | Requis    | Description                                                                                                                                                       |\n| ----------------- | -------------------------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `inputName`       | `string`                                           | Requis    | Le nom du champ d'entre. C'est la cl de l'objet retourn lorsque le formulaire est soumis.                                                                      |\n| `label`           | `string`                                           | Optionnel | Le label du champ d'entre, affich au-dessus du champ pour des raisons d'accessibilit.                                                                          |\n| `placeholder`     | `string`                                           | Optionnel | Le texte du placeholder affich  l'intrieur du champ lorsqu'il est vide. Pertinent pour les types d'entre comme texte, mot de passe, textarea, date et nombre. |\n| `inputType`       | `string`                                           | Requis    | Le type du champ d'entre  afficher.                                                                                                                             |\n| `zodObject`       | `ZodType<any>`                                     | Optionnel | L'objet Zod utilis pour valider le champ d'entre. Recommand pour une validation type-safe. [Plus d'infos](https://zod.dev/?id=primitives).                     |\n| `defaultValues`   | `any`                                              | Optionnel | Les valeurs par dfaut affiches dans le champ d'entre.                                                                                                          |\n| `options`         | `string[]` ou `{ value: string; label: string }[]` | Optionnel | Options pour les types d'entre `select`, `radio` ou `checkbox`. Requis si le type d'entre est l'un de ceux-ci.                                                  |\n| `className`       | `string`                                           | Optionnel | La classe CSS pour styliser le champ d'entre en utilisant Tailwind CSS. [Plus d'infos](https://tailwindcss.com/).                                                |\n| `disabled`        | `boolean`                                          | Optionnel | Dsactive le champ d'entre lorsqu'il est vrai.                                                                                                                   |\n| `fields`          | `(extended CompositeField)[]`                      | Optionnel | Composants enfants affichs dans le champ d'entre.                                                                                                               |\n| `isDiv`           | `boolean`                                          | Optionnel | Si vrai, rend le fieldset comme un `<div>` au lieu d'un `<fieldset>` smantique.                                                                                  |\n| `legend`          | `string`                                           | Optionnel | La lgende du champ d'entre affiche comme le titre du fieldset.                                                                                                 |\n| `legendClassName` | `string`                                           | Optionnel | La classe CSS pour styliser la lgende en utilisant Tailwind CSS.                                                                                                 |\n| `description`     | `string`                                           | Optionnel | Le texte de description affich avec le champ d'entre.                                                                                                           |\n| `isSecure`        | `boolean`                                          | Optionnel | Cache le champ d'entre pour des raisons de scurit lorsqu'il est vrai.                                                                                          |\n\n## Constructeur\n\n```typescript\nconstructor(name: string, entries?: Partial<T>) {\n  this.inputName = createNoSpacesString(name);\n  if (entries) Object.assign(this, entries);\n}\n```\n",
  "/ReactFormMaker/FormFields/Class/Fieldset.class.ts": "import type {\n  DividerReactFormMaker,\n  FieldReactFormMaker,\n  ReactFormMakerFieldset,\n} from '../../interfaces/FieldInterfaces';\n\ntype includedField =\n  | FieldReactFormMaker\n  | DividerReactFormMaker\n  | ReactFormMakerFieldset\n  | includedField[];\n\n/**\n * **FieldSet class**: This class is used to create a fieldset in a form.\n *\n * ---\n * *This class helps to formalize and structure a configuration for using React Form Macker, with an abstraction layer that facilitates use.*\n *\n * ---\n *\n * * @example\n *\n * ```ts\n *\n * const login = new Field('login').text();\n * const password = new Field('password').password();\n *\n *\n * const fieldset = new FieldSet(\n *    'login', //name of the fieldset\n *    { // Simple configuration of the fieldset\n *      legend: 'Login',\n *      className: 'w-full flex flex-col gap-4',\n *      legendClassName: 'text-lg font-bold',\n *    },\n *    [login, password] // Fields of the fieldset\n * )\n *\n * ```\n *\n * ---\n * * @param formName - The name of the fieldset.\n * * @param entries - The configuration of the fieldset.\n * * @param fields - The fields of the fieldset.\n *\n * ---\n *\n * @Advanced\n *\n * *You can use a Fasted div on horizontal mode to create a divider between fields. The divider is a field that contains other fields. You can use it to group fields together.*\n *\n * ```ts\n *\n * const login = new Field('login').text();\n * const password = new Field('password').password();\n * const firstName = new Field('firstName').text();\n * const lastName = new Field('lastName').text();\n *\n * const fieldset = new FieldSet(\n *   'register', //name of the fieldset\n *  {},\n *  [ login, [ firstName, lastName ], password ] // Fields of the fieldset : lastName and firstName are grouped together in a divider in a horizontal mode\n *\n *\n */\nexport default class FieldSet<T extends Partial<ReactFormMakerFieldset>> {\n  fieldset: string = '';\n\n  legend?: string;\n\n  legendClassName?: string;\n\n  className?: string;\n\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n\n  isHide?: boolean;\n\n  constructor(formName: string, entries: T, fields: includedField[]) {\n    this.fieldset = formName;\n    if (entries) Object.assign(this, entries);\n    this.fields = fields.map((entry) => this.parseIncludedField(entry));\n  }\n\n  private parseIncludedField(\n    entries: includedField[] | includedField,\n  ): FieldReactFormMaker | DividerReactFormMaker | ReactFormMakerFieldset {\n    if (!Array.isArray(entries)) {\n      return entries;\n    }\n\n    const newDivider = {\n      isDiv: true,\n      className: 'w-full flex gap-4 justify-between',\n      fields: [],\n    } as DividerReactFormMaker;\n\n    entries.forEach((entry) => {\n      if (!entry) return;\n      newDivider.fields\n        ? newDivider.fields.push(this.parseIncludedField(entry))\n        : (newDivider.fields = [this.parseIncludedField(entry)]);\n    });\n\n    return newDivider;\n  }\n\n  public setConfig(config: Partial<T>): this {\n    Object.assign(this, config);\n    return this;\n  }\n\n  /**\n   * **Define the legend of the fieldset**\n   * @param legend\n   * @returns\n   */\n  public setLegend(legend: string): this {\n    this.legend = legend;\n    return this;\n  }\n\n  /**\n   * **Define the class of the legend**\n   * @param legendClassName\n   * @returns\n   */\n  public legendClass(legendClassName: string): this {\n    this.legendClassName = legendClassName;\n    return this;\n  }\n\n  /**\n   * **Define the class of the fieldset**\n   * @param className\n   * @returns\n   */\n  public class = (className: string): this => {\n    this.className = className;\n    return this;\n  };\n}\n",
  "/ReactFormMaker/FormFields/Class/TextFields.class.ts": "import { z } from 'zod';\nimport Field from './FieldFactory/FieldFactory.class';\nimport type { FieldReactFormMaker } from '../../interfaces/FieldInterfaces';\nimport type { FormFieldEvent } from '../../interfaces/FormFieldEvent';\n\nexport class TextField extends Field<FieldReactFormMaker> {\n  constructor(name: string, config?: Partial<FieldReactFormMaker>) {\n    super(name);\n\n    this.text();\n    if (config) {\n      const currentConfig = this.getConfig();\n      this.setConfig({ ...currentConfig, ...config });\n    }\n    return this;\n  }\n\n  useRegex(regex: RegExp): this {\n    if (!this.zodObject) {\n      console.warn('You must set a zod object before using this method');\n      return this;\n    }\n    this.zodObject = this.zodObject.refine((data: string) => regex.test(data), {\n      message: 'Invalid input',\n    });\n    return this;\n  }\n\n  isEmail(): this {\n    if (!this.zodObject) {\n      this.zodObject;\n    }\n    this.setPlaceholder('Email');\n    this.zodObject = z.string().email({\n      message: 'Invalid email',\n    });\n    return this;\n  }\n\n  isUrl(): this {\n    if (!this.zodObject) {\n      this.zodObject;\n    }\n\n    this.zodObject = z.string().url({\n      message: 'Invalid url',\n    });\n\n    this.onSelect = (e: FormFieldEvent) => {\n      if (!e.target.value) {\n        e.target.value = 'https://';\n      }\n    };\n    return this;\n  }\n\n  isPassword(): this {\n    this.password();\n    this.setPlaceholder('********');\n    return this;\n  }\n\n  /**\n   * Add a second fieldText to confirm the password.\n   *\n   * This method is used to create a password confirmation field.\n   *\n   * /!\\ You must call this method after calling `password()` to set the zodObject.\n   * @returns\n   */\n  confirmPassword(\n    config?: Partial<Omit<FieldReactFormMaker, 'inputName'>>,\n  ): Field<FieldReactFormMaker> {\n    if (!this.zodObject) {\n      this.zodObject;\n    }\n    if (!this.inputType || this.inputType !== 'password') {\n      throw new Error(\n        'You must call password() before calling confirmPassword()',\n      );\n    }\n\n    // this.Children(ConfirmPasswordField);\n\n    const initialPasswordField = this.getConfig();\n\n    /**\n     * config?: Partial<FieldReactFormMaker>\n     */\n    const defaultconfig: FieldReactFormMaker = {\n      inputName: 'confirmPassword',\n      className: 'form-input',\n      placeholder: '*********',\n      inputType: 'password',\n      zodObject: z.string(),\n    };\n\n    const newField = new Field('passwordWrapper', {\n      isDiv: true,\n      className: 'flex flex-col',\n      fields: [\n        initialPasswordField as FieldReactFormMaker,\n        {\n          ...defaultconfig,\n          ...config,\n        },\n      ],\n    });\n    return newField;\n  }\n}\n",
  "/ReactFormMaker/FormFields/formfields.class.ts": "export class FormFields {}\n",
  "/ReactFormMaker/hooks/useFormFieldsMap.tsx": "import React, { useCallback } from 'react';\nimport type {\n  ControllerRenderProps,\n  FieldValues,\n  Path,\n  UseFormReturn,\n} from 'react-hook-form';\nimport type {\n  CompositeField,\n  FieldReactFormMaker,\n} from '../interfaces/FieldInterfaces';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport {\n  isDividerReactFormMaker,\n  isFieldReactFormMaker,\n  isReactFormMakerFieldset,\n} from '../utils/typeGuards/compositeField.TypeGuards';\nimport DivElementField from '../formElements/DivElementField';\nimport FormFieldElement from '../formElements/FormFieldElement';\nimport InputComponent from '../formElements/InputComponent';\nimport { cn } from '@/lib/utils';\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\ninterface UseFormFieldsMapReturn<T extends FieldValues> {\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * A memoized callback function that renders the `InputComponent` with the provided field parameters.\n   */\n  InpuTComponentCallBack: ({\n    zFields,\n    fieldProps,\n    indexField,\n  }: FieldParams) => React.ReactElement<typeof InputComponent>;\n\n  /**\n   * **Generates an array of React elements or null based on the provided data fields.**\n   * - - -\n   * @param {CompositeField[]} dataField - An array of composite fields to be rendered.\n   * @returns {(React.JSX.Element | null)[]} An array of React elements or null.\n   *\n   * @callback FormFieldsMap\n   * - - -\n   * @example\n   * ``` javascript\n   * const fields = [\n   *   { type: 'divider', ... },\n   *   { type: 'field', ... }\n   * ];\n   * const renderedFields = FormFieldsMap(fields);\n   * ```\n   *  - - -\n   * @remarks\n   * - Uses `useState` to manage UUIDs for each field.\n   * - Uses `useEffect` to generate new UUIDs whenever `dataField` changes.\n   * - Renders different components based on the type of field.\n   * - Utilizes `isDividerReactFormMaker` and `isFieldReactFormMaker` to determine the type of field.\n   * - - -\n   * @see {@link uuidV4} for UUID generation.\n   * @see {@link DivElementField} for rendering divider elements.\n   * @see {@link FormFieldElement} for rendering form field elements.\n   */\n  FormFieldsMap: (dataField: CompositeField[]) => (React.ReactElement | null)[];\n\n  /**\n   * **Generates an array of Fieldset elements based on the provided form fields.**\n   * @param {CompositeField[]} formfields - An array of composite fields to be rendered.\n   * @returns {(React.JSX.Element | null)[]} An array of React elements or null.\n   *\n   * @callback FieldsetMap\n   * - - -\n   * @example\n   * ```typescript\n   * const fields = [\n   *   { type: 'fieldset', ... },\n   *   { type: 'fieldset', ... }\n   * ];\n   * const renderedFields = FieldsetMap(fields);\n   * ```\n   *  - - -\n   * @remarks\n   * - Uses `useState` to manage UUIDs for each field.\n   * - Uses `useEffect` to generate new UUIDs whenever `formfields` changes.\n   * - Renders different components based on the type of field.\n   * - Utilizes `isReactFormMakerFieldset` to determine the type of field.\n   * - - -\n   * @see {@link uuidV4} for UUID generation.\n   */\n  FieldsetMap: (\n    formfields: CompositeField[],\n  ) => (React.ReactElement<'fieldset'> | null)[];\n}\n\nexport function useFormFieldsMap<T extends FieldValues>( //@typescript-eslint/no-unused-vars\n  form: UseFormReturn<T>,\n): UseFormFieldsMapReturn<T> {\n  const InpuTComponentCallBack = useCallback(\n    ({\n      zFields,\n      fieldProps,\n      indexField,\n    }: FieldParams): React.ReactElement<typeof InputComponent> => (\n      <InputComponent\n        zFields={zFields as ControllerRenderProps<T, Path<T>>}\n        fieldProps={fieldProps}\n        indexField={indexField}\n      />\n    ),\n    [],\n  );\n\n  const FormFieldsMap = useCallback(\n    (dataField: CompositeField[]) => {\n      return dataField?.map((elementField: CompositeField, index) => {\n        if (isDividerReactFormMaker(elementField)) {\n          return (\n            <DivElementField\n              key={`divider-${index}`}\n              elementField={elementField}\n              FormFieldsMap={FormFieldsMap}\n            />\n          );\n        }\n        if (isFieldReactFormMaker(elementField)) {\n          return (\n            <div className=\"mb-4\" key={`form-field-${index}`}>\n              <FormFieldElement<T>\n                elementField={elementField}\n                index={`FormFieldElement${elementField.inputName}`}\n                form={form}\n                InpuTComponentCallBack={InpuTComponentCallBack}\n              />\n            </div>\n          );\n        }\n        return null;\n      });\n    },\n    [form],\n  );\n\n  const FieldsetMap = useCallback(\n    (\n      formfields: CompositeField[],\n    ): (React.ReactElement<'fieldset'> | null)[] => {\n      return formfields.map((element, index) => {\n        if (isReactFormMakerFieldset(element)) {\n          return (\n            <fieldset\n              key={`fieldset-${index}`}\n              className={cn({ hidden: element.isHide }, element.className)}\n            >\n              {element.legend && (\n                <legend\n                  key={`fieldset-legend-${index}`}\n                  className={cn(\n                    'text-lg font-bold pb-3',\n                    element.legendClassName,\n                  )}\n                >\n                  {element.legend}\n                </legend>\n              )}\n              {FormFieldsMap(element.fields as FieldReactFormMaker[])}\n            </fieldset>\n          );\n        }\n        return null;\n      });\n    },\n    [FormFieldsMap],\n  );\n\n  return { InpuTComponentCallBack, FormFieldsMap, FieldsetMap };\n}\n",
  "/ReactFormMaker/hooks/useFormHandlers.hook.ts": "// hooks/useFormHandlers.ts\nimport type {\n  SubmitHandler,\n  SubmitErrorHandler,\n  FieldErrors,\n  FieldValues,\n} from 'react-hook-form';\n\ninterface UserFormHandlerParams<T extends FieldValues> {\n  /**\n   * Function to be called when the form is submitted. This function will be called with the data or errors.\n   * @param data Represents the data of the form when the form is submitted.\n   * @param errors Represents the errors of the form when the form is submitted.\n   * @returns\n   */\n  onSubmit: (data: false | T, errors: false | FieldErrors<T>) => void;\n}\n\ninterface UseFormHandlersReturn<T extends FieldValues> {\n  /**\n   * Function to be called when the form is submitted.\n   * This is an abstraction to the `onSubmit` function provided by the user. Used with OnInvalid and OnValid, this twin function will call the user's `onSubmit` function with the data or errors.\n   * @param data\n   */\n  onValid: SubmitHandler<T>;\n  /**\n   * Function to be called when the form is submitted and has errors.\n   * @param errors\n   */\n  onInvalid: SubmitErrorHandler<T>;\n}\n\n/**\n * Custom hook that returns the `onValid` and `onInvalid` functions to be called when the form is submitted.\n * @param onSubmit - The function to be called when the form is submitted.\n * @returns\n */\nexport default function useFormHandlers<T extends FieldValues>({\n  onSubmit,\n}: UserFormHandlerParams<T>): UseFormHandlersReturn<T> {\n  const onValid: SubmitHandler<T> = (data: T) => {\n    onSubmit(data, false);\n  };\n\n  const onInvalid: SubmitErrorHandler<T> = (errors: FieldErrors<T>) => {\n    onSubmit(false, errors);\n  };\n\n  return { onValid, onInvalid };\n}\n",
  "/ReactFormMaker/hooks/useReactFormMaker.hook.ts": "'use client';\n/* eslint-disable import/no-named-as-default-member */\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport {\n  type FieldValues,\n  type DefaultValues,\n  type UseFormReturn,\n  useForm,\n} from 'react-hook-form';\nimport { z, type ZodType, ZodObject } from 'zod';\nimport React from 'react';\nimport type { CompositeField } from '../interfaces/FieldInterfaces';\nimport {\n  isDividerReactFormMaker,\n  isFieldReactFormMaker,\n  isReactFormMakerFieldset,\n} from '../utils/typeGuards/compositeField.TypeGuards';\n\ninterface UseFormGenReturn<T extends FieldValues> {\n  form: UseFormReturn<T>;\n  formSchema: ZodObject<{ [key in keyof T]: ZodType<T[key]> }>;\n  dataFieldsDefaultValues: { [key in keyof T]?: T[key] };\n  zObject: { [key in keyof T]: ZodType<T[key]> };\n  hasSubmitButton: (children: React.ReactNode) => boolean;\n}\n\nexport function useReactFormMaker<T extends FieldValues>(\n  formfieldsAttributes: CompositeField[],\n): UseFormGenReturn<T> {\n  const zObject: { [key in keyof T]: ZodType<T[key]> } = {} as {\n    [key in keyof T]: ZodType<T[key]>;\n  };\n  const dataFieldsDefaultValues: { [key in keyof T]?: T[key] } = {};\n\n  /**\n   * Recursively processes a field element and its nested fields, if any.\n   *\n   * @template T - The type of the form data.\n   * @param {FieldReactFormMaker} element - The field element to process.\n   *\n   * The function performs the following actions:\n   * - If the element contains nested fields, it iterates over each field.\n   * - For each nested field:\n   *   - If the field is a container (e.g., a div), it recursively calls `createField` on the field.\n   *   - If the field is not a container:\n   *     - If the field has a Zod schema object (`zodObject`), it adds it to the `zObject` map.\n   *     - If the field has default values (`defaultValues`), it adds them to the `dataFieldsDefaultValues` map.\n   */\n  function createField(element: CompositeField): void {\n    if (element.fields) {\n      const dataFields = element.fields;\n      if (dataFields && dataFields.length > 0) {\n        dataFields.forEach((field) => {\n          if (\n            isDividerReactFormMaker(field) ||\n            isReactFormMakerFieldset(field)\n          ) {\n            createField(field);\n          } else if (isFieldReactFormMaker(field)) {\n            if (field.zodObject !== undefined) {\n              zObject[field.inputName as keyof T] = field.zodObject as ZodType<\n                T[keyof T]\n              >;\n            }\n            if (field.defaultValues !== undefined) {\n              dataFieldsDefaultValues[field.inputName as keyof T] =\n                field.defaultValues as T[keyof T];\n            }\n          }\n        });\n      }\n    }\n  }\n\n  formfieldsAttributes.forEach((element: CompositeField) => {\n    createField(element);\n  });\n\n  let zodEffect: any; //eslint-disable-line @typescript-eslint/no-explicit-any\n  const formSchema = z.object(zObject);\n\n  if ('confirmPassword' in zObject && 'password' in zObject) {\n    // Typage plus prcis pour data\n    zodEffect = formSchema\n      .refine(\n        (data: Record<string, unknown>) =>\n          data.password === data.confirmPassword,\n        {\n          message: 'Les mots de passe ne correspondent pas',\n          path: ['confirmPassword'],\n        },\n      )\n      .transform(\n        ({ confirmPassword, ...rest }: Record<string, unknown>) => rest, //eslint-disable-line @typescript-eslint/no-unused-vars\n      );\n  }\n\n  const form = useForm<T>({\n    resolver: zodResolver(zodEffect || formSchema),\n    defaultValues: dataFieldsDefaultValues as DefaultValues<T>,\n    mode: 'all',\n  });\n\n  function hasSubmitButton(_childrenArg: React.ReactNode): boolean {\n    // Typage scuris pour child\n    return React.Children.toArray(_childrenArg).some(\n      (\n        child:\n          | string\n          | number\n          | bigint\n          | React.ReactElement<any, string | React.JSXElementConstructor<any>> //eslint-disable-line @typescript-eslint/no-explicit-any\n          | Iterable<React.ReactNode>\n          | React.ReactPortal\n          | Promise<React.AwaitedReactNode>,\n      ) => {\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n        if (React.isValidElement(child)) {\n          if ((child.props.type as string) === 'submit') {\n            return true;\n          }\n          if (child.props.children) {\n            return hasSubmitButton(child.props.children as React.ReactNode);\n          }\n        }\n        return false;\n      },\n      /** eslint-enable @typescript-eslint/no-unsafe-member-access */\n    );\n  }\n\n  return {\n    form,\n    formSchema,\n    dataFieldsDefaultValues,\n    zObject,\n    hasSubmitButton,\n  };\n}\n/* eslint-enable import/no-named-as-default-member */\n",
  "/ReactFormMaker/inputs/CheckboxInput.tsx": "import React from 'react';\nimport CheckboxWithText from '../enhancements/CheckboxWithText';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction CheckboxInput({\n  zFields,\n  fieldProps,\n  indexField,\n}: FieldParams): JSX.Element {\n  return (\n    <CheckboxWithText\n      zFields={zFields}\n      fieldProps={fieldProps}\n      indexField={indexField}\n    />\n  );\n}\n\nexport default React.memo(CheckboxInput);\n",
  "/ReactFormMaker/inputs/DateInput.tsx": "import React from 'react';\nimport DatePickerSimple from '../enhancements/DatePickerSimple';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction DateInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <DatePickerSimple\n      zFields={zFields}\n      fieldProps={fieldProps}\n      indexField={indexField}\n    />\n  );\n}\n\nexport default React.memo(DateInput);\n",
  "/ReactFormMaker/inputs/DateRangeInput.tsx": "import React from 'react';\nimport { DateRangePicker } from '../enhancements/DateRangePicker';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction DateRangeInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <DateRangePicker\n      zFields={zFields}\n      fieldProps={fieldProps}\n      indexField={indexField}\n    />\n  );\n}\n\nexport default React.memo(DateRangeInput);\n",
  "/ReactFormMaker/inputs/FileInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { Input } from '@/components/ui/input';\n\nfunction FileInput({ zFields, fieldProps, indexField }: FieldParams) {\n  const { onChange, ...restZfields } = zFields;\n  return (\n    <Input\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      type=\"file\"\n      placeholder={fieldProps.placeholder}\n      {...restZfields}\n      accept=\"image/*, application/pdf\"\n      onChange={(event) =>\n        onChange(event.target.files && event.target.files[0])\n      }\n    />\n  );\n}\n\nexport default React.memo(FileInput);\n",
  "/ReactFormMaker/inputs/FileUploaderInput.tsx": "import React from 'react';\nimport type { DropzoneOptions } from 'react-dropzone';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport DefaultFileUploader from '../enhancements/FileUploader/variants/DefaultFileUploader';\n\nfunction isFile(obj: any): boolean {\n  return (\n    obj instanceof File ||\n    Object.prototype.toString.call(obj) === '[object File]'\n  );\n}\n\nfunction FileDropZone({ zFields, fieldProps, indexField }: FieldParams) {\n  const { value, onChange, ...restZfields } = zFields;\n\n  const exempleInstanceOfFileExemple = new File([], 'exemple.txt', {\n    type: 'text/plain',\n  });\n\n  const dropzoneOptions: DropzoneOptions = {\n    disabled: fieldProps.disabled,\n  };\n\n  // Filtrer les proprits inexistantes\n  const filteredFieldProps = Object.fromEntries(\n    Object.entries(fieldProps).filter(([_, v]) => v !== undefined),\n  );\n\n  return (\n    <DefaultFileUploader\n      value={value}\n      onValueChange={onChange}\n      {...restZfields}\n      {...filteredFieldProps}\n      className={fieldProps.className}\n      dropzoneOptions={dropzoneOptions}\n    />\n  );\n}\n\nexport default React.memo(FileDropZone);\n",
  "/ReactFormMaker/inputs/MultiSelectInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\nimport {\n  type MultiSelectParams,\n  MultiSelect,\n} from '../enhancements/MultiSelect/MultiSelect';\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\ninterface MultiSelectInputProps\n  extends FieldParams,\n    Partial<MultiSelectParams> {}\n\nfunction MultiSelectInput({ zFields, fieldProps }: MultiSelectInputProps) {\n  const { value, onChange, ...restZfields } = zFields;\n\n  if (!fieldProps.options) {\n    return null;\n  }\n\n  const serializedOptions = fieldProps.options.map((option) => {\n    if (isOption(option)) {\n      return option;\n    }\n    return { value: option, label: option };\n  });\n\n  return (\n    <MultiSelect\n      id={fieldProps.inputName}\n      onChange={onChange}\n      {...restZfields}\n      defaultValues={value || fieldProps.defaultValues}\n      options={serializedOptions}\n    />\n  );\n}\n\nexport default React.memo(MultiSelectInput);\n",
  "/ReactFormMaker/inputs/NumberInput.tsx": "import React from 'react';\nimport { Input } from '@/components/ui/input';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction NumberInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <Input\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      type=\"number\"\n      placeholder={fieldProps.placeholder}\n      {...zFields}\n      value={\n        zFields.value !== undefined && zFields.value !== null\n          ? Number(zFields.value)\n          : ''\n      }\n    />\n  );\n}\n\nexport default React.memo(NumberInput);\n",
  "/ReactFormMaker/inputs/PasswordInput.tsx": "import React from 'react';\nimport InputPasswordVisibility from '../enhancements/InputPasswordVisibility';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction PasswordInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <InputPasswordVisibility\n      key={indexField}\n      zFields={zFields}\n      fieldProps={fieldProps}\n      indexField={indexField}\n    />\n  );\n}\n\nexport default React.memo(PasswordInput);\n",
  "/ReactFormMaker/inputs/PhoneNumberInput.tsx": "import React from 'react';\nimport PhoneInput from '../enhancements/PhoneInput';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction PhoneNumberInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <PhoneInput\n      id={fieldProps.inputName}\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      placeholder={fieldProps.placeholder}\n      {...zFields}\n    />\n  );\n}\n\nexport default React.memo(PhoneNumberInput);\n",
  "/ReactFormMaker/inputs/RadioInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport {\n  isOption,\n  type Option,\n  getValueOption,\n} from '../utils/typeGuards/optionsFields.TypeGuards';\n\nfunction RadioInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <RadioGroup\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      {...zFields}\n      onValueChange={zFields.onChange}\n    >\n      {fieldProps.options?.map((option: string | Option, index: number) => (\n        <div className=\"flex items-center space-x-2\" key={index}>\n          <RadioGroupItem\n            key={getValueOption(option)}\n            value={isOption(option) ? option.label : option}\n            id={isOption(option) ? option.label : option}\n          />\n          <Label htmlFor={isOption(option) ? option.label : option}>\n            {isOption(option) ? option.label : option}\n          </Label>\n        </div>\n      ))}\n    </RadioGroup>\n  );\n}\n\nexport default React.memo(RadioInput);\n",
  "/ReactFormMaker/inputs/SelectAutocompleteInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { SelectAutocomplete } from '../enhancements/SelectAutocomplete';\n\nfunction SelectAutocompleteInput({\n  zFields,\n  fieldProps,\n  indexField,\n}: FieldParams) {\n  const { value, onChange, ...restZfields } = zFields;\n  const { options } = fieldProps;\n  if (!options) {\n    throw new Error(\n      `SelectAutocompleteInput: options must be an array of Option objects, received ${JSON.stringify(options)}`,\n    );\n    return null;\n  }\n\n  return (\n    <SelectAutocomplete\n      id={fieldProps.inputName}\n      defaultValue={fieldProps.defaultValues}\n      options={options}\n      {...zFields}\n    />\n  );\n}\n\nexport default React.memo(SelectAutocompleteInput);\n",
  "/ReactFormMaker/inputs/SelectInput.tsx": "import React from 'react';\nimport SelectSimple from '../enhancements/SelectSimple';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction SelectInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <SelectSimple\n      zFields={zFields}\n      fieldProps={fieldProps}\n      indexField={indexField}\n      {...zFields}\n    />\n  );\n}\n\nexport default React.memo(SelectInput);\n",
  "/ReactFormMaker/inputs/SwitchInput.tsx": "import React from 'react';\nimport { Switch } from '@/components/ui/switch';\nimport { cn } from '../../../lib/utils';\nimport type { FieldParams } from '../interfaces/FieldParams';\n\nfunction SwitchInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <Switch\n      key={indexField}\n      disabled={fieldProps.disabled}\n      className={cn(fieldProps.className)}\n      {...zFields}\n      checked={Boolean(zFields.value)}\n      onCheckedChange={(checked: boolean) => {\n        zFields.onChange(checked);\n      }}\n    />\n  );\n}\n\nexport default React.memo(SwitchInput);\n",
  "/ReactFormMaker/inputs/TextareaInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { Textarea } from '@/components/ui/textarea';\n\nfunction TextareaInput({ zFields, fieldProps, indexField }: FieldParams) {\n  return (\n    <Textarea\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      placeholder={fieldProps.placeholder}\n      {...zFields}\n    />\n  );\n}\n\nexport default React.memo(TextareaInput);\n",
  "/ReactFormMaker/inputs/TextInput.tsx": "import React from 'react';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport { Input } from 'components/ui/input';\n\nfunction TextInput({ zFields, fieldProps, indexField }: FieldParams) {\n  /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */\n  const { value } = zFields;\n\n  if (value === undefined || value === null) {\n    zFields.value = '';\n  }\n  return (\n    <Input\n      id={fieldProps.inputName}\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      placeholder={fieldProps.placeholder}\n      {...zFields}\n    />\n  );\n}\n\nexport default React.memo(TextInput);\n",
  "/ReactFormMaker/inputs/TileMultiselectorInput.tsx": "import React from 'react';\nimport { z } from 'zod';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport type { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\nimport TileMultiSelector, {\n  type TileMultiSelectorProps,\n} from '../enhancements/TileSelector/TileMultiSelector';\n\ninterface TileMultiSelectorInputProps\n  extends FieldParams,\n    Partial<TileMultiSelectorProps> {}\n\nfunction TileMultiSelectorInput({\n  zFields,\n  fieldProps,\n  indexField,\n  ...restProps\n}: TileMultiSelectorInputProps) {\n  const { value, onChange, ...restZfields } = zFields;\n\n  if (!fieldProps.options) {\n    return null;\n  }\n  function valueExcludes(fieldProps: FieldReactFormMaker): string[] {\n    if (!fieldProps.options || !fieldProps.zodObject) {\n      return [];\n    }\n\n    const schema = fieldProps.zodObject;\n    let schemaValues: (string | number)[] = [];\n\n    if (schema instanceof z.ZodEnum) {\n      schemaValues = schema._def.values;\n    } else if (schema instanceof z.ZodUnion) {\n      schemaValues = schema._def.options.flatMap((option: any) =>\n        option instanceof z.ZodEnum ? option._def.values : [],\n      );\n    }\n\n    if (!schemaValues.length) {\n      return [];\n    }\n\n    return fieldProps.options.reduce<string[]>((acc, option) => {\n      const optionValue = isOption(option) ? option.label : option;\n      if (!schemaValues.includes(optionValue)) {\n        acc.push(optionValue);\n      }\n      return acc;\n    }, []);\n  }\n\n  return (\n    <TileMultiSelector\n      id={fieldProps.inputName}\n      onSelect={onChange}\n      onChange={onChange}\n      {...restZfields}\n      value={value}\n      defaultValue={fieldProps.defaultValues}\n      options={fieldProps.options}\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      legend={fieldProps.legend}\n      excludes={valueExcludes(fieldProps)}\n      {...restProps}\n    />\n  );\n}\n\nexport default React.memo(TileMultiSelectorInput);\n",
  "/ReactFormMaker/inputs/TileSelectorInput.tsx": "import React, { memo } from 'react';\nimport { z } from 'zod';\nimport type { FieldParams } from '../interfaces/FieldParams';\nimport type { FieldReactFormMaker } from '../interfaces/FieldInterfaces';\nimport TileSelector from '../enhancements/TileSelector/TileSelector';\nimport { isOption } from '../utils/typeGuards/optionsFields.TypeGuards';\n\nfunction TileSelectorInput({ zFields, fieldProps, indexField }: FieldParams) {\n  // Typage explicite pour viter l'unsafe destructuring\n  const { value, onChange, ...restZfields } = zFields as {\n    value: string | number;\n    onChange: (val: string | number) => void;\n    [key: string]: unknown;\n  };\n\n  function testhandlerOnChange(value: string | number) {\n    onChange(value);\n  }\n  if (!fieldProps.options) {\n    return null;\n  }\n  function valueExcludes(fieldProps: FieldReactFormMaker): string[] {\n    if (!fieldProps.options || !fieldProps.zodObject) {\n      return [];\n    }\n\n    const schema = fieldProps.zodObject;\n    let schemaValues: string[] = [];\n\n    if (schema instanceof z.ZodEnum) {\n      schemaValues = schema._def.values; // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n    } else if (schema instanceof z.ZodUnion) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      schemaValues = (schema._def.options as z.ZodEnum<any>[]).flatMap(\n        (option) =>\n          option instanceof z.ZodEnum ? (option._def.values as string[]) : [],\n      );\n    }\n\n    if (!schemaValues.length) {\n      return [];\n    }\n\n    return fieldProps.options.reduce<string[]>((acc, option) => {\n      const optionValue = isOption(option) ? option.label : option;\n      if (\n        !schemaValues.includes(\n          isOption(optionValue) ? optionValue.label : optionValue,\n        )\n      ) {\n        acc.push(isOption(optionValue) ? optionValue.label : optionValue);\n      }\n      return acc;\n    }, []);\n  }\n\n  return (\n    <TileSelector\n      id={fieldProps.inputName}\n      onClick={testhandlerOnChange}\n      {...restZfields}\n      value={String(value)}\n      defaultValue={String(fieldProps.defaultValues as string | number)}\n      options={fieldProps.options}\n      className={fieldProps.className}\n      disabled={fieldProps.disabled}\n      key={indexField}\n      legend={fieldProps.legend}\n      excludes={valueExcludes(fieldProps)}\n    />\n  );\n}\n\nexport default memo(TileSelectorInput);\n",
  "/ReactFormMaker/interfaces/CustomInputFieldElementParams.ts": "import type { ControllerRenderProps, FieldValues, Path } from 'react-hook-form';\nimport type { FieldReactFormMaker } from './FieldInterfaces';\n\nexport interface CustomInputFieldElementParams<T extends FieldValues> {\n  zFields?: ControllerRenderProps<T, Path<T>>;\n  fieldProps?: FieldReactFormMaker;\n  index?: string;\n  props?: T;\n}\n",
  "/ReactFormMaker/interfaces/ElementField.ts": "import type { FieldReactFormMaker } from './FieldInterfaces';\nimport type { FormFieldEvent } from './FormFieldEvent';\n\nexport interface ElementField extends FieldReactFormMaker {\n  fields?: any; //eslint-disable-line @typescript-eslint/no-explicit-any\n  field?: any; //eslint-disable-line @typescript-eslint/no-explicit-any\n  isDiv?: boolean;\n  isHide?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  props?: Record<string, any>; //eslint-disable-line @typescript-eslint/no-explicit-any\n  onBlur?: (event: FormFieldEvent) => void;\n  onFocus?: (event: FormFieldEvent) => void;\n  onChange?: (event: FormFieldEvent) => void;\n  onSelect?: (event: FormFieldEvent) => void;\n}\n",
  "/ReactFormMaker/interfaces/FieldInterfaces.ts": "import type { ZodType } from 'zod';\nimport type { UseFormReturn } from 'react-hook-form';\nimport type { FormFieldEvent } from './FormFieldEvent';\nimport type { StepFormState } from '../formElements/Stepper/SteppersElements/StepperContext.interface';\n\nexport type InputType =\n  | 'text'\n  | 'password'\n  | 'select'\n  | 'selectAutocomplete'\n  | 'multiSelect'\n  | 'textarea'\n  | 'date'\n  | 'dateRange'\n  | 'radio'\n  | 'checkbox'\n  | 'switch'\n  | 'file'\n  | 'fileDropZone'\n  | 'number'\n  | 'custom'\n  | 'tileSelector'\n  | 'tileMultiSelector'\n  | 'phoneNumber';\n\n/**\n * @description **This is the interface for the ReactFormMaker component.**\n * _CompositeField is the main state of a type on which all object-specific interfaces whose purpose is to contain specific fields._\n *\n * _The use of this state implies that the functionality used to route the rendering of form fields probably involves a recursive approach._\n *\n * ---\n *\n * @param {string} classname The className for styling the field. We use Tailwind CSS to style the field. This is optional.\n * @param { FieldReactFormMake[] | DividerReactFormMaker [] | ReactFormMakerFieldset[]} fields The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional, but recommended for the fieldset.\n * @param {boolean} isHide Hide the composite field. If isHide is true, the composite field will be hidden. You can use it to hide the composite field for security purposes and use it with hook to show it.\n */\nexport interface CompositeField {\n  /**\n   * @description\n   * The className for styling the field.\n   * We use Tailwind CSS to style the field.\n   * This is optional.\n   */\n  classname?: string;\n  /**\n   * @description\n   * The children of the input field.\n   * This is the children of the input field that will be displayed.\n   * You can use it to display the children components inside the input field.\n   * This is optional, but recommended for the fieldset.\n   */\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n  /**\n   * @description\n   * Hide the composite field. If isHide is true, the composite field will be hidden.\n   * You can use it to hide the composite field for security purposes and use it with hook to show it.\n   */\n  isHide?: boolean;\n}\n\n/**\n * @description\n * **This is an interface used in the ReactFormMaker component. **\n * _FieldReactFormMaker is the interface for form fields._\n *\n * ---\n *\n * ### Properties\n\n| Attribute                       | Type             | Required    | Description                                                                                                                                                  |\n|---------------------------------|------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `inputName`                     | `string`                                                                                 | Required    | *The name of the input field. This is the key of the object returned when the form is submitted.*                                                            |\n| `label`                         | `string`                                                                                 | Optional    | *The label of the input field, displayed above the input field for accessibility purposes.*                                                                  |\n| `placeholder`                   | `string`                                                                                 | Optional    | *The placeholder text displayed inside the input field when empty. Relevant for input types like text, password, textarea, date, and number.*                |\n| `inputType`                     | `string`                                                                                 | Required    | *The type of the input field to display.*                                                                                                                    |\n| `zodObject`                     | `ZodType<any>`                                                                           | Optional    | *The Zod object used to validate the input field. Recommended for type-safe validation. [More info](https://zod.dev/?id=primitives).*                        |\n| `defaultValues`                 | `any`                                                                                    | Optional    | *The default values displayed in the input field.*                                                                                                           |\n| `options`                       | `string[]` or `{ value: string; label: string }[]`                                       | Optional    | *Options for `select`, `radio`, or `checkbox` input types. Required if the input type is one of these.*                                                      |\n| `className`                     | `string`                                                                                 | Optional    | *The className for styling the input field using Tailwind CSS. [More info](https://tailwindcss.com/).*                                                        |\n| `disabled`                      | `boolean`                                                                                | Optional    | *Disables the input field when true.*                                                                                                                        |\n| `fields`                        | `(extended CompositeField)[]`              | Optional    | *Child components displayed within the input field.*                                                                                                         |\n| `isDiv`                         | `boolean`                                                                                | Optional    | *If true, renders the fieldset as a `<div>` instead of a semantic `<fieldset>`.*                                                                             |\n| `legend`                        | `string`                                                                                 | Optional    | *The legend of the input field displayed as the title of the fieldset.*                                                                                      |\n| `legendClassName`               | `string`                                                                                 | Optional    | *The className for styling the legend using Tailwind CSS.*                                                                                                   |\n| `description`                   | `string`                                                                                 | Optional    | *The description text displayed with the input field.*                                                                                                       |\n| `isSecure`                      | `boolean`                                                                                | Optional    | *Hides the input field for security purposes when true.*                                                                                                     |\n\n---\n\n### Events\n\n| Event               | Type                | Required    | Description                                                                                                                                                  |\n|---------------------|---------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `onBlur`            | `FormFieldEvent`   | Optional    | *Triggered on blur of the input field. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                     |\n| `onSelect`          | `FormFieldEvent`   | Optional    | *Triggered on focus of the input field. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                    |\n| `onChange`          | `FormFieldEvent`   | Optional    | *Triggered on input value change. Includes a `form` attribute of type `UseFormReturn<T>` for direct form control.*                                         |\n\n\n---\n\n### JSX Elements\n\n| Attribute                    | Type                | Required    | Description                                                                                                                                                  |\n|------------------------------|---------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `children`                   | `React.ReactNode`  | Optional    | *Child components displayed within the input field.*                                                                                                         |\n| `customInputFieldElement`    | `React.ReactNode`  | Optional    | *Custom ReactNode used to render the input field. Must be a valid input field element for use with the `ReactFormMaker` component.*                          |\n\n---\n\n### Other Props\n\n| Attribute      | Type                  | Required    | Description                                                                                                                                                  |\n|----------------|-----------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `props`        | `Record<string, any>`| Optional    | *Additional props passed to the input field.*                                                                                                               |\n\n * ---\n * @extends CompositeField\n * @see {@link CompositeField}\n */\nexport interface FieldReactFormMaker extends CompositeField {\n  /**\n   * @description\n   * The name of the input field, is required.\n   * This is the key of the object that will be returned when the form is submitted.\n   */\n  inputName: string;\n  /**\n   * @description\n   * The label of the input field.\n   * This is the text that will be displayed above the input field.\n   * It is directly related to the inputName and inputType for the accessibility of the form.\n   * This is optional.\n   */\n  label?: string;\n  /**\n   * @description\n   * The placeholder of the input field.\n   * This is the text that will be displayed inside the input field when it is empty.\n   * Kinds of inputType: text, password, textarea, date, number can have a placeholder.\n   * This is optional.\n   */\n  placeholder?: string;\n  /**\n   * @description\n   * The type of the input field.\n   * This is the type of the input field that will be displayed.\n   * This is required.\n   */\n  inputType: InputType;\n  /**\n   * @description\n   * The Zod object of the input field.\n   * This is the Zod object that will be used to validate the input field.\n   * This is optional but recommended.\n   * You can read more about Zod here: https://zod.dev/?id=primitives\n   * We use the Zod object to validate the input field and to return the object with the correct types.\n   * If you don't provide a Zod object, the input field will be validated with the default values.\n   */\n  zodObject?: ZodType;\n  /**\n   * @description\n   * The default values of the input field.\n   * This is the default value that will be displayed in the input field.\n   * This is optional.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  defaultValues?: any;\n  /**\n   * @description\n   * The options of the input field for the select, radio, and checkbox input types.\n   * If the inputType is select, radio, or checkbox, you need to provide the options.\n   * Will Be changed to options: string[] | { value: string; label: string }[]; in the future.\n   */\n  options?: string[] | { value: string | number; label: string }[];\n  /**\n   * @description\n   * The className of the input field.\n   * This is the className of the input field that will be displayed.\n   * We use Tailwind CSS to style the input field.\n   * If you want read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  className?: string;\n  /**\n   * @description\n   * **Disabled the input field.**\n   *\n   * This is the boolean that will be used to disable the input field.\n   *\n   * _This is optional._\n   */\n  disabled?: boolean;\n  /**\n   * @description\n   * The children of the input field.\n   * This is the children of the input field that will be displayed.\n   * You can use it to display the children components inside the input field.\n   * This is optional.\n   */\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n  /**\n   * @description\n   * This bollean is used to declare this fieldset as a div.\n   * If isDiv is true, the fieldset will be a div and have no semantic meaning.\n   * You can use it to group the fields in a div for styling purposes.\n   * This is optional.\n   */\n  isDiv?: boolean;\n  /**\n   * @description\n   * The legend of the input field.\n   * This is the legend of the fieldset that will be displayed.\n   * This is optional.\n   */\n  legend?: string;\n  /**\n   * @description\n   * The className for styling the fieldset.\n   * We use Tailwind CSS to style the fieldset.\n   * This is optional.\n   */\n  legendClassName?: string;\n  /**\n   * @description\n   * The description of the input field.\n   * This is the description of the input field that will be displayed.\n   * This is optional.\n   */\n  description?: string;\n  /**\n   * @description\n   * IsSecure is used to hide the input field.\n   * If isSecure is true, the input field will be hidden.\n   * You can use it to hide the input field for security purposes.\n   * This is optional.\n   */\n  isSecure?: boolean;\n  /**\n   * @description\n   * The onBlur event of the input field.\n   * This is the onBlur event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * This is optional.\n   */\n  onBlur?: (event: FormFieldEvent) => void;\n  /**\n   * @description\n   * The onFocus event of the input field.\n   * This is the onFocus event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * This is optional.\n   */\n  onSelect?: (event: FormFieldEvent) => void;\n  /**\n   * @description\n   * The onChange event of the input field.\n   * This is the onChange event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * This is optional.\n   * You can use it to trigger the onChange event of the input field.\n   */\n  onChange?: (event: FormFieldEvent) => void;\n\n  /**\n   * @description\n   *\n   * The onClick event of the input field.\n   * This is the onClick event of the input field that will be triggered.\n   * We add the attribute form of type UseFormReturn<any> to the event for controlling the form directly from the event.\n   * This is optional.\n   * You can use it to trigger the onClick event of the input field.\n   * @param event\n   * @returns\n   */\n  onClick?: (event: FormFieldEvent) => void;\n  /**\n   * @description\n   * This is way to add a custom component or Element to the field.\n   * If you want to add a custom component or Element to the field, you can use this prop.\n   * The Children will be displayed under the input field.\n   * This is optional.\n   */\n  children?: React.ReactNode;\n  /**\n   * @description\n   * The customInputFieldElement of the input field.\n   * This is the customInputFieldElement is a ReactNode that will be displayed.\n   * The difference between children and customInputFieldElement is that customInputFieldElement will be used by the ReactFormMaker component to display the input field.\n   * This Element must be a valid input field element for the ReactFormMaker component.\n   * This is optional.\n   */\n  customInputFieldElement?: React.ReactNode;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props?: Record<string, any>;\n}\n\n/**\n * @description\n * **This is the interface for the ReactFormMaker component.**\n * _DividerReactFormMaker is the interface for the divider in the form._\n *\n * ### Usage\n *\n * You can use this interface on an object that is part of your form's reading continuation. Its declaration allows the program to continue assigning zodObjects to the form. It also allows you to declare useful separations, so you can take control of the user interface and compose your form more freely.\n *\n * ### Properties\n *\n * @param {boolean} isDiv This bollean is used to declare this fieldset as a div. If isDiv is true, the fieldset will be a div and have no semantic meaning. You can use it to group the fields in a div for styling purposes. This is optional.\n * @param {string} className The className for styling the fieldset. We use Tailwind CSS to style the fieldset. This is optional.\n * @param {boolean} isHide Hide the fieldset. If isHide is true, the fieldset will be hidden. You can use it to hide the fieldset for security purposes and use it with hook to show it. This is optional.\n * @param {FieldReactFormMaker[] | DividerReactFormMaker[] | ReactFormMakerFieldset[]} fields The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional.\n *\n * ### JSX Elements\n *\n * @param {JSX.Element} children The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field.\n *  _This is optional._\n *\n * ---\n *\n * @extends CompositeField\n * @see {@link CompositeField}\n */\nexport interface DividerReactFormMaker extends CompositeField {\n  /**\n   * @description\n   * This bollean is used to declare this fieldset as a div.\n   * If isDiv is true, the fieldset will be a div and have no semantic meaning.\n   * You can use it to group the fields in a div for styling purposes.\n   */\n  isDiv: boolean;\n  /**\n   * @description\n   * The className for styling the fieldset.\n   * We use Tailwind CSS to style the fieldset.\n   * This is optional.\n   */\n  className?: string;\n  /**\n   * @description\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\n   * This is optional.\n   */\n  isHide?: boolean;\n  /**\n   * @description\n   * The legend of the input field.\n   * This is the legend of the fieldset that will be displayed.\n   * This is optional.\n   */\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n  /**\n   * @description\n   * The legend of the input field.\n   * This is the legend of the fieldset that will be displayed.\n   * This is optional.\n   */\n  children?: JSX.Element;\n}\n\n/**\n * @description\n * This is the interface for the ReactFormMaker component.\n * ReactFormMakerFieldset is the interface for the fieldset in the form.\n * We need to use it in the ReactFormMakerParams interface to define the fieldset of the form.\n * The ReactFormMakerParams interface is used to define the props of the ReactFormMaker component.\n * Is a recursive interface that can have children fields.\n *\n * ---\n *\n * ## Properties\n *\n * ### Usage\n * \n * | Attribute           | Type                                                                                                                                         | Required    | Description                                                                                                   |\n|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------|-------------|---------------------------------------------------------------------------------------------------------------|\n| `fieldset`          | `string`                                                                                                                                     | Required    | *The fieldset of the form. This is the fieldset of the form that will be displayed.*                          |\n| `legend`            | `string`                                                                                                                                     | Optional    | *The legend of the input field. This is the title of the fieldset that will be displayed.*                    |\n| `legendClassName`   | `string`                                                                                                                                     | Optional    | *The className for styling the legend, using Tailwind CSS. [More info](https://tailwindcss.com/).*            |\n| `className`         | `string`                                                                                                                                     | Optional    | *The className for styling the fieldset, using Tailwind CSS. [More info](https://tailwindcss.com/).*          |\n| `description`       | `string`                                                                                                                                     | Optional    | *The description of the input field that will be displayed.*                                                 |\n| `fields`            | (`FieldReactFormMaker` or `DividerReactFormMaker` or `ReactFormMakerFieldset`)[]                                                                 | Optional    | *The fields of the form that will be displayed.*                                                             |\n| `isHide`            | `boolean`                                                                                                                                    | Optional    | *Hides the fieldset. If true, the fieldset will be hidden, useful for security purposes when combined with hooks.* |\n * \n * ---\n * \n * @extends CompositeField\n * @see {@link CompositeField} For more information about the CompositeField interface.\n * \n * ---\n * \n * @see {@link FieldReactFormMaker} \n * @see {@link DividerReactFormMaker}\n * @see {@link ReactFormMakerStep}\n */\nexport interface ReactFormMakerFieldset extends CompositeField {\n  /**\n   * @description\n   * The fieldset of the form.\n   * This is the fieldset of the form that will be displayed.\n   * This is required.\n   */\n  fieldset: string;\n  /**\n   * @description\n   * The legend of the input field.\n   * This is the legend of the fieldset that will be displayed.\n   * This is optional.\n   * You can use it to display the legend of the fieldset.\n   * The legend is the title of the fieldset.\n   */\n  legend?: string;\n  /**\n   * @description\n   * The className for styling the legend.\n   * We use Tailwind CSS to style the legend.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  legendClassName?: string;\n  /**\n   * @description\n   * The className for styling the fieldset.\n   * We use Tailwind CSS to style the fieldset.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  className?: string;\n  /**\n   * @description\n   * The description of the input field.\n   * This is the description of the input field that will be displayed.\n   * This is optional.\n   */\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n  /**\n   * @description\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\n   * This is optional.\n   */\n  isHide?: boolean;\n}\n\n/**\n * @description **This is the interface for the ReactFormMaker component.**\n * ReactFormMakerStep is the interface for the steps in the form. We need to use it in the ReactFormMakerParams interface to define the steps of the form.\n *\n * ---\n *\n * ### Properties\n *\n * @param {string} stepName The stepName of the form. This is the stepName of the form that will be displayed. This is required.\n * @param {boolean} isStep Define the fieldset as a step of Stepper. If isStep is true, the fieldset will be a step of Stepper.\n * @param {string} legend The legend of the input field. This is the legend of the fieldset that will be displayed. This is optional. You can use it to display the legend of the fieldset. The legend is the title of the fieldset.\n * @param {string} legendClassName The className for styling the legend. We use Tailwind CSS to style the legend. If you want to read more about Tailwind CSS here: https://tailwindcss.com/ This is optional.\n * @param {string} className The className for styling the fieldset. We use Tailwind CSS to style the fieldset. If you want to read more about Tailwind CSS here: https://tailwindcss.com/ This is optional.\n * @param {string} description The description of the input field. This is the description of the input field that will be displayed. This is optional.\n * @param {FieldReactFormMaker[]} fields The fields of the form. This is the fields of the form that will be displayed. This is optional. You can use it to display the fields of the form.\n * @param {boolean} isHide Hide the fieldset. If isHide is true, the fieldset will be hidden. You can use it to hide the fieldset for security purposes and use it with hook to show it. This is optional.\n * @param {boolean} disabledBefore disabledBefore is used to define if button before the current step is disabled. If disabledBefore is true, the button before the current step is disabled and cannot be clicked. disabledBefore disabled possibility to go back to any previous step in the stepper header and the stepper footer. False by default. This is optional.\n * @param {boolean} isStrict IsStrict is used to define if the step is strict. If isStrict is true, the step will be strict and the user cannot go to the next step without filling the current step. If any validation of zod is invalid, the user cannot go to the next step. False by default. This is optional.\n *\n * ### Events\n *\n * ### JSX Elements\n *\n * @param {React.ReactNode} children The children of the input field. This is the children of the input field that will be displayed. You can use it to display the children components inside the input field. This is optional.\n *\n * ---\n *\n * @extends CompositeField\n * @see {@link CompositeField}\n */\nexport interface ReactFormMakerStep extends CompositeField {\n  /**\n   * @description\n   * The stepName of the form.\n   * This is the stepName of the form that will be displayed.\n   * This is required.\n   */\n  stepName: string;\n  /**\n   * @description\n   * isStep Define the fieldset as a step of Stepper.\n   * If isStep is true, the fieldset will be a step of Stepper.\n   */\n  isStep?: boolean;\n  /**\n   * @description\n   * The legend of the input field.\n   * This is the legend of the fieldset that will be displayed.\n   * This is optional.\n   * You can use it to display the legend of the fieldset.\n   * The legend is the title of the fieldset.\n   */\n  legend?: string;\n  /**\n   * @description\n   * The className for styling the legend.\n   * We use Tailwind CSS to style the legend.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  legendClassName?: string;\n  /**\n   * @description\n   * The className for styling the fieldset.\n   * We use Tailwind CSS to style the fieldset.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  className?: string;\n  /**\n   * @description\n   * The description of the input field.\n   * This is the description of the input field that will be displayed.\n   * This is optional.\n   */\n  fields?: (\n    | FieldReactFormMaker\n    | DividerReactFormMaker\n    | ReactFormMakerFieldset\n  )[];\n  /**\n   * @description\n   * Hide the fieldset. If isHide is true, the fieldset will be hidden.\n   * You can use it to hide the fieldset for security purposes and use it with hook to show it.\n   * This is optional.\n   */\n  isHide?: boolean;\n\n  /**\n   * @description\n   * The children of the input field.\n   * This is the children of the input field that will be displayed.\n   * You can use it to display the children components inside the input field.\n   * This is optional.\n   */\n  children?: React.ReactNode;\n\n  /**\n   * @description\n   * disabledBefore is used to define if button before the current step is disabled.\n   * If disabledBefore is true, the button before the current step is disabled and cannot be clicked.\n   * disabledBefore disabled possibility to go back to any previous step in the stepper header and the stepper footer.\n   * False by default.\n   */\n  disabledBefore?: boolean;\n\n  /**\n   * @description\n   * IsStrict is used to define if the step is strict.\n   * If isStrict is true, the step will be strict and the user cannot go to the next step without filling the current step.\n   * If any validation of zod is invalid, the user cannot go to the next step.\n   * False by default.\n   * This is optional.\n   */\n  isStrict?: boolean;\n\n  /**\n   * @description\n   * onBeforeNextStep is used to define a function that will be executed before switching to the next step.\n   * This is optional.\n   * This function will be executed before switching to the next step and after the triggering of validation form when step is the current step.\n   *\n   * @param data The data of the form.\n   * @returns Promise<boolean> if true, the user can switch to the next step, if false, the user cannot switch to the next step.\n   */\n  onBeforeNextStep?: (data: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    submissionState: StepFormState<any>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    form: UseFormReturn<any>;\n  }) => Promise<boolean>;\n\n  /**\n   * @description\n   * **Componenent for Icon of the step.**\n   *\n   * If IconStep is not provided, the step will have defaults icons depending on the step status.\n   * This is optional.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  IconStep?: React.ComponentType<any>;\n\n  /**\n   * @description\n   * change name of the button next\n   * this is optional\n   */\n  buttonNextContent?: string;\n\n  /**\n   * @description\n   * change name of the button previous\n   * tjhis is optional\n   */\n  buttonPreviousContent?: string;\n\n  /**\n   * @description\n   * **Add additional buttons to the step.**\n   * This is optional.\n   *\n   * This element jsx erith the context of the step.\n   * We can use it to add additional buttons to the step.\n   * This button will be displayed in the footer of the step after the button next and the button previous.\n   *\n   */\n  additionalButtons?: React.ReactNode;\n\n  /**\n   * @description\n   * **Add additionclassname stepper footer.**\n   * This is optional.\n   */\n  footerClassName?: string | string[];\n}\n",
  "/ReactFormMaker/interfaces/FieldParams.ts": "import type { ClassValue } from 'clsx';\nimport type { ControllerRenderProps, Path } from 'react-hook-form';\nimport type { FieldReactFormMaker } from './FieldInterfaces';\n\n/**\n * @description\n * This is the interface for the ReactFormMaker component.\n * FieldParams is the interface for the props of the Field component.\n * We need to use it in the Field component to define the props of the Field component under the ReactFormMaker component.\n *\n * ### Attributes\n *\n * | Name     | isRequired | Type | Description |\n * |----------|------------|------|-------------|\n * | zFields  | true       | ControllerRenderProps<any, Path<any>> | The register of the input field. |\n * | fieldProps | true     | FieldReactFormMaker | The fieldProps of the input field. |\n * | indexField | true     | string | The indexField of the input field. |\n * | id | false          | string | id of the input field. |\n * | className | false    | ClassValue[] \\| string \\| undefined | This is the custom className of the input field that will be displayed. |\n *\n * ---\n *\n * #### Info about the attributes\n *\n * @see {@link ControllerRenderProps} for more details.\n * @see {@link FieldReactFormMaker} for more details.\n *\n * ##### ControllerRenderProps\n *\n * | Name     | isRequired | Type | Description |\n * |----------|------------|------|-------------|\n * | onChange | true       | (...event: any[]) => void | The onChange event of the input field. |\n * | onBlur   | true       | Noop | The onBlur event of the input field. |\n * | value    | true       | FieldPathValue<TFieldValues, TName> | The value of the input field. |\n * | disabled | false      | boolean | The disabled attribute of the input field. |\n * | name     | true       | TName | The name of the input field. |\n * | ref      | true       | RefCallBack | The ref of the input field. |\n *\n */\nexport interface FieldParams {\n  /**\n   * @description\n   * The register of the input field.\n   * This is the register of the input field that will be displayed.\n   * Is a representation of the input field in the form and interprets the input field of zodObject.\n   */\n  zFields: ControllerRenderProps<any, Path<any>>; // eslint-disable-line @typescript-eslint/no-explicit-any\n  /**\n   * @description\n   * The fieldProps of the input field.\n   * This is the fieldProps of the field, which is the FieldReactFormMaker interface.\n   * We need to use it in the Field component to define the props of the Field component under the ReactFormMaker component.\n   * This is required.\n   */\n  fieldProps: FieldReactFormMaker;\n  /**\n   * @description\n   * The indexField of the input field.\n   * This is the indexField of the input field that will be displayed.\n   * This is required.\n   */\n  indexField: string;\n  /**\n   * @description\n   * id of the input field.\n   * Can be used to identify the input field. If not provided, the id will be generated automatically by the system.\n   */\n  id?: string;\n  /**\n   * @description\n   * This is the custom className of the input field that will be displayed.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  className?: ClassValue[] | string | undefined;\n}\n",
  "/ReactFormMaker/interfaces/FormFieldEvent.ts": "import type {\n  ControllerRenderProps,\n  FieldValues,\n  Path,\n  UseFormReturn,\n} from 'react-hook-form';\n\n/**\n * @description\n * This is the interface for the ReactFormMaker component.\n * FormFieldEvent is the interface for the custom event of the input field.\n * FormFieldEnvent add the controlField and form attributes to the React.FocusEvent<HTMLInputElement> interface.\n * Also, we add form attribute to the React.FocusEvent<HTMLInputElement> interface to control the form directly from the event.\n */\nexport interface FormFieldEvent<T extends FieldValues = FieldValues>\n  extends React.FocusEvent<HTMLInputElement> {\n  controlField?: ControllerRenderProps<T, Path<T>>;\n  form?: UseFormReturn<T>;\n}\n",
  "/ReactFormMaker/interfaces/FormParams.ts": "import type { FieldErrors, FieldValues } from 'react-hook-form';\nimport type { CompositeField } from './FieldInterfaces';\n\n/**\n * @description\n * This is the interface for the ReactFormMaker component.\n * ReactFormMakerParams is the interface for the props of the ReactFormMaker component.\n */\nexport interface ReactFormMakerParams<T extends FieldValues> {\n  /**\n   * @description\n   * The fieldset of the form.\n   * This is the fieldset of the form that will be displayed.\n   * This is required.\n   */\n  formfields: CompositeField[];\n  /**\n   * @description\n   * The className for styling the form.\n   * We use Tailwind CSS to style the form.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  className?: string;\n  /**\n   * @description\n   * The className for styling the footer.\n   * We use Tailwind CSS to style the footer.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  footerClassName?: string;\n  /**\n   * @description\n   * The text of the submit button.\n   * This is the text of the submit button that will be displayed.\n   * This is optional.\n   */\n  btnTextSubmit?: string;\n  /**\n   * @description\n   * The className for styling the submit button.\n   * We use Tailwind CSS to style the submit button.\n   * If you want to read more about Tailwind CSS here: https://tailwindcss.com/\n   * This is optional.\n   */\n  btnSubmitClassName?: string;\n\n  /**\n   * @description\n   * The onSubmit event of the form.\n   * This is the onSubmit event of the form that will be triggered.\n   * We add the attribute data of type FormEvent<HTMLFormElement> to the event for controlling the form directly from the event.\n   * This is required.\n   * @param data\n   * @returns void\n   */\n  onSubmit: (data: T | false, errors: FieldErrors<T> | false) => void;\n\n  /**\n   * @description\n   * The children of the form.\n   * This is the children of the form that will be displayed.\n   * You can use it to display the children components inside the form.\n   * This is optional.\n   */\n  children?: React.ReactNode;\n  /**\n   * @description\n   * The setZodObject event of the form.\n   * This is the setZodObject event of the form that will be triggered.\n   * We add the attribute zObject of type { [key: string]: ZodType<any> } to the event for controlling the form directly from the event.\n   * You can just use Hook like useState<{ [key: string]: ZodType<unknown> }>({}); to get the Zod object. The System will set the Zod object to the state automatically.\n   * This is optional.\n   * @param zObject\n   * @returns void\n   * deprecated\n   */\n  // setZodObject?: (zObject: { [key in keyof T]: ZodType<T[key]> }) => void;\n\n  /**\n   * @description\n   * Stepper boolean value determines if the form will be displayed as a stepper.\n   * By default, the stepper is set to false.\n   * This is optional.\n   */\n  stepper?: boolean;\n\n  /**\n   * @description\n   * The orientation of the form, used when the stepper is set to true.\n   * This is the orientation of the form that will be displayed.\n   * This is optional.\n   */\n  orientation?: 'vertical' | 'horizontal';\n}\n",
  "/ReactFormMaker/ReactFormMaker.tsx": "'use client';\n\nimport type { FieldValues } from 'react-hook-form';\nimport { Slottable } from '@radix-ui/react-slot';\nimport React, { useCallback } from 'react';\nimport type { ReactFormMakerParams } from './interfaces/FormParams';\nimport { Button } from '@/components/ui/button';\nimport { Form } from '@/components/ui/form';\nimport { cn } from '@/lib/utils';\nimport mapChildrenWithForm from './formElements/mapChildrenWithForm';\nimport validateStepperFormFields from './utils/validators/formValidators';\nimport useFormHandlers from './hooks/useFormHandlers.hook';\nimport { useReactFormMaker } from './hooks/useReactFormMaker.hook';\nimport { useFormFieldsMap } from './hooks/useFormFieldsMap';\nimport StepperForm from './formElements/Stepper/StepperForm.componenent';\n\n/**\n * A React component for dynamically generating forms using a set of field definitions.\n * Supports both standard and stepper-based forms with customizable layouts and behaviors.\n *\n * @template T - A generic type extending `FieldValues` from React Hook Form.\n *\n * @param {ReactFormMakerParams<T>} props - The props for the ReactFormMaker component.\n * @param {FormField<T>[]} props.formfields - An array of form field definitions used to generate the form.\n * @param {string} [props.className] - Optional CSS class for the form container.\n * @param {string} [props.footerClassName='flex justify-end gap-4'] - Optional CSS class for the footer section.\n * @param {(data: T) => void} props.onSubmit - Callback function triggered on form submission with valid data.\n * @param {React.ReactNode} [props.children] - Optional children to be rendered inside the form.\n * @param {string} [props.btnTextSubmit='Submit'] - Text for the submit button.\n * @param {string} [props.btnSubmitClassName] - Optional CSS class for the submit button.\n * @param {boolean} [props.stepper=false] - Whether to render the form as a stepper.\n * @param {'horizontal' | 'vertical'} [props.orientation='horizontal'] - Orientation of the stepper form. Used only if `stepper` is true.\n *\n * @returns {JSX.Element} The rendered form component.\n *\n * @example\n * ```tsx\n * const formfields = [\n *   { name: 'username', type: 'text', label: 'Username', validation: { required: true } },\n *   { name: 'password', type: 'password', label: 'Password', validation: { required: true } },\n * ];\n *\n * function handleSubmit(data: FieldValues) {\n *   console.log(data);\n * }\n *\n * <ReactFormMaker\n *   formfields={formfields}\n *   onSubmit={handleSubmit}\n *   className=\"custom-form\"\n *   btnTextSubmit=\"Login\"\n * />\n * ```\n */\nexport default function ReactFormMaker<T extends FieldValues>({\n  formfields,\n  className,\n  footerClassName = 'flex justify-end gap-4',\n  onSubmit,\n  // setZodObject, deprecated\n  children,\n  btnTextSubmit = 'Submit',\n  btnSubmitClassName,\n  stepper = false,\n  orientation = 'horizontal',\n}: ReactFormMakerParams<T>) {\n  const { form, zObject, hasSubmitButton } = useReactFormMaker<T>(formfields);\n  const { onValid, onInvalid } = useFormHandlers<T>({ onSubmit });\n  const { FormFieldsMap, FieldsetMap } = useFormFieldsMap<T>(form);\n  const mappedChildren = useCallback(\n    () => mapChildrenWithForm(children, form),\n    [children, form],\n  );\n  /** STEPPER FORM */\n  if (stepper) {\n    validateStepperFormFields(formfields, stepper);\n\n    return (\n      <Form {...form}>\n        <form\n          // eslint-disable-next-line @typescript-eslint/no-misused-promises\n          onSubmit={form.handleSubmit(onValid, onInvalid)}\n          className={cn(\n            ' flex flex-col gap-4 p-4 rounded-lg shadow-lg mx-auto mt-4 bg-white w-5/6 h-full min-h-80 overflow-hidden',\n            className,\n          )}\n        >\n          <StepperForm<T>\n            form={form}\n            formfields={formfields}\n            zObject={zObject}\n            orientation={orientation}\n            formFieldsMap={FormFieldsMap}\n          />\n        </form>\n      </Form>\n    );\n  }\n\n  return (\n    <Form {...form}>\n      <form\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSubmit={form.handleSubmit(onValid, onInvalid)}\n        className={className}\n      >\n        {FieldsetMap(formfields)}\n\n        <footer className={footerClassName}>\n          <Slottable>{mappedChildren()}</Slottable>\n          {!hasSubmitButton(children) && (\n            <Button type=\"submit\" className={btnSubmitClassName}>\n              {btnTextSubmit}\n            </Button>\n          )}\n        </footer>\n      </form>\n    </Form>\n  );\n}\n",
  "/ReactFormMaker/utils/typeGuards/compositeField.TypeGuards.ts": "import type {\n  CompositeField,\n  DividerReactFormMaker,\n  FieldReactFormMaker,\n  ReactFormMakerFieldset,\n  ReactFormMakerStep,\n} from '../../interfaces/FieldInterfaces';\n\nexport function isCompositeField(element: unknown): element is CompositeField {\n  return (element as CompositeField).fields !== undefined;\n}\n\n/**\n * **Type guard function to check if a given element is of type `FieldReactFormMaker`.**\n * - - -\n * @param element - The element to check.\n * @returns {boolean} A boolean indicating whether the element is a `FieldReactFormMaker`.\n * is defined by the presence of the `inputName` property.\n */\nexport function isFieldReactFormMaker(\n  element: CompositeField,\n): element is FieldReactFormMaker {\n  return (element as FieldReactFormMaker).inputName !== undefined;\n}\n\n/**\n *  **Type guard function to check if a given element is of type `DividerReactFormMaker`.**\n * is defined by the presence of the `isDiv` property.\n * - - -\n * @param element - The element to check.\n * @returns {boolean} A boolean indicating whether the element is a `DividerReactFormMaker`.\n *\n */\nexport function isDividerReactFormMaker(\n  element: CompositeField,\n): element is DividerReactFormMaker {\n  return (element as DividerReactFormMaker).isDiv !== undefined;\n}\n\n/**\n *  **Type guard function to check if a given element is of type `ReactFormMakerFieldset`.**\n *  Is defined by the presence of the `fieldset` property.\n * - - -\n * @param element  - The element to check.\n * @returns {boolean} A boolean indicating whether the element is a `ReactFormMakerFieldset`.\n */\nexport function isReactFormMakerFieldset(\n  element: CompositeField,\n): element is ReactFormMakerFieldset {\n  return (element as ReactFormMakerFieldset).fieldset !== undefined;\n}\n\n/**\n *  ** Type guard function to check if a given element is of type `ReactFormMakerStep`.**\n *  Is defined by the presence of the `isStep` or `stepName` property.\n * - - -\n * @param element - The element to check.\n * @returns {boolean} A boolean indicating whether the element is a `ReactFormMakerStep`.\n */\nexport function isStepReactFormMaker(\n  element: CompositeField,\n): element is ReactFormMakerStep {\n  return (\n    (element as ReactFormMakerStep).isStep !== undefined ||\n    (element as ReactFormMakerStep).stepName !== undefined\n  );\n}\n",
  "/ReactFormMaker/utils/typeGuards/optionsFields.TypeGuards.ts": "export interface Option {\n  value: string | number;\n  label: string;\n}\n\n/**\n * **Type guard function to check if one option are of type `Option` or `string`.**\n * - - -\n * @param element - The element to check.\n * @returns {boolean} A boolean indicating whether the element is a `Option` type.\n * _is defined by the presence of the `value` property._\n */\nexport function isOption(element: string | Option): element is Option {\n  return (element as Option).value !== undefined;\n}\n\n/**\n * **Function to extract the value from an option.**\n * - - -\n * @param option - The option to extract the value from.\n * @returns {string | number} The value of the option.\n * _If the option is a string, it returns the string itself._\n */\nexport function getValueOption(option: string | Option) {\n  return isOption(option) ? option.value : option;\n}\n\nexport function isOptionsArray(\n  options: (string | Option)[] | undefined,\n): options is Option[] {\n  return Array.isArray(options) && options.every((option) => isOption(option));\n}\n\n/**\n * **Type guard function to check if all options are of type `Option` and not `string`.**\n * - - -\n * _This function is used when componenent needs to ensure that all options are of type `Option`._\n * @param options\n * @returns {Option[]} An array of options.\n */\nexport function mustBeArrayOfOptions(\n  options: (string | Option)[] | undefined,\n): Option[] {\n  if (!options) {\n    return [];\n  }\n  return options.filter(isOption);\n}\n",
  "/ReactFormMaker/utils/validators/dateValidators.ts": "export interface SimpleDurationValues {\n  days?: number;\n  weeks?: number;\n  months?: number;\n  years?: number;\n}\n\n/**\n * **isOlderThan**\n * Vrifie si la date de naissance est antrieure  une date calcule en soustrayant un certain nombre d'annes, de mois et de jours de la date actuelle.\n *\n * @param {Date} birthDate - La date de naissance sous forme d'objet Date.\n * @param {SimpleDurationValues} comparisonDate - La diffrence en annes, mois et jours.\n * @returns {boolean} `true` si la date de naissance est antrieure  la date calcule, `false` sinon.\n *\n * ---\n *\n * #### Exemple\n *\n * ##### Utilisation simple\n *\n * ```typescript\n * const birthDate = new Date('1990-01-01');\n * const comparisonDate = { years: 18 };\n * const isAdult = isOlderThan(birthDate, comparisonDate);\n * console.log(isAdult); // retourn true\n * ```\n *\n * ##### Autre Exemple d'utilisation\n *\n * ```typescript\n * // On verfie si la date est suprieure  1 an et 6 mois\n * const birthDate = new Date('2024-01-01');\n * const comparisonDate = { years: 1, months: 6 };\n * const isOlder = isOlderThan(birthDate, comparisonDate);\n * console.log(isOlder); // retourne true\n *\n * // ou aussi\n * const secondComparisonDate = { months: 18 };\n * const isOlder = isOlderThan(birthDate, secondComparisonDate);\n * console.log(isOlder); // retourne true\n * ```\n */\nconst isOlderThan = (\n  birthDate: Date,\n  comparisonDate: SimpleDurationValues,\n): boolean => {\n  const now = new Date();\n  const comparison = new Date(\n    now.getFullYear() - (comparisonDate.years || 0),\n    now.getMonth() - (comparisonDate.months || 0),\n    now.getDate() - (comparisonDate.days || 0),\n  );\n  if (comparisonDate.weeks) {\n    comparison.setDate(comparison.getDate() - comparisonDate.weeks * 7);\n  }\n  return birthDate.getTime() < comparison.getTime();\n};\n\nconst islaterThan = (\n  birthDate: Date,\n  comparisonDate: SimpleDurationValues,\n): boolean => {\n  const now = new Date();\n  const comparison = new Date(\n    now.getFullYear() + (comparisonDate.years || 0),\n    now.getMonth() + (comparisonDate.months || 0),\n    now.getDate() + (comparisonDate.days || 0),\n  );\n  if (comparisonDate.weeks) {\n    comparison.setDate(comparison.getDate() + comparisonDate.weeks * 7);\n  }\n  return birthDate.getTime() > comparison.getTime();\n};\n\nconst isBetween = (\n  from: Date,\n  to: Date,\n  comparisonDate: SimpleDurationValues,\n): boolean => {\n  const comparison = new Date(\n    from.getFullYear() + (comparisonDate.years || 0),\n    from.getMonth() + (comparisonDate.months || 0),\n    from.getDate() + (comparisonDate.days || 0),\n  );\n  if (comparisonDate.weeks) {\n    comparison.setDate(comparison.getDate() + comparisonDate.weeks * 7);\n  }\n  return to.getTime() > comparison.getTime();\n};\n\nexport { isOlderThan, islaterThan, isBetween };\n",
  "/ReactFormMaker/utils/validators/formValidators.ts": "import type { CompositeField } from '../../interfaces/FieldInterfaces';\nimport { isStepReactFormMaker } from '../typeGuards/compositeField.TypeGuards';\n\n/**\n * **Validate Stepper Form Fields**\n * Rule :\n *  - Warn if the form contains only one step.\n *  - Error if the form contains no step.\n * - - -\n * @param formfields - Les champs de formulaire  valider.\n * @param stepper - Le boolean indiquant si le formulaire utilise un stepper.\n * @returns Vrai si la validation passe, sinon une erreur ou un avertissement est lanc.\n */\nexport default function validateStepperFormFields(\n  formfields: CompositeField[],\n  stepper: boolean,\n): void {\n  if (stepper) {\n    const stepFields = formfields.filter(isStepReactFormMaker);\n    if (stepFields.length < 1) {\n      throw new Error(\n        'Le formulaire doit contenir au moins un champ de type \"ReactFormMakerStep\" lorsque le stepper est activ.',\n      );\n    } else if (stepFields.length === 1) {\n      console.warn(\n        'Le formulaire contient seulement un champ de type \"ReactFormMakerStep\". Le stepper n\\'est pas utile avec une seule tape.',\n      );\n    }\n  }\n}\n",
  "/ReactFormMaker/zodRFM/zodRFM.class.ts": "import { z, AnyZodObject, ZodTypeAny } from 'zod';\nimport { merge } from 'ts-deepmerge';\nimport type { ReactFormMakerFieldset } from '../interfaces/FieldInterfaces';\n\nexport interface ReferenceObject {\n  $ref: string;\n  summary?: string;\n  description?: string;\n}\n\nexport type SchemaObjectType =\n  | 'integer'\n  | 'number'\n  | 'string'\n  | 'boolean'\n  | 'object'\n  | 'null'\n  | 'array';\n\nexport type SchemaObject = Partial<ReactFormMakerFieldset> & {\n  type?: SchemaObjectType | SchemaObjectType[];\n  format?: string;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  minimum?: number;\n  exclusiveMinimum?: number;\n  multipleOf?: number;\n  additionalProperties?: Partial<SchemaObject> | ReferenceObject | boolean;\n  minItems?: number;\n  maxItems?: number;\n  oneOf?: SchemaObject[];\n  allOf?: SchemaObject[];\n  enum?: any[];\n  readOnly?: boolean;\n  description?: string;\n};\n\ntype RFMchemaObject = SchemaObject & { hideDefinitions?: string[] };\n\ninterface RFMZodAny extends ZodTypeAny {\n  metaReactFormMaker?: Partial<ReactFormMakerFieldset>;\n}\n\ninterface RFMAnyObject extends AnyZodObject {\n  metaReactFormMaker?: Partial<ReactFormMakerFieldset>;\n}\n\ntype RFMVersion = '1' | '1.2';\n\ninterface ParsingArgs<T> {\n  zodRef: T;\n  schemas: RFMAnyObject[];\n  useOutput?: boolean;\n  hideDefinitions?: string[];\n  RFMVersion: RFMVersion;\n}\n\nexport function extendApi<T extends RFMZodAny>(\n  schema: T,\n  schemaObject: Partial<ReactFormMakerFieldset> = {},\n): T {\n  const This = (schema as any).constructor;\n  const newSchema = new This(schema._def);\n  newSchema.metaOpenApi = Object.assign(\n    {},\n    schema.metaReactFormMaker || {},\n    schemaObject,\n  );\n  return newSchema;\n}\n\nfunction iterateZodObject({\n  zodRef,\n  useOutput,\n  hideDefinitions,\n  RFMVersion,\n}: ParsingArgs<RFMAnyObject>) {\n  const reduced = Object.keys(zodRef.shape)\n    .filter((key) => hideDefinitions?.includes(key) === false)\n    .reduce(\n      (carry, key) => ({\n        ...carry,\n        [key]: generateSchema(zodRef.shape[key], useOutput, RFMVersion),\n      }),\n      {} as Record<string, SchemaObject>,\n    );\n\n  return reduced;\n}\n\nfunction typeFormat<const T extends SchemaObjectType>(\n  type: T,\n  openApiVersion: RFMVersion,\n) {\n  return openApiVersion === '1' ? type : [type];\n}\n\nfunction parseTransformation({\n  zodRef,\n  schemas,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodTransformer<never> | z.ZodEffects<never>>): SchemaObject {\n  const input = generateSchema(zodRef._def.schema, useOutput, RFMVersion);\n  let output = 'undefined';\n  if (useOutput && zodRef._def.effect) {\n    const effect =\n      zodRef._def.effect.type === 'transform' ? zodRef._def.effect : null;\n    if (effect && 'transform' in effect) {\n      try {\n        const type = Array.isArray(input.type) ? input.type[0] : input.type;\n        output = typeof effect.transform(\n          ['integer', 'number'].includes(`${type}`)\n            ? 0\n            : 'string' === type\n              ? ''\n              : 'boolean' === type\n                ? false\n                : 'object' === type\n                  ? {}\n                  : 'null' === type\n                    ? null\n                    : 'array' === type\n                      ? []\n                      : undefined,\n          { addIssue: () => undefined, path: [] }, // TODO: Discover if context is necessary here\n        );\n      } catch (e) {\n        /**/\n      }\n    }\n  }\n  const outputType = output as 'number' | 'string' | 'boolean' | 'null';\n  return merge(\n    {\n      ...(zodRef.description ? { description: zodRef.description } : {}),\n      ...input,\n      ...(['number', 'string', 'boolean', 'null'].includes(output)\n        ? {\n            type: typeFormat(outputType, RFMVersion),\n          }\n        : {}),\n    },\n    ...schemas,\n  );\n}\n\nfunction parseString({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodString>): SchemaObject {\n  const baseSchema: SchemaObject = {\n    type: typeFormat('string', RFMVersion),\n  };\n  const { checks = [] } = zodRef._def;\n  checks.forEach((item) => {\n    switch (item.kind) {\n      case 'email':\n        baseSchema.format = 'email';\n        break;\n      case 'uuid':\n        baseSchema.format = 'uuid';\n        break;\n      case 'cuid':\n        baseSchema.format = 'cuid';\n        break;\n      case 'url':\n        baseSchema.format = 'uri';\n        break;\n      case 'datetime':\n        baseSchema.format = 'date-time';\n        break;\n      case 'length':\n        baseSchema.minLength = item.value;\n        baseSchema.maxLength = item.value;\n        break;\n      case 'max':\n        baseSchema.maxLength = item.value;\n        break;\n      case 'min':\n        baseSchema.minLength = item.value;\n        break;\n      case 'regex':\n        baseSchema.pattern = item.regex.source;\n        break;\n    }\n  });\n  return merge(\n    baseSchema,\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseNumber({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodNumber>): SchemaObject {\n  const baseSchema: SchemaObject = {\n    type: typeFormat('number', RFMVersion),\n  };\n  const { checks = [] } = zodRef._def;\n  checks.forEach((item) => {\n    switch (item.kind) {\n      case 'max':\n        if (item.inclusive) baseSchema.maximum = item.value;\n        else baseSchema.exclusiveMaximum = item.value;\n        break;\n      case 'min':\n        if (item.inclusive) baseSchema.minimum = item.value;\n        else baseSchema.exclusiveMinimum = item.value;\n        break;\n      case 'int':\n        baseSchema.type = typeFormat('integer', RFMVersion);\n        break;\n      case 'multipleOf':\n        baseSchema.multipleOf = item.value;\n        break;\n    }\n  });\n  return merge(\n    baseSchema,\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction getExcludedDefinitionsFromSchema(schemas: any): string[] {\n  const excludedDefinitions = [];\n  for (const schema of schemas) {\n    if (Array.isArray(schema.hideDefinitions)) {\n      excludedDefinitions.push(...schema.hideDefinitions);\n    }\n  }\n\n  return excludedDefinitions;\n}\n\nfunction parseObject({\n  zodRef,\n  schemas,\n  useOutput,\n  hideDefinitions,\n  RFMVersion,\n}: ParsingArgs<\n  z.ZodObject<never, 'passthrough' | 'strict' | 'strip'>\n>): SchemaObject {\n  let additionalProperties: SchemaObject['additionalProperties'];\n\n  // `catchall` obviates `strict`, `strip`, and `passthrough`\n  if (\n    !(\n      zodRef._def.catchall instanceof z.ZodNever ||\n      zodRef._def.catchall?._def.typeName === 'ZodNever'\n    )\n  ) {\n    additionalProperties = generateSchema(\n      zodRef._def.catchall,\n      useOutput,\n      RFMVersion,\n    );\n  } else if (zodRef._def.unknownKeys === 'passthrough') {\n    additionalProperties = true;\n  } else if (zodRef._def.unknownKeys === 'strict') {\n    additionalProperties = false;\n  }\n\n  // So that `undefined` values don't end up in the schema and be weird\n  additionalProperties =\n    additionalProperties != null ? additionalProperties : {};\n\n  const requiredProperties = Object.keys(\n    (zodRef as z.AnyZodObject).shape,\n  ).filter((key) => {\n    const item = (zodRef as z.AnyZodObject).shape[key];\n    return (\n      !(\n        item.isOptional() ||\n        item instanceof z.ZodDefault ||\n        item._def.typeName === 'ZodDefault'\n      ) && !(item instanceof z.ZodNever || item._def.typeName === 'ZodDefault')\n    );\n  });\n\n  const required =\n    requiredProperties.length > 0 ? { required: requiredProperties } : {};\n\n  return merge(\n    {\n      type: typeFormat('object', RFMVersion),\n      properties: iterateZodObject({\n        zodRef: zodRef as RFMAnyObject,\n        schemas,\n        useOutput,\n        hideDefinitions: getExcludedDefinitionsFromSchema(schemas),\n        RFMVersion,\n      }),\n      ...required,\n      additionalProperties,\n      ...hideDefinitions,\n    },\n    zodRef.description\n      ? { description: zodRef.description, hideDefinitions }\n      : {},\n    ...schemas,\n  );\n}\n\nfunction parseRecord({\n  zodRef,\n  schemas,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodRecord>): SchemaObject {\n  return merge(\n    {\n      type: typeFormat('object', RFMVersion),\n      additionalProperties:\n        zodRef._def.valueType instanceof z.ZodUnknown\n          ? true\n          : generateSchema(zodRef._def.valueType, useOutput, RFMVersion),\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseBigInt({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodBigInt>): SchemaObject {\n  return merge(\n    {\n      type: typeFormat('integer', RFMVersion),\n      format: 'int64',\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseBoolean({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodBoolean>): SchemaObject {\n  return merge(\n    { type: typeFormat('boolean', RFMVersion) },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseDate({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodDate>): SchemaObject {\n  return merge(\n    {\n      type: typeFormat('string', RFMVersion),\n      format: 'date-time',\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseNull({\n  zodRef,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodNull>): SchemaObject {\n  return merge(\n    RFMVersion === '1'\n      ? { type: 'null' as SchemaObjectType }\n      : {\n          type: ['string', 'null'] as SchemaObjectType[],\n          enum: ['null'],\n        },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseOptional({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodOptional<RFMZodAny>>): SchemaObject {\n  return merge(\n    generateSchema(zodRef.unwrap(), useOutput, RFMVersion),\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseNullable({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodNullable<RFMZodAny>>): SchemaObject {\n  const schema = generateSchema(zodRef.unwrap(), useOutput, RFMVersion);\n  return merge(\n    schema,\n    { type: typeFormat('null', RFMVersion) },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseDefault({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodDefault<RFMZodAny>>): SchemaObject {\n  return merge(\n    {\n      default: zodRef._def.defaultValue(),\n      ...generateSchema(zodRef._def.innerType, useOutput, RFMVersion),\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseArray({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodArray<RFMZodAny>>): SchemaObject {\n  const constraints: Partial<SchemaObject> = {};\n  if (zodRef._def.exactLength != null) {\n    constraints.minItems = zodRef._def.exactLength.value;\n    constraints.maxItems = zodRef._def.exactLength.value;\n  }\n\n  if (zodRef._def.minLength != null)\n    constraints.minItems = zodRef._def.minLength.value;\n  if (zodRef._def.maxLength != null)\n    constraints.maxItems = zodRef._def.maxLength.value;\n\n  return merge(\n    {\n      type: typeFormat('array', RFMVersion),\n      items: generateSchema(zodRef.element, useOutput, RFMVersion),\n      ...constraints,\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseLiteral({\n  schemas,\n  zodRef,\n  RFMVersion,\n}: ParsingArgs<z.ZodLiteral<RFMZodAny>>): SchemaObject {\n  const type = typeof zodRef._def.value as 'string' | 'number' | 'boolean';\n  return merge(\n    {\n      type: typeFormat(type, RFMVersion),\n      enum: [zodRef._def.value],\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseEnum({\n  schemas,\n  zodRef,\n  RFMVersion,\n}: ParsingArgs<z.ZodEnum<never> | z.ZodNativeEnum<never>>): SchemaObject {\n  const type = typeof Object.values(zodRef._def.values)[0] as\n    | 'string'\n    | 'number';\n  return merge(\n    {\n      type: typeFormat(type, RFMVersion),\n      enum: Object.values(zodRef._def.values),\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseIntersection({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodIntersection<z.ZodTypeAny, z.ZodTypeAny>>): SchemaObject {\n  return merge(\n    {\n      type: typeFormat('object', RFMVersion),\n      allOf: [\n        generateSchema(zodRef._def.left, useOutput, RFMVersion),\n        generateSchema(zodRef._def.right, useOutput, RFMVersion),\n      ],\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseUnion({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodUnion<[z.ZodTypeAny, ...z.ZodTypeAny[]]>>): SchemaObject {\n  const contents = zodRef._def.options;\n  if (\n    contents.reduce(\n      (prev, content) => prev && content._def.typeName === 'ZodLiteral',\n      true,\n    )\n  ) {\n    // special case to transform unions of literals into enums\n    const literals = contents as unknown as z.ZodLiteral<RFMZodAny>[];\n    const type = literals.reduce(\n      (prev, content) =>\n        !prev || prev === typeof content._def.value\n          ? typeof content._def.value\n          : null,\n      null as null | string,\n    );\n\n    if (type) {\n      const baseSchema: SchemaObject = {\n        type: typeFormat(type as SchemaObjectType, RFMVersion),\n        enum: literals.map((literal) => literal._def.value),\n      };\n\n      const descriptionSchema = zodRef.description\n        ? { description: zodRef.description }\n        : {};\n\n      return merge(baseSchema, descriptionSchema, ...schemas);\n    }\n  }\n\n  const baseSchema: SchemaObject = {\n    oneOf: contents.map((schema) =>\n      generateSchema(schema, useOutput, RFMVersion),\n    ),\n  };\n\n  const descriptionSchema = zodRef.description\n    ? { description: zodRef.description }\n    : {};\n\n  return merge(baseSchema, descriptionSchema, ...schemas);\n}\n\nfunction parseDiscriminatedUnion({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<\n  z.ZodDiscriminatedUnion<string, z.ZodDiscriminatedUnionOption<string>[]>\n>): SchemaObject {\n  return merge(\n    {\n      discriminator: {\n        propertyName: (\n          zodRef as z.ZodDiscriminatedUnion<\n            string,\n            z.ZodDiscriminatedUnionOption<string>[]\n          >\n        )._def.discriminator,\n      },\n      oneOf: Array.from(\n        (\n          zodRef as z.ZodDiscriminatedUnion<\n            string,\n            z.ZodDiscriminatedUnionOption<string>[]\n          >\n        )._def.options.values(),\n      ).map((schema) => generateSchema(schema, useOutput, RFMVersion)),\n    },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseNever({\n  zodRef,\n  schemas,\n}: ParsingArgs<z.ZodNever>): SchemaObject {\n  return merge(\n    { readOnly: true },\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction parseBranded({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodBranded<z.ZodAny, string>>): SchemaObject {\n  return merge(\n    generateSchema(zodRef._def.type, useOutput, RFMVersion),\n    ...schemas,\n  );\n}\n\nfunction parsePipeline({\n  schemas,\n  zodRef,\n  useOutput,\n  RFMVersion,\n}: ParsingArgs<z.ZodPipeline<never, never>>): SchemaObject {\n  return merge(\n    generateSchema(\n      useOutput ? zodRef._def.out : zodRef._def.in,\n      useOutput,\n      RFMVersion,\n    ),\n    ...schemas,\n  );\n}\n\nfunction parseReadonly({\n  zodRef,\n  useOutput,\n  schemas,\n  RFMVersion,\n}: ParsingArgs<z.ZodReadonly<z.ZodAny>>): SchemaObject {\n  return merge(\n    generateSchema(zodRef._def.innerType, useOutput, RFMVersion),\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nfunction catchAllParser({\n  zodRef,\n  schemas,\n}: ParsingArgs<ZodTypeAny>): SchemaObject {\n  return merge(\n    zodRef.description ? { description: zodRef.description } : {},\n    ...schemas,\n  );\n}\n\nconst workerMap = {\n  ZodObject: parseObject,\n  ZodRecord: parseRecord,\n  ZodString: parseString,\n  ZodNumber: parseNumber,\n  ZodBigInt: parseBigInt,\n  ZodBoolean: parseBoolean,\n  ZodDate: parseDate,\n  ZodNull: parseNull,\n  ZodOptional: parseOptional,\n  ZodNullable: parseNullable,\n  ZodDefault: parseDefault,\n  ZodArray: parseArray,\n  ZodLiteral: parseLiteral,\n  ZodEnum: parseEnum,\n  ZodNativeEnum: parseEnum,\n  ZodTransformer: parseTransformation,\n  ZodEffects: parseTransformation,\n  ZodIntersection: parseIntersection,\n  ZodUnion: parseUnion,\n  ZodDiscriminatedUnion: parseDiscriminatedUnion,\n  ZodNever: parseNever,\n  ZodBranded: parseBranded,\n  // TODO Transform the rest to schemas\n  ZodUndefined: catchAllParser,\n  // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples\n  ZodTuple: catchAllParser,\n  ZodMap: catchAllParser,\n  ZodFunction: catchAllParser,\n  ZodLazy: catchAllParser,\n  ZodPromise: catchAllParser,\n  ZodAny: catchAllParser,\n  ZodUnknown: catchAllParser,\n  ZodVoid: catchAllParser,\n  ZodPipeline: parsePipeline,\n  ZodReadonly: parseReadonly,\n};\ntype WorkerKeys = keyof typeof workerMap;\n\nexport function generateSchema(\n  zodRef: RFMZodAny,\n  useOutput = false,\n  RFMVersion: RFMVersion = '1',\n): SchemaObject {\n  const { metaReactFormMaker = {} } = zodRef;\n  const schemas = [\n    ...(Array.isArray(metaReactFormMaker)\n      ? metaReactFormMaker\n      : [metaReactFormMaker]),\n  ];\n  try {\n    const typeName = zodRef._def.typeName as WorkerKeys;\n    if (typeName in workerMap) {\n      return workerMap[typeName]({\n        zodRef: zodRef as never,\n        schemas,\n        useOutput,\n        RFMVersion,\n      });\n    }\n\n    return catchAllParser({ zodRef, schemas, RFMVersion });\n  } catch (err) {\n    console.error(err);\n    return catchAllParser({ zodRef, schemas, RFMVersion });\n  }\n}\n",
  "/lib/commandManager.interface.ts": "/**\n * **Gestionnaire de commandes**\n *\n * ---\n *\n * Un gestionnaire de commandes permet d'excuter une srie de commandes de manire progressive. Les commandes sont excutes dans\n * l'ordre o elles ont t ajoutes, et peuvent partager des donnes via un contexte global.\n *\n * ---\n *\n * #### Exemple d'utilisation\n * ```ts\n * const manager = new CommandManager();\n *\n * manager.addCommand('greet', async (context) => {\n *   console.log('Hello', context.user.name);\n *   return { success: true };\n * });\n *\n * manager.addCommand('farewell', async (context) => {\n *   console.log('Goodbye', context.user.name);\n *   return { success: true };\n * });\n *\n * manager.setContext({ user: { name: 'John Doe' } });\n *\n * const result = await manager.execute();\n * console.log('All commands executed successfully:', result);\n * ```\n */\n\nexport type CommandResult<T = unknown> = {\n  success: boolean;\n  data?: T;\n};\n\nexport type Command<TContext = Record<string, unknown>> = (\n  context: TContext,\n) => Promise<CommandResult>;\n\nexport interface NamedCommand<TContext = Record<string, unknown>> {\n  name: string;\n  command: Command<TContext>;\n}\n\nexport interface CommandManagerInterface<\n  TContext extends Record<string, unknown> = Record<string, unknown>,\n> {\n  /**\n   * **Ajouter une commande**\n   *\n   * Ajoute une commande  la liste des commandes  excuter. Une commande doit tre identifie par un nom unique.\n   *\n   * #### Exemple\n   * ```ts\n   * manager.addCommand('init', async (context) => {\n   *   console.log('Initialisation du contexte');\n   *   return { success: true };\n   * });\n   * ```\n   *\n   * @param name - Le nom unique de la commande.\n   * @param command - La fonction asynchrone reprsentant la commande.\n   */\n  addCommand(name: string, command: Command<TContext>): void;\n\n  /**\n   * **Ajouter plusieurs commandes**\n   *\n   * Ajoute une liste de commandes nommes.\n   *\n   * #### Exemple\n   * ```ts\n   * manager.addCommands([\n   *   { name: 'step1', command: async (context) => ({ success: true }) },\n   *   { name: 'step2', command: async (context) => ({ success: true }) },\n   * ]);\n   * ```\n   *\n   * @param commands - La liste des commandes  ajouter.\n   */\n  addCommands(commands: NamedCommand<TContext>[]): void;\n\n  /**\n   * **Dfinir ou mettre  jour le contexte**\n   *\n   * Ajoute ou met  jour les donnes du contexte global partag entre les commandes.\n   *\n   * #### Exemple\n   * ```ts\n   * manager.setContext({ user: { id: 123, name: 'Jane' } });\n   * ```\n   *\n   * @param partialContext - Un objet contenant les donnes  fusionner avec le contexte actuel.\n   */\n  setContext(partialContext: Partial<TContext>): void;\n\n  /**\n   * **Excuter toutes les commandes**\n   *\n   * Excute les commandes dans l'ordre o elles ont t ajoutes. Si une commande choue, l'excution s'arrte.\n   *\n   * #### Exemple\n   * ```ts\n   * const result = await manager.execute();\n   * console.log(result ? 'Success' : 'Failure');\n   * ```\n   *\n   * @returns `true` si toutes les commandes ont russi, `false` sinon.\n   */\n  execute(): Promise<boolean>;\n\n  /**\n   * **Rinitialiser le gestionnaire**\n   *\n   * Supprime toutes les commandes et rinitialise le contexte.\n   *\n   * #### Exemple\n   * ```ts\n   * manager.reset();\n   * ```\n   */\n  reset(): void;\n\n  /**\n   * **Obtenir le contexte actuel**\n   *\n   * Retourne une copie immuable du contexte global.\n   *\n   * #### Exemple\n   * ```ts\n   * const currentContext = manager.getContext();\n   * console.log(currentContext);\n   * ```\n   *\n   * @returns Une copie du contexte global actuel.\n   */\n  getContext(): Readonly<TContext>;\n\n  /**\n   * **Obtenir la liste des commandes**\n   *\n   * Retourne une copie immuable des commandes enregistres.\n   *\n   * #### Exemple\n   * ```ts\n   * const commands = manager.getCommands();\n   * console.log(commands);\n   * ```\n   *\n   * @returns Une liste immuable des commandes enregistres.\n   */\n  getCommands(): Readonly<NamedCommand<TContext>[]>;\n\n  /**\n   * **Excuter une commande spcifique**\n   *\n   * Excute uniquement une commande identifie par son nom.\n   *\n   * #### Exemple\n   * ```ts\n   * const result = await manager.executeOnly('greet');\n   * console.log(result);\n   * ```\n   *\n   * @param name - Le nom de la commande  excuter.\n   * @returns Le rsultat de la commande, ou `null` si elle n'existe pas.\n   */\n  executeOnly(name: string): Promise<CommandResult | null>;\n\n  /**\n   * **Excuter les commandes suivantes**\n   *\n   * Excute toutes les commandes qui se trouvent aprs une commande donne.\n   *\n   * #### Exemple\n   * ```ts\n   * const success = await manager.executeAfter('step1');\n   * console.log(success);\n   * ```\n   *\n   * @param name - Le nom de la commande aprs laquelle commencer.\n   * @returns `true` si toutes les commandes restantes ont russi, `false` sinon.\n   */\n  executeAfter(name: string): Promise<boolean>;\n\n  /**\n   * **Excuter un sous-ensemble de commandes**\n   *\n   * Excute une liste spcifique de commandes.\n   *\n   * #### Exemple\n   * ```ts\n   * const subset = manager.getCommands().slice(1, 3);\n   * const success = await manager.executeSubset(subset);\n   * console.log(success);\n   * ```\n   *\n   * @param commands - La liste des commandes  excuter.\n   * @returns `true` si toutes les commandes ont russi, `false` sinon.\n   */\n  executeSubset(commands: NamedCommand<TContext>[]): Promise<boolean>;\n}\n",
  "/lib/commandManager.ts": "import type {\n  Command,\n  CommandManagerInterface,\n  CommandResult,\n  NamedCommand,\n} from './commandManager.interface';\n\nexport class CommandManager<\n  TContext extends Record<string, unknown> = Record<string, unknown>,\n> implements CommandManagerInterface<TContext>\n{\n  private commands: NamedCommand<TContext>[] = [];\n  private context: TContext;\n\n  constructor(initialContext: Partial<TContext> = {}) {\n    this.context = initialContext as TContext;\n  }\n\n  addCommand(name: string, command: Command<TContext>): void {\n    if (this.commands.some((c) => c.name === name)) {\n      throw new Error(`Une commande avec le nom \"${name}\" existe dj.`);\n    }\n    this.commands.push({ name, command });\n  }\n\n  addCommands(namedCommands: NamedCommand<TContext>[]): void {\n    namedCommands.forEach(({ name, command }) =>\n      this.addCommand(name, command),\n    );\n  }\n\n  setContext(partialContext: Partial<TContext>): void {\n    Object.assign(this.context, partialContext);\n  }\n\n  async execute(): Promise<boolean> {\n    for (const { name, command } of this.commands) {\n      const result = await command(this.context);\n\n      if (!result.success) {\n        console.error(`Command \"${name}\" failed:`, result);\n        return false;\n      }\n\n      if (result.data) {\n        Object.assign(this.context, result.data);\n      }\n    }\n    return true;\n  }\n\n  reset(): void {\n    this.commands = [];\n    this.context = {} as TContext;\n  }\n\n  getContext(): Readonly<TContext> {\n    return { ...this.context };\n  }\n\n  getCommands(): Readonly<NamedCommand<TContext>[]> {\n    return [...this.commands];\n  }\n\n  async executeOnly(name: string): Promise<CommandResult | null> {\n    const command = this.commands.find((c) => c.name === name);\n    if (!command) {\n      console.warn(`Aucune commande trouve avec le nom \"${name}\".`);\n      return null;\n    }\n    const result = await command.command(this.context);\n    if (result.data) {\n      Object.assign(this.context, result.data);\n    }\n    return result;\n  }\n\n  async executeAfter(name: string): Promise<boolean> {\n    const index = this.commands.findIndex((c) => c.name === name);\n    if (index === -1) {\n      console.warn(`Aucune commande trouve avec le nom \"${name}\".`);\n      return false;\n    }\n    const commandsToExecute = this.commands.slice(index + 1);\n    return this.executeSubset(commandsToExecute);\n  }\n\n  async executeSubset(commands: NamedCommand<TContext>[]): Promise<boolean> {\n    for (const { name, command } of commands) {\n      const result = await command(this.context);\n\n      if (!result.success) {\n        console.error(`Command \"${name}\" failed:`, result);\n        return false;\n      }\n\n      if (result.data) {\n        Object.assign(this.context, result.data);\n      }\n    }\n    return true;\n  }\n}\n",
  "/lib/useGenerateUUIDs.ts": "import { useRef } from 'react';\nimport { v4 as uuidV4 } from 'uuid';\n\n/**\n * Custom hook pour gnrer des UUIDs pour chaque lment d'un tableau.\n * @template T Le type des lments du tableau.\n * @param {T[]} array - Le tableau pour lequel gnrer des UUIDs.\n * @returns {string[]} - Un tableau d'UUIDs.\n */\n/**\n * Gnre des cls stables pour chaque lment du tableau, en utilisant une proprit unique si possible.\n * Si aucune proprit unique n'est disponible, utilise le type + index comme fallback.\n */\nexport function useGenerateUUIDs<T>(array: T[]): string[] {\n  const uuidMap = useRef<Map<T, string>>(new Map());\n\n  return array.map((item) => {\n    if (!uuidMap.current.has(item)) {\n      uuidMap.current.set(item, uuidV4());\n    }\n    return uuidMap.current.get(item)!;\n  });\n}\n",
  "/lib/usePromiseObserver.ts": "import { useState, useCallback } from 'react';\n\ninterface PromiseState<T> {\n  loading: boolean;\n  data: T | null;\n  error: Error | null;\n}\n\ninterface UsePromiseObserverResult<T, R> {\n  states: { [key: string]: PromiseState<R> };\n  execute: (key: string, data: T) => void;\n  listener: (key: string) => 'idle' | 'loading' | 'resolved' | 'rejected';\n}\n\ninterface PromiseMap<T, R> {\n  [key: string]: (data: T) => Promise<R>;\n}\n\nexport function usePromiseObserver<T, R>(\n  promiseMap: PromiseMap<T, R>,\n): UsePromiseObserverResult<T, R> {\n  const [states, setStates] = useState<{ [key: string]: PromiseState<R> }>(() =>\n    Object.keys(promiseMap).reduce(\n      (acc, key) => {\n        acc[key] = { loading: false, data: null, error: null };\n        return acc;\n      },\n      {} as { [key: string]: PromiseState<R> },\n    ),\n  );\n\n  const execute = useCallback(\n    (key: string, data: T) => {\n      setStates((prevStates) => ({\n        ...prevStates,\n        [key]: { loading: true, data: null, error: null },\n      }));\n\n      promiseMap[key](data)\n        .then((result) => {\n          setStates((prevStates) => ({\n            ...prevStates,\n            [key]: { loading: false, data: result, error: null },\n          }));\n        })\n        .catch((err) => {\n          setStates((prevStates) => ({\n            ...prevStates,\n            [key]: { loading: false, data: null, error: err }, // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n          }));\n        });\n    },\n    [promiseMap],\n  );\n\n  const listener = useCallback(\n    (key: string) => {\n      if (!states[key]) {\n        return 'idle';\n      }\n      const state = states[key];\n      if (\n        state.loading === false &&\n        state.error !== null &&\n        state.data !== null\n      ) {\n        return 'idle';\n      }\n      if (state.loading === true) {\n        return 'loading';\n      }\n      if (state.data !== null) {\n        return 'resolved';\n      }\n      if (state.error !== null) {\n        return 'rejected';\n      }\n      return 'idle'; // Default case\n    },\n    [states],\n  );\n\n  return { states, execute, listener };\n}\n",
  "/lib/utils.ts": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\nimport React from 'react';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function mergeRefs<T = any>( // eslint-disable-line @typescript-eslint/no-explicit-any\n  ...refs: Array<\n    React.MutableRefObject<T> | React.LegacyRef<T> | undefined | null\n  >\n): React.RefCallback<T> | null {\n  return (value: T | null) => {\n    refs.forEach((ref) => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n\nexport function formatBytes(\n  bytes: number,\n  opts: {\n    decimals?: number;\n    sizeType?: 'accurate' | 'normal';\n  } = {},\n) {\n  const { decimals = 0, sizeType = 'normal' } = opts;\n\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const accurateSizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB'];\n  if (bytes === 0) return '0 Byte';\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return `${(bytes / Math.pow(1024, i)).toFixed(decimals)} ${\n    sizeType === 'accurate'\n      ? (accurateSizes[i] ?? 'Bytes')\n      : (sizes[i] ?? 'Bytes')\n  }`;\n}\n",
  "/components/ui/Typography.tsx": "import React from 'react';\n\ninterface Props {\n  className?: string;\n  children: string | string[] | React.ReactNode;\n}\n\nconst H1: React.FC<Props> = ({ className, children }) => {\n  return (\n    <h1\n      className={`scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl ${className}`}\n    >\n      {children}\n    </h1>\n  );\n};\n\nconst H2: React.FC<Props> = ({ className, children }) => {\n  return (\n    <h2\n      className={`scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0 ${className}`}\n    >\n      {children}\n    </h2>\n  );\n};\n\nconst H3: React.FC<Props> = ({ className, children }) => {\n  return (\n    <h3\n      className={`scroll-m-20 text-2xl font-semibold tracking-tight ${className}`}\n    >\n      {children}\n    </h3>\n  );\n};\n\nconst H4: React.FC<Props> = ({ className, children }) => {\n  return (\n    <h4\n      className={`scroll-m-20 text-xl font-semibold tracking-tight ${className}`}\n    >\n      {children}\n    </h4>\n  );\n};\n\nconst P: React.FC<Props> = ({ className, children }) => {\n  return (\n    <p className={`leading-7 [&:not(:first-child)]:mt-6 ${className}`}>\n      {children}\n    </p>\n  );\n};\n\nconst Blockquote: React.FC<Props> = ({ className, children }) => {\n  return (\n    <blockquote className={`mt-6 border-l-2 pl-6 italic ${className}`}>\n      {children}\n    </blockquote>\n  );\n};\n\nconst InlineCode: React.FC<Props> = ({ className, children }) => {\n  return (\n    <code\n      className={`relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold ${className}`}\n    >\n      {children}\n    </code>\n  );\n};\n\nconst Lead: React.FC<Props> = ({ className, children }) => {\n  return (\n    <p className={`text-xl text-muted-foreground ${className}`}>{children}</p>\n  );\n};\n\nconst Large: React.FC<Props> = ({ className, children }) => {\n  return <div className={`text-lg font-semibold ${className}`}>{children}</div>;\n};\n\nconst Muted: React.FC<Props> = ({ className, children }) => {\n  return (\n    <p className={`text-sm text-muted-foreground ${className}`}>{children}.</p>\n  );\n};\n\nexport { H1, H2, H3, H4, P, Lead, Large, Muted, Blockquote, InlineCode };\n"
}